# abacus-jdbc API Index (v4.3.1)
- Build: unknown
- Java: 17
- Generated: 2026-02-09

## Packages
- com.landawn.abacus.jdbc
- com.landawn.abacus.jdbc.annotation
- com.landawn.abacus.jdbc.dao

## com.landawn.abacus.jdbc
### Class AbstractQuery (com.landawn.abacus.jdbc.AbstractQuery)
Abstract base class for JDBC query operations that provides a fluent API for executing SQL queries and updates with PreparedStatement.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### closeAfterExecution(...) -> This
- **Signature:** `public This closeAfterExecution(final boolean closeAfterExecution) throws IllegalStateException`
- **Summary:** Sets whether the PreparedStatement should be closed after execution.
- **Contract:**
  - Sets whether the PreparedStatement should be closed after execution.
  - <p> Set to {@code false} if you want to reuse the statement for multiple executions, but ensure you manually close it when done.
- **Parameters:**
  - `closeAfterExecution` (`boolean`) — If {@code true} , the statement will be closed after execution. Default is {@code true} .
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalStateException` — if the query is already closed
##### onClose(...) -> This
- **Signature:** `@SuppressWarnings("hiding") public This onClose(final Runnable closeHandler) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Registers a callback to be executed when this query is closed.
- **Contract:**
  - Registers a callback to be executed when this query is closed.
- **Parameters:**
  - `closeHandler` (`Runnable`) — A task to execute after this {@code Query} is closed
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if closeHandler is null
  - `java.lang.IllegalStateException` — if this query is already closed
##### setNull(...) -> This
- **Signature:** `public This setNull(final int parameterIndex, final int sqlType) throws SQLException`
- **Summary:** Sets a SQL NULL value for the specified parameter.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set to {@code null} , starting from 1
  - `sqlType` (`int`) — the SQL type code defined in {@link java.sql.Types}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
- **Signature:** `public This setNull(final int parameterIndex, final int sqlType, final String typeName) throws SQLException`
- **Summary:** Sets a SQL NULL value for the specified parameter with a type name.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set to {@code null} , starting from 1
  - `sqlType` (`int`) — the SQL type code defined in {@link java.sql.Types}
  - `typeName` (`String`) — the fully-qualified name of an SQL user-defined type
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBoolean(...) -> This
- **Signature:** `public This setBoolean(final int parameterIndex, final boolean x) throws SQLException`
- **Summary:** Sets a boolean parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`boolean`) — the boolean value to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setBoolean(final int parameterIndex, final Boolean x) throws SQLException`
- **Summary:** Sets a Boolean parameter value, handling {@code null} values.
- **Contract:**
  - If the value is {@code null} , sets the parameter to SQL NULL.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Boolean`) — the Boolean value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setBoolean(final int parameterIndex, final Boolean x, final boolean defaultValueForNull) throws SQLException`
- **Summary:** Sets a Boolean parameter value with a default value for {@code null} .
- **Contract:**
  - If the value is {@code null} , uses the specified default value instead of SQL NULL.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setBoolean(1, nullableBoolean, false); // use false if null } </pre>
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Boolean`) — the Boolean value to set, or {@code null} to use the default value
  - `defaultValueForNull` (`boolean`) — the boolean value to use if {@code x} is {@code null}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setByte(...) -> This
- **Signature:** `public This setByte(final int parameterIndex, final byte x) throws SQLException`
- **Summary:** Sets a byte parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`byte`) — the byte value to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setByte(final int parameterIndex, final Byte x) throws SQLException`
- **Summary:** Sets a Byte parameter value, handling {@code null} values.
- **Contract:**
  - If the value is {@code null} , sets the parameter to SQL NULL.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Byte`) — the Byte value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setByte(final int parameterIndex, final Byte x, final byte defaultValueForNull) throws SQLException`
- **Summary:** Sets a Byte parameter value with a default value for {@code null} .
- **Contract:**
  - If the value is {@code null} , uses the specified default value instead of SQL NULL.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setByte(1, nullableByte, (byte)0); // use 0 if null } </pre>
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Byte`) — the Byte value to set, or {@code null} to use the default value
  - `defaultValueForNull` (`byte`) — the byte value to use if {@code x} is {@code null}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setShort(...) -> This
- **Signature:** `public This setShort(final int parameterIndex, final short x) throws SQLException`
- **Summary:** Sets a short parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`short`) — the short value to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setShort(final int parameterIndex, final Short x) throws SQLException`
- **Summary:** Sets a Short parameter value, handling {@code null} values.
- **Contract:**
  - If the value is {@code null} , sets the parameter to SQL NULL.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Short`) — the Short value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setShort(final int parameterIndex, final Short x, final short defaultValueForNull) throws SQLException`
- **Summary:** Sets a Short parameter value with a default value for {@code null} .
- **Contract:**
  - If the value is {@code null} , uses the specified default value instead of SQL NULL.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setShort(1, nullableShort, (short)0); // use 0 if null } </pre>
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Short`) — the Short value to set, or {@code null} to use the default value
  - `defaultValueForNull` (`short`) — the short value to use if {@code x} is {@code null}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setInt(...) -> This
- **Signature:** `public This setInt(final int parameterIndex, final int x) throws SQLException`
- **Summary:** Sets an int parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`int`) — the int value to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setInt(final int parameterIndex, final Integer x) throws SQLException`
- **Summary:** Sets an Integer parameter value, handling {@code null} values.
- **Contract:**
  - If the value is {@code null} , sets the parameter to SQL NULL.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Integer`) — the Integer value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public This setInt(final int parameterIndex, final Integer x, final int defaultValueForNull) throws SQLException`
- **Summary:** Sets an Integer parameter value with a default value for {@code null} .
- **Contract:**
  - If the value is {@code null} , uses the specified default value instead of SQL NULL.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setInt(1, nullableCount, 0); // use 0 if null } </pre>
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Integer`) — the Integer value to set, or {@code null} to use the default value
  - `defaultValueForNull` (`int`) — the int value to use if {@code x} is {@code null}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta public This setInt(final int parameterIndex, final char x) throws SQLException`
- **Summary:** Sets a char parameter value as an integer.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`char`) — the char value to set as an integer
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setString(int, char)
- **Signature:** `@Deprecated @Beta public This setInt(final int parameterIndex, final Character x) throws SQLException`
- **Summary:** Sets a Character parameter value as an integer, handling {@code null} values.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Character`) — the Character value to set as an integer, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setString(int, Character)
##### setLong(...) -> This
- **Signature:** `public This setLong(final int parameterIndex, final long x) throws SQLException`
- **Summary:** Sets a long parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`long`) — the long value to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setLong(final int parameterIndex, final Long x) throws SQLException`
- **Summary:** Sets a Long parameter value, handling {@code null} values.
- **Contract:**
  - If the value is {@code null} , sets the parameter to SQL NULL.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Long`) — the Long value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public This setLong(final int parameterIndex, final Long x, final long defaultValueForNull) throws SQLException`
- **Summary:** Sets a Long parameter value with a default value for {@code null} .
- **Contract:**
  - If the value is {@code null} , uses the specified default value instead of SQL NULL.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setLong(1, nullableId, -1L); // use -1 if null } </pre>
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Long`) — the Long value to set, or {@code null} to use the default value
  - `defaultValueForNull` (`long`) — the long value to use if {@code x} is {@code null}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setLong(final int parameterIndex, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger parameter value as a long.
- **Contract:**
  - The BigInteger must be within the range of a long value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setFloat(...) -> This
- **Signature:** `public This setFloat(final int parameterIndex, final float x) throws SQLException`
- **Summary:** Sets a float parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`float`) — the float value to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setFloat(final int parameterIndex, final Float x) throws SQLException`
- **Summary:** Sets a Float parameter value, handling {@code null} values.
- **Contract:**
  - If the value is {@code null} , sets the parameter to SQL NULL.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Float`) — the Float value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setFloat(final int parameterIndex, final Float x, final float defaultValueForNull) throws SQLException`
- **Summary:** Sets a Float parameter value with a default value for {@code null} .
- **Contract:**
  - If the value is {@code null} , uses the specified default value instead of SQL NULL.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setFloat(1, nullableRating, 0.0f); // use 0.0 if null } </pre>
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Float`) — the Float value to set, or {@code null} to use the default value
  - `defaultValueForNull` (`float`) — the float value to use if {@code x} is {@code null}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setDouble(...) -> This
- **Signature:** `public This setDouble(final int parameterIndex, final double x) throws SQLException`
- **Summary:** Sets a double parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`double`) — the double value to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setDouble(final int parameterIndex, final Double x) throws SQLException`
- **Summary:** Sets a Double parameter value, handling {@code null} values.
- **Contract:**
  - If the value is {@code null} , sets the parameter to SQL NULL.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Double`) — the Double value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setDouble(final int parameterIndex, final Double x, final double defaultValueForNull) throws SQLException`
- **Summary:** Sets a Double parameter value with a default value for {@code null} .
- **Contract:**
  - If the value is {@code null} , uses the specified default value instead of SQL NULL.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setDouble(1, nullablePrice, 0.0); // use 0.0 if null } </pre>
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Double`) — the Double value to set, or {@code null} to use the default value
  - `defaultValueForNull` (`double`) — the double value to use if {@code x} is {@code null}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBigDecimal(...) -> This
- **Signature:** `public This setBigDecimal(final int parameterIndex, final BigDecimal x) throws SQLException`
- **Summary:** Sets a BigDecimal parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`BigDecimal`) — the BigDecimal value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setBigDecimal(final int parameterIndex, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger parameter value as a BigDecimal.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBigIntegerAsString(...) -> This
- **Signature:** `@Beta public This setBigIntegerAsString(final int parameterIndex, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger parameter value as a String.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setString(int, BigInteger)
##### setString(...) -> This
- **Signature:** `public This setString(final int parameterIndex, final String x) throws SQLException`
- **Summary:** Sets a String parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`String`) — the String value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setString(final int parameterIndex, final CharSequence x) throws SQLException`
- **Summary:** Sets a CharSequence parameter value as a String.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`CharSequence`) — the CharSequence value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setString(final int parameterIndex, final char x) throws SQLException`
- **Summary:** Sets a char parameter value as a String.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`char`) — the char value to set as a String
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setString(final int parameterIndex, final Character x) throws SQLException`
- **Summary:** Sets a Character parameter value as a String, handling {@code null} values.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Character`) — the Character value to set as a String, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public This setString(final int parameterIndex, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger parameter value as a String.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`BigInteger`) — the BigInteger value to set as a String, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setBigIntegerAsString(int, BigInteger)
##### setNString(...) -> This
- **Signature:** `public This setNString(final int parameterIndex, final String x) throws SQLException`
- **Summary:** Sets a national character set String (NCHAR, NVARCHAR, LONGNVARCHAR) parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`String`) — the String value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setNString(final int parameterIndex, final CharSequence x) throws SQLException`
- **Summary:** Sets a national character set CharSequence (NCHAR, NVARCHAR, LONGNVARCHAR) parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`CharSequence`) — the CharSequence value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setDate(...) -> This
- **Signature:** `public This setDate(final int parameterIndex, final java.sql.Date x) throws SQLException`
- **Summary:** Sets a java.sql.Date parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Date`) — the Date value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setDate(final int parameterIndex, final java.util.Date x) throws SQLException`
- **Summary:** Sets a java.util.Date parameter value as a SQL Date.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.util.Date`) — the Date value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setDate(final int parameterIndex, final java.sql.Date x, final Calendar cal) throws SQLException`
- **Summary:** Sets a SQL Date parameter value using a Calendar for timezone conversion.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Date`) — the Date value to set, or {@code null} to set SQL NULL
  - `cal` (`Calendar`) — the Calendar object to use for timezone conversion
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setDate(final int parameterIndex, final LocalDate x) throws SQLException`
- **Summary:** Sets a LocalDate parameter value as a SQL Date.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`LocalDate`) — the LocalDate value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setTime(...) -> This
- **Signature:** `public This setTime(final int parameterIndex, final java.sql.Time x) throws SQLException`
- **Summary:** Sets a java.sql.Time parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Time`) — the Time value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTime(final int parameterIndex, final java.util.Date x) throws SQLException`
- **Summary:** Sets a java.util.Date parameter value as a SQL Time.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.util.Date`) — the Date value to set as Time, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTime(final int parameterIndex, final java.sql.Time x, final Calendar cal) throws SQLException`
- **Summary:** Sets a SQL Time parameter value using a Calendar for timezone conversion.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Time`) — the Time value to set, or {@code null} to set SQL NULL
  - `cal` (`Calendar`) — the Calendar object to use for timezone conversion
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTime(final int parameterIndex, final LocalTime x) throws SQLException`
- **Summary:** Sets a LocalTime parameter value as a SQL Time.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`LocalTime`) — the LocalTime value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setTimestamp(...) -> This
- **Signature:** `public This setTimestamp(final int parameterIndex, final java.sql.Timestamp x) throws SQLException`
- **Summary:** Sets a java.sql.Timestamp parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Timestamp`) — the Timestamp value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTimestamp(final int parameterIndex, final java.util.Date x) throws SQLException`
- **Summary:** Sets a java.util.Date parameter value as a SQL Timestamp.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.util.Date`) — the Date value to set as Timestamp, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTimestamp(final int parameterIndex, final java.sql.Timestamp x, final Calendar cal) throws SQLException`
- **Summary:** Sets a SQL Timestamp parameter value using a Calendar for timezone conversion.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Timestamp`) — the Timestamp value to set, or {@code null} to set SQL NULL
  - `cal` (`Calendar`) — the Calendar object to use for timezone conversion
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTimestamp(final int parameterIndex, final LocalDateTime x) throws SQLException`
- **Summary:** Sets a LocalDateTime parameter value as a SQL Timestamp.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`LocalDateTime`) — the LocalDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTimestamp(final int parameterIndex, final ZonedDateTime x) throws SQLException`
- **Summary:** Sets a ZonedDateTime parameter value as a SQL Timestamp.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`ZonedDateTime`) — the ZonedDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTimestamp(final int parameterIndex, final OffsetDateTime x) throws SQLException`
- **Summary:** Sets an OffsetDateTime parameter value as a SQL Timestamp.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`OffsetDateTime`) — the OffsetDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setTimestamp(final int parameterIndex, final Instant x) throws SQLException`
- **Summary:** Sets an Instant parameter value as a SQL Timestamp.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Instant`) — the Instant value to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBytes(...) -> This
- **Signature:** `public This setBytes(final int parameterIndex, final byte[] x) throws SQLException`
- **Summary:** Sets a byte array parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`byte[]`) — the byte array to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setAsciiStream(...) -> This
- **Signature:** `public This setAsciiStream(final int parameterIndex, final InputStream inputStream) throws SQLException`
- **Summary:** Sets an ASCII stream parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing ASCII data, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setAsciiStream(final int parameterIndex, final InputStream inputStream, final int length) throws SQLException`
- **Summary:** Sets an ASCII stream parameter value with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing ASCII data
  - `length` (`int`) — the number of bytes in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setAsciiStream(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException`
- **Summary:** Sets an ASCII stream parameter value with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing ASCII data
  - `length` (`long`) — the number of bytes in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBinaryStream(...) -> This
- **Signature:** `public This setBinaryStream(final int parameterIndex, final InputStream inputStream) throws SQLException`
- **Summary:** Sets a binary stream parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing binary data, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setBinaryStream(final int parameterIndex, final InputStream inputStream, final int length) throws SQLException`
- **Summary:** Sets a binary stream parameter value with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing binary data
  - `length` (`int`) — the number of bytes in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setBinaryStream(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException`
- **Summary:** Sets a binary stream parameter value with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing binary data
  - `length` (`long`) — the number of bytes in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setCharacterStream(...) -> This
- **Signature:** `public This setCharacterStream(final int parameterIndex, final Reader reader) throws SQLException`
- **Summary:** Sets a character stream parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing character data, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setCharacterStream(final int parameterIndex, final Reader reader, final int length) throws SQLException`
- **Summary:** Sets a character stream parameter value with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing character data
  - `length` (`int`) — the number of characters in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setCharacterStream(final int parameterIndex, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets a character stream parameter value with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing character data
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setNCharacterStream(...) -> This
- **Signature:** `public This setNCharacterStream(final int parameterIndex, final Reader reader) throws SQLException`
- **Summary:** Sets a national character stream parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing national character data
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setNCharacterStream(final int parameterIndex, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets a national character stream parameter value with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing national character data
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBlob(...) -> This
- **Signature:** `public This setBlob(final int parameterIndex, final java.sql.Blob x) throws SQLException`
- **Summary:** Sets a Blob parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Blob`) — the Blob object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setBlob(final int parameterIndex, final InputStream inputStream) throws SQLException`
- **Summary:** Sets a Blob parameter value from an InputStream.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing the data for the Blob
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setBlob(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException`
- **Summary:** Sets a Blob parameter value from an InputStream with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `inputStream` (`InputStream`) — the input stream containing the data for the Blob
  - `length` (`long`) — the number of bytes in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setClob(...) -> This
- **Signature:** `public This setClob(final int parameterIndex, final java.sql.Clob x) throws SQLException`
- **Summary:** Sets a Clob parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Clob`) — the Clob object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setClob(final int parameterIndex, final Reader reader) throws SQLException`
- **Summary:** Sets a Clob parameter value from a Reader.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing the data for the Clob
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setClob(final int parameterIndex, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets a Clob parameter value from a Reader with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing the data for the Clob
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setNClob(...) -> This
- **Signature:** `public This setNClob(final int parameterIndex, final java.sql.NClob x) throws SQLException`
- **Summary:** Sets an NClob parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.NClob`) — the NClob object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setNClob(final int parameterIndex, final Reader reader) throws SQLException`
- **Summary:** Sets an NClob parameter value from a Reader.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing the national character data
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setNClob(final int parameterIndex, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets an NClob parameter value from a Reader with a specified length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `reader` (`Reader`) — the reader containing the national character data
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setURL(...) -> This
- **Signature:** `public This setURL(final int parameterIndex, final URL x) throws SQLException`
- **Summary:** Sets a URL parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`URL`) — the URL object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setArray(...) -> This
- **Signature:** `public This setArray(final int parameterIndex, final java.sql.Array x) throws SQLException`
- **Summary:** Sets an Array parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Array`) — the Array object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setSQLXML(...) -> This
- **Signature:** `public This setSQLXML(final int parameterIndex, final java.sql.SQLXML x) throws SQLException`
- **Summary:** Sets a SQLXML parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.SQLXML`) — the SQLXML object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setRef(...) -> This
- **Signature:** `public This setRef(final int parameterIndex, final java.sql.Ref x) throws SQLException`
- **Summary:** Sets a Ref parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.Ref`) — the Ref object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setRowId(...) -> This
- **Signature:** `public This setRowId(final int parameterIndex, final java.sql.RowId x) throws SQLException`
- **Summary:** Sets a RowId parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`java.sql.RowId`) — the RowId object, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setObject(...) -> This
- **Signature:** `public This setObject(final int parameterIndex, final Object x) throws SQLException`
- **Summary:** Sets an Object parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Object`) — the object to set, or {@code null} to set SQL NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setObject(final int parameterIndex, final Object x, final int sqlType) throws SQLException`
- **Summary:** Sets an Object parameter value with a specified SQL type.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Object`) — the object to set
  - `sqlType` (`int`) — the SQL type to use (from {@link java.sql.Types} )
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
- **Signature:** `public This setObject(final int parameterIndex, final Object x, final int sqlType, final int scaleOrLength) throws SQLException`
- **Summary:** Sets an Object parameter value with a specified SQL type and scale or length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Object`) — the object to set
  - `sqlType` (`int`) — the SQL type to use (from {@link java.sql.Types} )
  - `scaleOrLength` (`int`) — For numeric types, the number of decimal places; for strings, the length
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
- **Signature:** `public This setObject(final int parameterIndex, final Object x, final SQLType sqlType) throws SQLException`
- **Summary:** Sets an Object parameter value with a specified SQL type.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Object`) — the object to set
  - `sqlType` (`SQLType`) — the SQL type to use
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setObject(final int parameterIndex, final Object x, final SQLType sqlType, final int scaleOrLength) throws SQLException`
- **Summary:** Sets an Object parameter value with a specified SQL type and scale or length.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`Object`) — the object to set
  - `sqlType` (`SQLType`) — the SQL type to use
  - `scaleOrLength` (`int`) — For numeric types, the number of decimal places; for strings, the length
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> This setObject(final int parameterIndex, final T x, final Type<T> type) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Object parameter value using a custom Type handler.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter to set, starting from 1
  - `x` (`T`) — the object to set
  - `type` (`Type<T>`) — the Type handler for custom serialization
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if type is invalid
  - `java.sql.SQLException` — if a database access error occurs
##### setParameters(...) -> This
- **Signature:** `public This setParameters(final String param1, final String param2) throws SQLException`
- **Summary:** Sets two String parameters starting from index 1.
- **Parameters:**
  - `param1` (`String`) — the first String parameter
  - `param2` (`String`) — the second String parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final String param1, final String param2, final String param3) throws SQLException`
- **Summary:** Sets three String parameters starting from index 1.
- **Parameters:**
  - `param1` (`String`) — the first String parameter
  - `param2` (`String`) — the second String parameter
  - `param3` (`String`) — the third String parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final String param1, final String param2, final String param3, final String param4) throws SQLException`
- **Summary:** Sets four String parameters starting from index 1.
- **Parameters:**
  - `param1` (`String`) — the first String parameter
  - `param2` (`String`) — the second String parameter
  - `param3` (`String`) — the third String parameter
  - `param4` (`String`) — the fourth String parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final String param1, final String param2, final String param3, final String param4, final String param5) throws SQLException`
- **Summary:** Sets five String parameters starting from index 1.
- **Parameters:**
  - `param1` (`String`) — the first String parameter
  - `param2` (`String`) — the second String parameter
  - `param3` (`String`) — the third String parameter
  - `param4` (`String`) — the fourth String parameter
  - `param5` (`String`) — the fifth String parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final String param1, final String param2, final String param3, final String param4, final String param5, final String param6) throws SQLException`
- **Summary:** Sets six String parameters starting from index 1.
- **Parameters:**
  - `param1` (`String`) — the first String parameter
  - `param2` (`String`) — the second String parameter
  - `param3` (`String`) — the third String parameter
  - `param4` (`String`) — the fourth String parameter
  - `param5` (`String`) — the fifth String parameter
  - `param6` (`String`) — the sixth String parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final String param1, final String param2, final String param3, final String param4, final String param5, final String param6, final String param7) throws SQLException`
- **Summary:** Sets seven String parameters starting from index 1.
- **Parameters:**
  - `param1` (`String`) — the first String parameter
  - `param2` (`String`) — the second String parameter
  - `param3` (`String`) — the third String parameter
  - `param4` (`String`) — the fourth String parameter
  - `param5` (`String`) — the fifth String parameter
  - `param6` (`String`) — the sixth String parameter
  - `param7` (`String`) — the seventh String parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Object param1, final Object param2, final Object param3) throws SQLException`
- **Summary:** Sets three Object parameters starting from index 1.
- **Parameters:**
  - `param1` (`Object`) — the first parameter
  - `param2` (`Object`) — the second parameter
  - `param3` (`Object`) — the third parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4) throws SQLException`
- **Summary:** Sets four Object parameters starting from index 1.
- **Parameters:**
  - `param1` (`Object`) — the first parameter
  - `param2` (`Object`) — the second parameter
  - `param3` (`Object`) — the third parameter
  - `param4` (`Object`) — the fourth parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5) throws SQLException`
- **Summary:** Sets five Object parameters starting from index 1.
- **Parameters:**
  - `param1` (`Object`) — the first parameter
  - `param2` (`Object`) — the second parameter
  - `param3` (`Object`) — the third parameter
  - `param4` (`Object`) — the fourth parameter
  - `param5` (`Object`) — the fifth parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6) throws SQLException`
- **Summary:** Sets six Object parameters starting from index 1.
- **Parameters:**
  - `param1` (`Object`) — the first parameter
  - `param2` (`Object`) — the second parameter
  - `param3` (`Object`) — the third parameter
  - `param4` (`Object`) — the fourth parameter
  - `param5` (`Object`) — the fifth parameter
  - `param6` (`Object`) — the sixth parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6, final Object param7) throws SQLException`
- **Summary:** Sets seven Object parameters starting from index 1.
- **Parameters:**
  - `param1` (`Object`) — the first parameter
  - `param2` (`Object`) — the second parameter
  - `param3` (`Object`) — the third parameter
  - `param4` (`Object`) — the fourth parameter
  - `param5` (`Object`) — the fifth parameter
  - `param6` (`Object`) — the sixth parameter
  - `param7` (`Object`) — the seventh parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6, final Object param7, final Object param8) throws SQLException`
- **Summary:** Sets eight Object parameters starting from index 1.
- **Parameters:**
  - `param1` (`Object`) — the first parameter
  - `param2` (`Object`) — the second parameter
  - `param3` (`Object`) — the third parameter
  - `param4` (`Object`) — the fourth parameter
  - `param5` (`Object`) — the fifth parameter
  - `param6` (`Object`) — the sixth parameter
  - `param7` (`Object`) — the seventh parameter
  - `param8` (`Object`) — the eighth parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6, final Object param7, final Object param8, final Object param9) throws IllegalArgumentException, SQLException`
- **Summary:** Sets nine Object parameters starting from index 1.
- **Parameters:**
  - `param1` (`Object`) — the first parameter
  - `param2` (`Object`) — the second parameter
  - `param3` (`Object`) — the third parameter
  - `param4` (`Object`) — the fourth parameter
  - `param5` (`Object`) — the fifth parameter
  - `param6` (`Object`) — the sixth parameter
  - `param7` (`Object`) — the seventh parameter
  - `param8` (`Object`) — the eighth parameter
  - `param9` (`Object`) — the ninth parameter
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any parameter is invalid
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final int[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple int parameters starting from index 1.
- **Parameters:**
  - `parameters` (`int[]`) — the array of int values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final long[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple long parameters starting from index 1.
- **Parameters:**
  - `parameters` (`long[]`) — the array of long values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final String[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple String parameters starting from index 1.
- **Parameters:**
  - `parameters` (`String[]`) — the array of String values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> This setParameters(final T[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters of the same type starting from index 1.
- **Parameters:**
  - `parameters` (`T[]`) — the array of values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Collection<?> parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters from a Collection starting from index 1.
- **Parameters:**
  - `parameters` (`Collection<?>`) — the collection of values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> This setParameters(final Collection<? extends T> parameters, final Class<T> type) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters from a typed Collection starting from index 1.
- **Contract:**
  - This method ensures type safety when setting parameters.
- **Parameters:**
  - `parameters` (`Collection<? extends T>`) — the collection of values to set
  - `type` (`Class<T>`) — the class type of the parameters
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters or type is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParameters(final Jdbc.ParametersSetter<? super Stmt> parametersSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Sets parameters using a custom ParametersSetter.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.setParameters(stmt -> { stmt.setString(1, user.getName()); stmt.setInt(2, user.getAge()); if (user.getEmail() != null) { stmt.setString(3, user.getEmail()); } else { stmt.setNull(3, Types.VARCHAR); } }).list(); } </pre>
- **Parameters:**
  - `parametersSetter` (`Jdbc.ParametersSetter<? super Stmt>`) — the function to set parameters on the PreparedStatement
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parametersSetter is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> This setParameters(final T parameters, final Jdbc.BiParametersSetter<? super Stmt, ? super T> parametersSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Sets parameters using a BiParametersSetter with additional context.
- **Parameters:**
  - `parameters` (`T`) — the additional data to use when setting parameters
  - `parametersSetter` (`Jdbc.BiParametersSetter<? super Stmt, ? super T>`) — the function to set parameters on the PreparedStatement
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parametersSetter is null
  - `java.sql.SQLException` — if a database access error occurs
##### setParametersFrom(...) -> This
- **Signature:** `public This setParametersFrom(int startParameterIndex, final int[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple int parameters starting from the specified index.
- **Parameters:**
  - `startParameterIndex` (`int`) — the starting parameter index (1-based)
  - `parameters` (`int[]`) — the array of int values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParametersFrom(int startParameterIndex, final long[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple long parameters starting from the specified index.
- **Parameters:**
  - `startParameterIndex` (`int`) — the starting parameter index (1-based)
  - `parameters` (`long[]`) — the array of long values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParametersFrom(int startParameterIndex, final String[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple String parameters starting from the specified index.
- **Parameters:**
  - `startParameterIndex` (`int`) — the starting parameter index (1-based)
  - `parameters` (`String[]`) — the array of String values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> This setParametersFrom(int startParameterIndex, final T[] parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters of the same type starting from the specified index.
- **Parameters:**
  - `startParameterIndex` (`int`) — the starting parameter index (1-based)
  - `parameters` (`T[]`) — the array of values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public This setParametersFrom(int startParameterIndex, final Collection<?> parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters from a Collection starting from the specified index.
- **Parameters:**
  - `startParameterIndex` (`int`) — the starting parameter index (1-based)
  - `parameters` (`Collection<?>`) — the collection of values to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> This setParametersFrom(int startParameterIndex, final Collection<? extends T> parameters, final Class<T> type) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters from a typed Collection starting from the specified index.
- **Contract:**
  - This method ensures type safety when setting parameters.
- **Parameters:**
  - `startParameterIndex` (`int`) — the starting parameter index (1-based)
  - `parameters` (`Collection<? extends T>`) — the collection of values to set
  - `type` (`Class<T>`) — the class type of the parameters
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters or type is null
  - `java.sql.SQLException` — if a database access error occurs
##### settParameters(...) -> This
- **Signature:** `@Beta public This settParameters(final Jdbc.ParametersSetter<? super This> parametersSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Sets parameters using a custom ParametersSetter that operates on this query instance.
- **Parameters:**
  - `parametersSetter` (`Jdbc.ParametersSetter<? super This>`) — the function to set parameters on this query
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parametersSetter is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public <T> This settParameters(final T parameters, final Jdbc.BiParametersSetter<? super This, ? super T> parametersSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Sets parameters using a BiParametersSetter that operates on this query instance with additional context.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code UserFilter filter = getUserFilter(); query.settParameters(filter, (q, f) -> { q.setString(1, f.getName()); if (f.getMinAge() != null) { q.setInt(2, f.getMinAge()); } else { q.setNull(2, Types.INTEGER); } }).list(); } </pre>
- **Parameters:**
  - `parameters` (`T`) — the additional data to use when setting parameters
  - `parametersSetter` (`Jdbc.BiParametersSetter<? super This, ? super T>`) — the function to set parameters on this query
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parametersSetter is null
  - `java.sql.SQLException` — if a database access error occurs
##### setNullForIndices(...) -> This
- **Signature:** `@Beta public This setNullForIndices(final int sqlType, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same SQL NULL value to multiple parameter positions.
- **Contract:**
  - Useful when multiple parameters should be NULL with the same SQL type.
- **Parameters:**
  - `sqlType` (`int`) — the SQL type to set, as defined in {@link java.sql.Types}
  - `parameterIndices` (`int[]`) — the parameter positions to set to NULL
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
##### setBooleanForIndices(...) -> This
- **Signature:** `@Beta public This setBooleanForIndices(final Boolean parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Boolean value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`Boolean`) — the Boolean value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setIntForIndices(...) -> This
- **Signature:** `@Beta public This setIntForIndices(final Integer parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Integer value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`Integer`) — the Integer value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setLongForIndices(...) -> This
- **Signature:** `@Beta public This setLongForIndices(final Long parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Long value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`Long`) — the Long value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setDoubleForIndices(...) -> This
- **Signature:** `@Beta public This setDoubleForIndices(final Double parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Double value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`Double`) — the Double value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setStringForIndices(...) -> This
- **Signature:** `@Beta public This setStringForIndices(final String parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same String value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`String`) — the String value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setDateForIndices(...) -> This
- **Signature:** `@Beta public This setDateForIndices(final java.sql.Date parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Date value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`java.sql.Date`) — the Date value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public This setDateForIndices(final java.util.Date parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same java.util.Date value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`java.util.Date`) — the Date value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setTimeForIndices(...) -> This
- **Signature:** `@Beta public This setTimeForIndices(final java.sql.Time parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Time value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`java.sql.Time`) — the Time value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public This setTimeForIndices(final java.util.Date parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same java.util.Date value as Time to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`java.util.Date`) — the Date value to set as Time
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setTimestampForIndices(...) -> This
- **Signature:** `@Beta public This setTimestampForIndices(final java.sql.Timestamp parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Timestamp value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`java.sql.Timestamp`) — the Timestamp value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public This setTimestampForIndices(final java.util.Date parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same java.util.Date value as Timestamp to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`java.util.Date`) — the Date value to set as Timestamp
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setObjectForIndices(...) -> This
- **Signature:** `@Beta public This setObjectForIndices(final Object parameterValue, final int... parameterIndices) throws SQLException`
- **Summary:** Sets the same Object value to multiple parameter positions.
- **Parameters:**
  - `parameterValue` (`Object`) — the Object value to set
  - `parameterIndices` (`int[]`) — the parameter positions to set
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### addBatchParameters(...) -> This
- **Signature:** `@Beta public This addBatchParameters(final Collection<?> batchParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Adds multiple sets of parameters for batch execution.
- **Parameters:**
  - `batchParameters` (`Collection<?>`) — Collection where each element is a collection of parameters for one batch
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if batchParameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public <T> This addBatchParameters(final Collection<? extends T> batchParameters, final Class<T> type) throws IllegalArgumentException, SQLException`
- **Summary:** Adds multiple sets of typed parameters for batch execution.
- **Parameters:**
  - `batchParameters` (`Collection<? extends T>`) — Collection of parameters
  - `type` (`Class<T>`) — the class type of the parameters
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — If batchParameters or type is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @SuppressWarnings("rawtypes") public This addBatchParameters(final Iterator<?> batchParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Adds multiple sets of parameters for batch execution using an iterator.
- **Parameters:**
  - `batchParameters` (`Iterator<?>`) — Iterator over parameter sets
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if batchParameters is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public <T> This addBatchParameters(final Iterator<? extends T> batchParameters, final Class<T> type) throws IllegalArgumentException, SQLException`
- **Summary:** Adds multiple sets of typed parameters for batch execution using an iterator.
- **Parameters:**
  - `batchParameters` (`Iterator<? extends T>`) — Iterator over parameters
  - `type` (`Class<T>`) — the class type of the parameters
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — If batchParameters or type is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public <T> This addBatchParameters(final Collection<? extends T> batchParameters, final Jdbc.BiParametersSetter<? super This, ? super T> parametersSetter) throws SQLException`
- **Summary:** Adds multiple sets of parameters for batch execution using a custom parameter setter.
- **Parameters:**
  - `batchParameters` (`Collection<? extends T>`) — Collection of parameter objects
  - `parametersSetter` (`Jdbc.BiParametersSetter<? super This, ? super T>`) — Function to set parameters for each object
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public <T> This addBatchParameters(final Iterator<? extends T> batchParameters, final Jdbc.BiParametersSetter<? super This, ? super T> parametersSetter) throws SQLException`
- **Summary:** Adds multiple sets of parameters for batch execution using a custom parameter setter and iterator.
- **Parameters:**
  - `batchParameters` (`Iterator<? extends T>`) — Iterator over parameter objects
  - `parametersSetter` (`Jdbc.BiParametersSetter<? super This, ? super T>`) — Function to set parameters for each object
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public <T> This addBatchParameters(final Collection<? extends T> batchParameters, final Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException> parametersSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Adds multiple sets of parameters for batch execution using a TriConsumer parameter setter.
- **Parameters:**
  - `batchParameters` (`Collection<? extends T>`) — Collection of parameter objects
  - `parametersSetter` (`Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException>`) — Function to set parameters with access to query and statement
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — If batchParameters or parametersSetter is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public <T> This addBatchParameters(final Iterator<? extends T> batchParameters, final Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException> parametersSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Adds multiple sets of parameters for batch execution using a TriConsumer parameter setter and iterator.
- **Parameters:**
  - `batchParameters` (`Iterator<? extends T>`) — Iterator over parameter objects
  - `parametersSetter` (`Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException>`) — Function to set parameters with access to query and statement
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — If batchParameters or parametersSetter is null
  - `java.sql.SQLException` — if a database access error occurs
##### addBatch(...) -> This
- **Signature:** `public This addBatch() throws SQLException`
- **Summary:** Adds the current set of parameters to this statement's batch of commands.
- **Parameters:**
  - (none)
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed statement
- **See also:** java.sql.PreparedStatement#addBatch()
##### setFetchDirection(...) -> This
- **Signature:** `public This setFetchDirection(final FetchDirection direction) throws SQLException`
- **Summary:** Sets the direction for fetching rows from database tables.
- **Parameters:**
  - `direction` (`FetchDirection`) — One of {@code ResultSet.FETCH_FORWARD} , {@code ResultSet.FETCH_REVERSE} , or {@code ResultSet.FETCH_UNKNOWN}
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Statement#setFetchDirection(int)
##### setFetchDirectionToForward(...) -> This
- **Signature:** `public This setFetchDirectionToForward() throws SQLException`
- **Summary:** Sets the fetch direction to FORWARD.
- **Parameters:**
  - (none)
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setFetchDirection(FetchDirection)
##### setFetchSize(...) -> This
- **Signature:** `public This setFetchSize(final int fetchSize) throws SQLException`
- **Summary:** Sets the number of rows that should be fetched from the database when more rows are needed.
- **Contract:**
  - Sets the number of rows that should be fetched from the database when more rows are needed.
- **Parameters:**
  - `fetchSize` (`int`) — the number of rows to fetch. Use 0 to let the JDBC driver choose.
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Statement#setFetchSize(int)
##### setMaxFieldSize(...) -> This
- **Signature:** `public This setMaxFieldSize(final int max) throws SQLException`
- **Summary:** Sets the maximum number of bytes that can be returned for character and binary column values.
- **Parameters:**
  - `max` (`int`) — the new column size limit in bytes; zero means there is no limit
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Statement#setMaxFieldSize(int)
##### setMaxRows(...) -> This
- **Signature:** `public This setMaxRows(final int max) throws SQLException`
- **Summary:** Sets the maximum number of rows that this query can return.
- **Contract:**
  - If the limit is exceeded, the excess rows are silently dropped.
- **Parameters:**
  - `max` (`int`) — the new max rows limit; zero means there is no limit
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Statement#setMaxRows(int)
##### setLargeMaxRows(...) -> This
- **Signature:** `public This setLargeMaxRows(final long max) throws SQLException`
- **Summary:** Sets the maximum number of rows that this query can return (for large row counts).
- **Contract:**
  - If the limit is exceeded, the excess rows are silently dropped.
- **Parameters:**
  - `max` (`long`) — the new max rows limit; zero means there is no limit
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Statement#setLargeMaxRows(long)
##### setQueryTimeout(...) -> This
- **Signature:** `public This setQueryTimeout(final int seconds) throws SQLException`
- **Summary:** Sets the number of seconds the driver will wait for a Statement to execute.
- **Contract:**
  - If the limit is exceeded, a SQLException is thrown.
- **Parameters:**
  - `seconds` (`int`) — the new query timeout limit in seconds; zero means there is no limit
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Statement#setQueryTimeout(int)
##### configStmt(...) -> This
- **Signature:** `@Beta public This configStmt(final Throwables.Consumer<? super Stmt, ? extends SQLException> stmtSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Configures this statement using a custom configuration function.
- **Parameters:**
  - `stmtSetter` (`Throwables.Consumer<? super Stmt, ? extends SQLException>`) — the function to configure the statement
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — If stmtSetter is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta public This configStmt(final Throwables.BiConsumer<? super This, ? super Stmt, ? extends SQLException> stmtSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Configures this statement using a BiConsumer that has access to both the query and statement.
- **Parameters:**
  - `stmtSetter` (`Throwables.BiConsumer<? super This, ? super Stmt, ? extends SQLException>`) — the function to configure the statement
- **Returns:** this AbstractQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — If stmtSetter is null
  - `java.sql.SQLException` — if a database access error occurs
##### queryForBoolean(...) -> OptionalBoolean
- **Signature:** `public OptionalBoolean queryForBoolean() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a boolean value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalBoolean} is returned.
- **Parameters:**
  - (none)
- **Returns:** an {@code OptionalBoolean} containing the boolean value if at least one row is returned; otherwise {@code OptionalBoolean.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query has been closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForChar(...) -> OptionalChar
- **Signature:** `public OptionalChar queryForChar() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a char value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalChar} is returned.
- **Parameters:**
  - (none)
- **Returns:** An {@code OptionalChar} containing the char value if at least one row is returned; otherwise {@code OptionalChar.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForByte(...) -> OptionalByte
- **Signature:** `public OptionalByte queryForByte() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a byte value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalByte} is returned.
- **Parameters:**
  - (none)
- **Returns:** An {@code OptionalByte} containing the byte value if at least one row is returned; otherwise {@code OptionalByte.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForShort(...) -> OptionalShort
- **Signature:** `public OptionalShort queryForShort() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a short value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalShort} is returned.
- **Parameters:**
  - (none)
- **Returns:** An {@code OptionalShort} containing the short value if at least one row is returned; otherwise {@code OptionalShort.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForInt(...) -> OptionalInt
- **Signature:** `public OptionalInt queryForInt() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as an int value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalInt} is returned.
- **Parameters:**
  - (none)
- **Returns:** An {@code OptionalInt} containing the int value if at least one row is returned; otherwise {@code OptionalInt.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForLong(...) -> OptionalLong
- **Signature:** `public OptionalLong queryForLong() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a long value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalLong} is returned.
- **Parameters:**
  - (none)
- **Returns:** An {@code OptionalLong} containing the long value if at least one row is returned; otherwise {@code OptionalLong.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForFloat(...) -> OptionalFloat
- **Signature:** `public OptionalFloat queryForFloat() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a float value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalFloat} is returned.
- **Parameters:**
  - (none)
- **Returns:** An {@code OptionalFloat} containing the float value if at least one row is returned; otherwise {@code OptionalFloat.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForDouble(...) -> OptionalDouble
- **Signature:** `public OptionalDouble queryForDouble() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a double value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@code OptionalDouble} is returned.
- **Parameters:**
  - (none)
- **Returns:** An {@code OptionalDouble} containing the double value if at least one row is returned; otherwise {@code OptionalDouble.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForString(...) -> Nullable<String>
- **Signature:** `public Nullable<String> queryForString() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a string value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<String>} is returned.
- **Parameters:**
  - (none)
- **Returns:** A {@code Nullable<String>} containing the string value if at least one row is returned; otherwise {@code Nullable.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForBigInteger(...) -> Nullable<BigInteger>
- **Signature:** `@Beta public Nullable<BigInteger> queryForBigInteger() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a BigInteger value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<BigInteger>} is returned.
- **Parameters:**
  - (none)
- **Returns:** A {@code Nullable<BigInteger>} containing the BigInteger value if at least one row is returned; otherwise {@code Nullable.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForBigDecimal(...) -> Nullable<BigDecimal>
- **Signature:** `@Beta public Nullable<BigDecimal> queryForBigDecimal() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a BigDecimal value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<BigDecimal>} is returned.
- **Parameters:**
  - (none)
- **Returns:** A {@code Nullable<BigDecimal>} containing the BigDecimal value if at least one row is returned; otherwise {@code Nullable.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForDate(...) -> Nullable<java.sql.Date>
- **Signature:** `public Nullable<java.sql.Date> queryForDate() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a Date value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<java.sql.Date>} is returned.
- **Parameters:**
  - (none)
- **Returns:** A {@code Nullable<java.sql.Date>} containing the Date value if at least one row is returned; otherwise {@code Nullable.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForTime(...) -> Nullable<java.sql.Time>
- **Signature:** `public Nullable<java.sql.Time> queryForTime() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a Time value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<java.sql.Time>} is returned.
- **Parameters:**
  - (none)
- **Returns:** A {@code Nullable<java.sql.Time>} containing the Time value if at least one row is returned; otherwise {@code Nullable.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForTimestamp(...) -> Nullable<java.sql.Timestamp>
- **Signature:** `public Nullable<java.sql.Timestamp> queryForTimestamp() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a Timestamp value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<java.sql.Timestamp>} is returned.
- **Parameters:**
  - (none)
- **Returns:** A {@code Nullable<java.sql.Timestamp>} containing the Timestamp value if at least one row is returned; otherwise {@code Nullable.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForBytes(...) -> Nullable<byte\[\]>
- **Signature:** `public Nullable<byte[]> queryForBytes() throws IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as a byte\[\] value.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<byte\[\]>} is returned.
- **Parameters:**
  - (none)
- **Returns:** A {@code Nullable<byte\[\]>} containing the byte\[\] value if at least one row is returned; otherwise {@code Nullable.empty()}
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForSingleResult(...) -> Nullable<V>
- **Signature:** `public <V> Nullable<V> queryForSingleResult(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes this query and returns the first column of the first row as the specified type.
- **Contract:**
  - <p> If the query produces no rows, an empty {@link Nullable<V>} is returned.
- **Parameters:**
  - `targetValueType` (`Class<? extends V>`) — the class of the desired result type
- **Returns:** A {@code Nullable} containing the value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <V> Nullable<V> queryForSingleResult(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the query and returns the first value from the result set using a custom Type handler.
- **Parameters:**
  - `targetValueType` (`Type<? extends V>`) — the Type handler for converting the result
- **Returns:** A {@code Nullable} containing the value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryForSingleNonNull(...) -> Optional<V>
- **Signature:** `public <V> Optional<V> queryForSingleNonNull(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException, NullPointerException`
- **Summary:** Executes the query and returns the first non-null value from the result set as the specified type.
- **Contract:**
  - <br/> If the value encountered in the first row/column is null, a NullPointerException is thrown.
- **Parameters:**
  - `targetValueType` (`Class<? extends V>`) — the class of the desired result type
- **Returns:** An {@code Optional} containing the non-null value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.NullPointerException` — if a null value is encountered in the result set
- **Signature:** `public <V> Optional<V> queryForSingleNonNull(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException, NullPointerException`
- **Summary:** Executes the query and returns the first non-null value from the result set using a custom Type handler.
- **Contract:**
  - <br/> If the value encountered in the first row/column is null, a NullPointerException is thrown.
- **Parameters:**
  - `targetValueType` (`Type<? extends V>`) — the Type handler for converting the result
- **Returns:** An {@code Optional} containing the non-null value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.NullPointerException` — if a null value is encountered in the result set
##### queryForUniqueResult(...) -> Nullable<V>
- **Signature:** `public <V> Nullable<V> queryForUniqueResult(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException`
- **Summary:** Executes the query and returns the unique result value from the result set as the specified type.
- **Contract:**
  - Throws DuplicatedResultException if more than one row is found.
  - // Throws exception if multiple users have the same email } </pre>
- **Parameters:**
  - `targetValueType` (`Class<? extends V>`) — the class of the desired result type
- **Returns:** A {@code Nullable} containing the unique value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `com.landawn.abacus.exception.DuplicatedResultException` — If more than one row is found
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <V> Nullable<V> queryForUniqueResult(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException`
- **Summary:** Executes the query and returns the unique result value from the result set using a custom Type handler.
- **Contract:**
  - Throws DuplicatedResultException if more than one row is found.
- **Parameters:**
  - `targetValueType` (`Type<? extends V>`) — the Type handler for converting the result
- **Returns:** A {@code Nullable} containing the unique value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `com.landawn.abacus.exception.DuplicatedResultException` — If more than one row is found
  - `java.sql.SQLException` — if a database access error occurs
##### queryForUniqueNonNull(...) -> Optional<V>
- **Signature:** `public <V> Optional<V> queryForUniqueNonNull(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException, NullPointerException`
- **Summary:** Executes the query and returns the unique non-null result value as the specified type.
- **Contract:**
  - <br/> If more than one row is found, a DuplicatedResultException is thrown.
  - If the value encountered in the first row/column is null, a NullPointerException is thrown.
  - // Throws exception if multiple sessions exist for the token } </pre>
- **Parameters:**
  - `targetValueType` (`Class<? extends V>`) — the class of the desired result type
- **Returns:** An {@code Optional} containing the unique non-null value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `com.landawn.abacus.exception.DuplicatedResultException` — If more than one row is found
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.NullPointerException` — if a null value is encountered in the result set
- **Signature:** `public <V> Optional<V> queryForUniqueNonNull(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException, NullPointerException`
- **Summary:** Executes the query and returns the unique non-null result value using a custom Type handler.
- **Contract:**
  - <br/> If more than one row is found, a DuplicatedResultException is thrown.
  - If the value encountered in the first row/column is null, a NullPointerException is thrown.
- **Parameters:**
  - `targetValueType` (`Type<? extends V>`) — the Type handler for converting the result
- **Returns:** An {@code Optional} containing the unique non-null value if present, otherwise empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetValueType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `com.landawn.abacus.exception.DuplicatedResultException` — If more than one row is found
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.NullPointerException` — if a null value is encountered in the result set
##### query(...) -> Dataset
- **Signature:** `public Dataset query() throws SQLException`
- **Summary:** Retrieves the first {@code ResultSet} and converts it to a {@code Dataset} .
- **Parameters:**
  - (none)
- **Returns:** A {@code Dataset} containing all rows from the query result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Dataset
- **Signature:** `public Dataset query(final Class<?> entityClassForExtractor) throws SQLException`
- **Summary:** Retrieves the first {@code ResultSet} and maps it to a {@code Dataset} using the specified entity class.
- **Parameters:**
  - `entityClassForExtractor` (`Class<?>`) — the class used to provide metadata for mapping columns in the result set
- **Returns:** A {@code Dataset} containing the results with entity-aware column mapping
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.ResultExtractor#toDataset(Class)
- **Signature:** `public <R> R query(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the query and extracts the result using the provided {@code ResultExtractor} .
- **Parameters:**
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — the extractor used to process the {@code ResultSet} and produce the result. The ResultSet will be automatically closed after this call.
- **Returns:** The result extracted from the {@code ResultSet}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if resultExtractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <R> R query(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the query and extracts the result using the provided {@code BiResultExtractor} .
- **Parameters:**
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — the extractor that receives both ResultSet and column labels. The ResultSet will be automatically closed after this call.
- **Returns:** The result extracted from the {@code ResultSet}
- **Throws:**
  - `java.lang.IllegalArgumentException` — if resultExtractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### query2Resultsets(...) -> Tuple2<R1, R2>
- **Signature:** `@Beta public <R1, R2> Tuple2<R1, R2> query2Resultsets(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Retrieves at most two {@code ResultSets} from a stored procedure or multi-result query.
- **Parameters:**
  - `resultExtractor1` (`Jdbc.BiResultExtractor<? extends R1>`) — the extractor for the first {@code ResultSet} . ResultSet will be closed after extraction.
  - `resultExtractor2` (`Jdbc.BiResultExtractor<? extends R2>`) — the extractor for the second {@code ResultSet} . ResultSet will be closed after extraction.
- **Returns:** A {@code Tuple2} containing the results from both ResultSets (may contain {@code null} if ResultSet not available)
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any of the provided extractors is {@code null}
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### query3Resultsets(...) -> Tuple3<R1, R2, R3>
- **Signature:** `@Beta public <R1, R2, R3> Tuple3<R1, R2, R3> query3Resultsets(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2, final Jdbc.BiResultExtractor<? extends R3> resultExtractor3) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Retrieves at most three {@code ResultSets} from a stored procedure or multi-result query.
- **Parameters:**
  - `resultExtractor1` (`Jdbc.BiResultExtractor<? extends R1>`) — the extractor for the first {@code ResultSet} . ResultSet will be closed after extraction.
  - `resultExtractor2` (`Jdbc.BiResultExtractor<? extends R2>`) — the extractor for the second {@code ResultSet} . ResultSet will be closed after extraction.
  - `resultExtractor3` (`Jdbc.BiResultExtractor<? extends R3>`) — the extractor for the third {@code ResultSet} . ResultSet will be closed after extraction.
- **Returns:** A {@code Tuple3} containing the results from all three ResultSets (may contain {@code null} if ResultSet not available)
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any of the provided extractors is {@code null}
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### queryAllResultsets(...) -> List<Dataset>
- **Signature:** `public List<Dataset> queryAllResultsets() throws SQLException`
- **Summary:** Retrieves all {@code ResultSets} and converts them to a list of {@code Dataset} .
- **Parameters:**
  - (none)
- **Returns:** A list of {@code Dataset} objects, one for each ResultSet returned by the query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryAllResultsets(ResultExtractor), #streamAllResultsets()
- **Signature:** `public <R> List<R> queryAllResultsets(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Retrieves all {@code ResultSets} and processes them with the specified {@code ResultExtractor} .
- **Parameters:**
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — the extractor to process each {@code ResultSet} . Each ResultSet will be closed after extraction.
- **Returns:** A list containing the extracted results from all ResultSets
- **Throws:**
  - `java.lang.IllegalArgumentException` — if resultExtractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #streamAllResultsets(ResultExtractor)
- **Signature:** `public <R> List<R> queryAllResultsets(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Retrieves all {@code ResultSets} and processes them with the specified {@code BiResultExtractor} .
- **Parameters:**
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — the extractor that receives ResultSet and column labels. Each ResultSet will be closed after extraction.
- **Returns:** A list containing the extracted results from all ResultSets
- **Throws:**
  - `java.lang.IllegalArgumentException` — if resultExtractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #streamAllResultsets(BiResultExtractor)
##### queryThenApply(...) -> R
- **Signature:** `@Beta public <R, E extends Exception> R queryThenApply(final Throwables.Function<? super Dataset, ? extends R, E> func) throws SQLException, E`
- **Summary:** Executes a query and applies a function to the resulting {@code Dataset} .
- **Parameters:**
  - `func` (`Throwables.Function<? super Dataset, ? extends R, E>`) — the function to apply to the {@code Dataset} resulting from the query
- **Returns:** The result produced by applying the function to the {@code Dataset}
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the function throws an exception
- **Signature:** `@Beta public <R, E extends Exception> R queryThenApply(final Class<?> entityClassForExtractor, final Throwables.Function<? super Dataset, ? extends R, E> func) throws SQLException, E`
- **Summary:** Executes a query and applies a function to the resulting {@code Dataset} , using the specified entity class.
- **Parameters:**
  - `entityClassForExtractor` (`Class<?>`) — the class used to provide metadata for column mapping
  - `func` (`Throwables.Function<? super Dataset, ? extends R, E>`) — the function to apply to the {@code Dataset} resulting from the query
- **Returns:** The result produced by applying the function to the {@code Dataset}
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the function throws an exception
- **See also:** Jdbc.ResultExtractor#toDataset(Class)
##### queryThenAccept(...) -> void
- **Signature:** `@Beta public <E extends Exception> void queryThenAccept(final Throwables.Consumer<? super Dataset, E> action) throws SQLException, E`
- **Summary:** Executes a query and applies a consumer action to the resulting {@code Dataset} .
- **Contract:**
  - <p> This method is useful when you need to perform side effects with the query results without returning a value.
- **Parameters:**
  - `action` (`Throwables.Consumer<? super Dataset, E>`) — the consumer action to apply to the {@code Dataset} resulting from the query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the consumer action throws an exception
- **Signature:** `@Beta public <E extends Exception> void queryThenAccept(final Class<?> entityClassForExtractor, final Throwables.Consumer<? super Dataset, E> action) throws SQLException, E`
- **Summary:** Executes a query and applies a consumer action to the resulting {@code Dataset} , using the specified entity class.
- **Parameters:**
  - `entityClassForExtractor` (`Class<?>`) — the class used to provide metadata for column mapping
  - `action` (`Throwables.Consumer<? super Dataset, E>`) — the consumer action to apply to the {@code Dataset} resulting from the query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the consumer action throws an exception
- **See also:** Jdbc.ResultExtractor#toDataset(Class)
##### findOnlyOne(...) -> Optional<Map<String, Object>>
- **Signature:** `public Optional<Map<String, Object>> findOnlyOne() throws DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns an {@code Optional} containing a map of column names to values if exactly one record is found.
- **Contract:**
  - Executes a query and returns an {@code Optional} containing a map of column names to values if exactly one record is found.
  - If no rows or multiple rows are found, it throws an appropriate exception.
- **Parameters:**
  - (none)
- **Returns:** An {@code Optional} containing a map of column names to values if exactly one record is found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryForUniqueResult(Class), #queryForUniqueNonNull(Class)
- **Signature:** `public <T> Optional<T> findOnlyOne(final Class<? extends T> targetType) throws NullPointerException, DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns an {@code Optional} containing a single result of the specified type if exactly one record is found.
- **Contract:**
  - Executes a query and returns an {@code Optional} containing a single result of the specified type if exactly one record is found.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map the result row to
- **Returns:** An {@code Optional} containing the mapped object if exactly one record is found, otherwise empty
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryForUniqueResult(Class), #queryForUniqueNonNull(Class)
- **Signature:** `public <T> Optional<T> findOnlyOne(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code RowMapper} if exactly one record is found.
- **Contract:**
  - Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code RowMapper} if exactly one record is found.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} used to map the result set to the result object
- **Returns:** An {@code Optional} containing the mapped object if exactly one record is found, otherwise empty
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> Optional<T> findOnlyOne(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code BiRowMapper} if exactly one record is found.
- **Contract:**
  - Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code BiRowMapper} if exactly one record is found.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} used to map the result set to the result object
- **Returns:** An {@code Optional} containing the mapped object if exactly one record is found, otherwise empty
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
##### findOnlyOneOrNull(...) -> Map<String, Object>
- **Signature:** `public Map<String, Object> findOnlyOneOrNull() throws DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns a single result as a {@code Map<String, Object>} if exactly one record is found.
- **Contract:**
  - Executes a query and returns a single result as a {@code Map<String, Object>} if exactly one record is found.
  - <p> Similar to {@link #findOnlyOne()} , but returns {@code null} instead of an empty Optional when no record is found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Map<String, Object> user = preparedQuery .setLong(1, userId) .findOnlyOneOrNull(); if (user != null) { System.out.println("Found user: " + user.get("name")); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** A {@code Map<String, Object>} containing the result if exactly one record is found, otherwise {@code null}
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> T findOnlyOneOrNull(final Class<? extends T> targetType) throws NullPointerException, DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns a single result of the specified type if exactly one record is found.
- **Contract:**
  - Executes a query and returns a single result of the specified type if exactly one record is found.
  - <p> Similar to {@link #findOnlyOne(Class)} , but returns {@code null} instead of an empty Optional when no record is found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code User user = preparedQuery .setString(1, email) .findOnlyOneOrNull(User.class); if (user == null) { throw new NotFoundException("User not found"); } } </pre>
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map the result row to
- **Returns:** The mapped object if exactly one record is found, otherwise {@code null}
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> T findOnlyOneOrNull(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns a single result extracted by the specified {@code RowMapper} if exactly one record is found.
- **Contract:**
  - Executes a query and returns a single result extracted by the specified {@code RowMapper} if exactly one record is found.
  - <p> Similar to {@link #findOnlyOne(Jdbc.RowMapper)} , but returns {@code null} instead of an empty Optional when no record is found.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} used to map the result set to the result object
- **Returns:** The mapped object if exactly one record is found, otherwise {@code null}
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> T findOnlyOneOrNull(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException`
- **Summary:** Executes a query and returns a single result extracted by the specified {@code BiRowMapper} if exactly one record is found.
- **Contract:**
  - Executes a query and returns a single result extracted by the specified {@code BiRowMapper} if exactly one record is found.
  - <p> Similar to {@link #findOnlyOne(BiRowMapper)} , but returns {@code null} instead of an empty Optional when no record is found.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} used to map the result set to the result object
- **Returns:** The mapped object if exactly one record is found, otherwise {@code null}
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `com.landawn.abacus.exception.DuplicatedResultException` — If the query finds more than one record
  - `java.sql.SQLException` — if a database access error occurs
##### findFirst(...) -> Optional<Map<String, Object>>
- **Signature:** `public Optional<Map<String, Object>> findFirst() throws SQLException`
- **Summary:** Executes a query and returns the first result as an {@code Optional} containing a {@code Map<String, Object>} .
- **Contract:**
  - <p> Unlike {@link #findOnlyOne()} , this method doesn't throw an exception if multiple rows are found; it simply returns the first row.
- **Parameters:**
  - (none)
- **Returns:** An {@code Optional} containing the first result as a map, or empty if no result is found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryForUniqueResult(Class), #queryForUniqueNonNull(Class)
- **Signature:** `public <T> Optional<T> findFirst(final Class<? extends T> targetType) throws NullPointerException, SQLException`
- **Summary:** Executes a query and returns the first result as an {@code Optional} containing an object of the specified type.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map the result row to
- **Returns:** An {@code Optional} containing the first result, or empty if no result is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryForUniqueResult(Class), #queryForUniqueNonNull(Class)
- **Signature:** `public <T> Optional<T> findFirst(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query and returns the first result as an {@code Optional} containing an object extracted by the specified {@code RowMapper} .
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} used to map the result set to an object
- **Returns:** An {@code Optional} containing the first result, or empty if no result is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated public <T> Optional<T> findFirst(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query with the specified {@code RowFilter} and {@code RowMapper} , and returns the first matching result as an {@code Optional} .
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the {@code RowFilter} used to filter the rows in the result set
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} used to map the result set to an object
- **Returns:** An {@code Optional} containing the first matching result, or empty if no match is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the first matching row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> Optional<T> findFirst(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query and returns the first result as an {@code Optional} containing an object extracted by the specified {@code BiRowMapper} .
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} used to map the result set to an object
- **Returns:** An {@code Optional} containing the first result, or empty if no result is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated public <T> Optional<T> findFirst(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query with the specified {@code BiRowFilter} and {@code BiRowMapper} , and returns the first matching result as an {@code Optional} .
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the {@code BiRowFilter} used to filter the rows in the result set
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} used to map the result set to an object
- **Returns:** An {@code Optional} containing the first matching result, or empty if no match is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the first matching row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
##### findFirstOrNull(...) -> Map<String, Object>
- **Signature:** `public Map<String, Object> findFirstOrNull() throws SQLException`
- **Summary:** Executes a query and returns the first result as a {@code Map<String, Object>} .
- **Contract:**
  - <p> Similar to {@link #findFirst()} , but returns {@code null} instead of an empty Optional when no result is found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Map<String, Object> firstRow = preparedQuery.findFirstOrNull(); if (firstRow != null) { System.out.println("Found: " + firstRow); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** A {@code Map<String, Object>} containing the first result, or {@code null} if no result is found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> T findFirstOrNull(final Class<? extends T> targetType) throws NullPointerException, SQLException`
- **Summary:** Executes a query and returns the first result of the specified type.
- **Contract:**
  - <p> Similar to {@link #findFirst(Class)} , but returns {@code null} instead of an empty Optional when no result is found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code User firstUser = preparedQuery .setString(1, "active") .findFirstOrNull(User.class); if (firstUser != null) { processUser(firstUser); } } </pre>
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map the result row to
- **Returns:** The first result mapped to the specified type, or {@code null} if no result is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> T findFirstOrNull(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query and returns the first result extracted by the specified {@code RowMapper} .
- **Contract:**
  - <p> Similar to {@link #findFirst(RowMapper)} , but returns {@code null} instead of an empty Optional when no result is found.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} used to map the result set to an object
- **Returns:** The first result mapped by the rowMapper, or {@code null} if no result is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated public <T> T findFirstOrNull(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query with filtering and returns the first matching result extracted by the specified {@code RowMapper} .
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the {@code RowFilter} used to filter rows
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} used to map the result set to an object
- **Returns:** The first matching result, or {@code null} if no match is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the first matching row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> T findFirstOrNull(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query and returns the first result extracted by the specified {@code BiRowMapper} .
- **Contract:**
  - <p> Similar to {@link #findFirst(BiRowMapper)} , but returns {@code null} instead of an empty Optional when no result is found.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} used to map the result set to an object
- **Returns:** The first result mapped by the rowMapper, or {@code null} if no result is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the found row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated public <T> T findFirstOrNull(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException`
- **Summary:** Executes a query with filtering and returns the first matching result extracted by the specified {@code BiRowMapper} .
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the {@code BiRowFilter} used to filter rows
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} used to map the result set to an object
- **Returns:** The first matching result, or {@code null} if no match is found
- **Throws:**
  - `java.lang.NullPointerException` — if the mapped object for the first matching row is {@code null}
  - `java.sql.SQLException` — if a database access error occurs
##### list(...) -> List<Map<String, Object>>
- **Signature:** `public List<Map<String, Object>> list() throws SQLException`
- **Summary:** Lists all rows in the first {@code ResultSet} as maps of column names to values.
- **Parameters:**
  - (none)
- **Returns:** A list of maps, where each map represents a row with column names as keys
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> List<T> list(final Class<? extends T> targetType) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet and maps them to the specified target type.
- **Contract:**
  - <p> <b> Mapping Rules: </b> </p> <ul> <li> Column names are matched to field/property names (case-insensitive) </li> <li> Underscores in column names are converted to camelCase (e.g., user_name \\u2192 userName) </li> <li> The target class must have a no-argument constructor </li> <li> Fields can be set via public fields or setter methods </li> <li> Type conversion is automatic for common types </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Define a simple entity class public class User { private Long id; private String name; private int age; // getters and setters...
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class of the type to map the rows to. Must not be {@code null} .
- **Returns:** A list of objects of the specified type, where each object represents a row in the result set. Returns an empty list if no rows are found.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or mapping fails
- **See also:** #list(Jdbc.RowMapper), #stream(Class), Jdbc.BiRowMapper#to(Class)
- **Signature:** `@Deprecated public <T> List<T> list(final Class<? extends T> targetType, final int maxResult) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet and maps them to the specified target type with a maximum result limit.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class of the type to map the rows to
  - `maxResult` (`int`) — the maximum number of results to return
- **Returns:** A list of objects of the specified type, limited by maxResult
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") public <T> List<T> list(final Jdbc.RowMapper<? extends T> rowMapper) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet using the provided row mapper.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the row mapper to map each row of the ResultSet to an object. Must not be {@code null} .
- **Returns:** A list of objects of the specified type, where each object represents a row in the result set
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the row mapper throws an exception
- **See also:** Jdbc.RowMapper, #list(Jdbc.BiRowMapper)
- **Signature:** `@Deprecated public <T> List<T> list(final Jdbc.RowMapper<? extends T> rowMapper, final int maxResult) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet using the provided row mapper with a maximum result limit.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the row mapper to map each row to an object
  - `maxResult` (`int`) — the maximum number of results to return
- **Returns:** A list of mapped objects, limited by maxResult
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> List<T> list(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet that match the specified row filter and maps them using the provided row mapper.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to apply to each row of the ResultSet. Must not be {@code null} .
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the row mapper to map each row of the ResultSet to an object. Must not be {@code null} .
- **Returns:** A list of objects that passed the filter, mapped by the row mapper
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.RowFilter, Jdbc.RowMapper
- **Signature:** `public <T> List<T> list(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper, int maxResult) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Lists the rows in the first ResultSet that match the specified row filter and maps them using the provided row mapper, with a maximum result limit.
- **Contract:**
  - Processing stops when either the ResultSet is exhausted or maxResult mapped objects have been created.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to apply to each row. Must not be {@code null} .
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the row mapper to map filtered rows to objects. Must not be {@code null} .
  - `maxResult` (`int`) — the maximum number of results to return. Must be non-negative.
- **Returns:** A list of objects that passed the filter, limited by maxResult
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowMapper is {@code null} , or maxResult is negative
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") public <T> List<T> list(final Jdbc.BiRowMapper<? extends T> rowMapper) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet and maps them using the provided BiRowMapper.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Map with access to column labels List<Map<String, Object>> results = preparedQuery .list((rs, columnLabels) -> { Map<String, Object> row = new HashMap<>(); for (String label : columnLabels) { row.put(label.toLowerCase(), rs.getObject(label)); } return row; }); // Dynamic mapping based on available columns List<FlexibleDTO> dtos = query .list((rs, columnLabels) -> { FlexibleDTO dto = new FlexibleDTO(); if (columnLabels.contains("name")) { dto.setName(rs.getString("name")); } if (columnLabels.contains("description")) { dto.setDescription(rs.getString("description")); } return dto; }); } </pre>
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper to map each row. Receives ResultSet and column labels. Must not be {@code null} .
- **Returns:** A list of objects mapped by the BiRowMapper
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.BiRowMapper, #list(Jdbc.RowMapper)
- **Signature:** `@Deprecated public <T> List<T> list(final Jdbc.BiRowMapper<? extends T> rowMapper, final int maxResult) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet using a BiRowMapper with a maximum result limit.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper to map each row
  - `maxResult` (`int`) — the maximum number of results to return
- **Returns:** A list of mapped objects, limited by maxResult
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> List<T> list(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws SQLException`
- **Summary:** Lists the rows in the first ResultSet that match the specified BiRowFilter and maps them using the provided BiRowMapper.
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the BiRowFilter to test each row. Must not be {@code null} .
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper to map filtered rows. Must not be {@code null} .
- **Returns:** A list of objects that passed the filter
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.BiRowFilter, Jdbc.BiRowMapper
- **Signature:** `public <T> List<T> list(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper, int maxResult) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Lists the rows in the first ResultSet that match the specified BiRowFilter and maps them using the provided BiRowMapper, with a maximum result limit.
- **Contract:**
  - Processing stops when maxResult objects have been created.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Complex filtering and mapping with result limit List<OrderSummary> summaries = preparedQuery .list( (rs, labels) -> { // Only include orders with all required fields return labels.containsAll(Arrays.asList("id", "total", "status")) && "COMPLETED".equals(rs.getString("status")); }, (rs, labels) -> { OrderSummary summary = new OrderSummary(); summary.setId(rs.getLong("id")); summary.setTotal(rs.getBigDecimal("total")); // Include optional fields if present if (labels.contains("customer_name")) { summary.setCustomerName(rs.getString("customer_name")); } return summary; }, 100 // Limit to 100 results ); } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the BiRowFilter to test each row. Must not be {@code null} .
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper to map filtered rows. Must not be {@code null} .
  - `maxResult` (`int`) — the maximum number of results to return. Must be non-negative.
- **Returns:** A list of objects that passed the filter, limited by maxResult
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowMapper is {@code null} , or maxResult is negative
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### listAllResultsets(...) -> List<List<T>>
- **Signature:** `public <T> List<List<T>> listAllResultsets(final Class<? extends T> targetType) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Lists all the ResultSets returned by the query (typically from stored procedures).
- **Contract:**
  - <p> This method is primarily used when executing stored procedures that return multiple ResultSets.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map each row to. Must not be {@code null} .
- **Returns:** A list of lists, where each inner list represents one ResultSet
- **Throws:**
  - `java.lang.IllegalArgumentException` — If targetType is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #listAllResultsets(Jdbc.RowMapper)
- **Signature:** `public <T> List<List<T>> listAllResultsets(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Lists all the ResultSets using the provided row mapper.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the row mapper to apply to each row in all ResultSets. Must not be {@code null} .
- **Returns:** A list of lists, where each inner list represents one ResultSet
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.RowMapper
- **Signature:** `public <T> List<List<T>> listAllResultsets(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Lists all the ResultSets that match the specified row filter and maps them using the provided row mapper.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to apply to each row. Must not be {@code null} .
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the row mapper for filtered rows. Must not be {@code null} .
- **Returns:** A list of lists, where each inner list contains filtered and mapped rows from one ResultSet
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public <T> List<List<T>> listAllResultsets(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Lists all the ResultSets and maps them using the provided BiRowMapper.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper to apply to each row. Must not be {@code null} .
- **Returns:** A list of lists, where each inner list represents one ResultSet
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.BiRowMapper
- **Signature:** `public <T> List<List<T>> listAllResultsets(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Lists all the ResultSets that match the specified BiRowFilter and maps them using the provided BiRowMapper.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Process multiple result sets with column-aware filtering and mapping List<List<ProcessedRecord>> results = callableQuery .listAllResultsets( (rs, labels) -> labels.contains("process_flag") && rs.getBoolean("process_flag"), (rs, labels) -> { ProcessedRecord record = new ProcessedRecord(); record.setId(rs.getLong("id")); if (labels.contains("metadata")) { record.setMetadata(rs.getString("metadata")); } return record; } ); } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the BiRowFilter to test each row. Must not be {@code null} .
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper for filtered rows. Must not be {@code null} .
- **Returns:** A list of lists with filtered and mapped rows from each ResultSet
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### listThenApply(...) -> R
- **Signature:** `@Beta public <T, R, E extends Exception> R listThenApply(final Class<? extends T> targetType, final Throwables.Function<? super List<T>, ? extends R, E> func) throws SQLException, E`
- **Summary:** Retrieves query results as a list and applies the specified function to transform them.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map each row to. Must not be {@code null} .
  - `func` (`Throwables.Function<? super List<T>, ? extends R, E>`) — the function to apply to the list. Must not be {@code null} .
- **Returns:** The result of applying the function to the list
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the function throws an exception
- **See also:** #list(Class), #listThenAccept(Class, Throwables.Consumer)
- **Signature:** `@Beta public <T, R, E extends Exception> R listThenApply(final Jdbc.RowMapper<? extends T> rowMapper, final Throwables.Function<? super List<T>, ? extends R, E> func) throws SQLException, E`
- **Summary:** Retrieves query results using a row mapper and applies the specified function to transform them.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the row mapper to use. Must not be {@code null} .
  - `func` (`Throwables.Function<? super List<T>, ? extends R, E>`) — the function to apply to the list. Must not be {@code null} .
- **Returns:** The result of applying the function to the list
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the function throws an exception
- **Signature:** `@Beta public <T, R, E extends Exception> R listThenApply(final Jdbc.BiRowMapper<? extends T> rowMapper, final Throwables.Function<? super List<T>, ? extends R, E> func) throws SQLException, E`
- **Summary:** Retrieves query results using a BiRowMapper and applies the specified function to transform them.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper to use. Must not be {@code null} .
  - `func` (`Throwables.Function<? super List<T>, ? extends R, E>`) — the function to apply to the list. Must not be {@code null} .
- **Returns:** The result of applying the function to the list
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the function throws an exception
##### listThenAccept(...) -> void
- **Signature:** `@Beta public <T, E extends Exception> void listThenAccept(final Class<? extends T> targetType, final Throwables.Consumer<? super List<T>, E> consumer) throws SQLException, E`
- **Summary:** Retrieves query results as a list and processes them with the specified consumer.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map each row to. Must not be {@code null} .
  - `consumer` (`Throwables.Consumer<? super List<T>, E>`) — the consumer to process the list. Must not be {@code null} .
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the consumer throws an exception
- **See also:** #list(Class), #listThenApply(Class, Throwables.Function)
- **Signature:** `@Beta public <T, E extends Exception> void listThenAccept(final Jdbc.RowMapper<? extends T> rowMapper, final Throwables.Consumer<? super List<T>, E> consumer) throws SQLException, E`
- **Summary:** Retrieves query results using a RowMapper and processes them with the specified consumer.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the RowMapper to use. Must not be {@code null} .
  - `consumer` (`Throwables.Consumer<? super List<T>, E>`) — the consumer to process the list. Must not be {@code null} .
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the consumer throws an exception
- **Signature:** `@Beta public <T, E extends Exception> void listThenAccept(final Jdbc.BiRowMapper<? extends T> rowMapper, final Throwables.Consumer<? super List<T>, E> consumer) throws SQLException, E`
- **Summary:** Retrieves query results using a BiRowMapper and processes them with the specified consumer.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper to use. Must not be {@code null} .
  - `consumer` (`Throwables.Consumer<? super List<T>, E>`) — the consumer to process the list. Must not be {@code null} .
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — If the consumer throws an exception
##### stream(...) -> Stream<Map<String, Object>>
- **Signature:** `@LazyEvaluation public Stream<Map<String, Object>> stream()`
- **Summary:** Streams the rows in the first ResultSet as a lazy-evaluated stream of maps.
- **Parameters:**
  - (none)
- **Returns:** A lazy-evaluated Stream of {@code Map<String, Object>} representing the rows
- **See also:** #list(), #stream(Class), Stream
- **Signature:** `@LazyEvaluation public <T> Stream<T> stream(final Class<? extends T> targetType)`
- **Summary:** Streams the rows in the first ResultSet, mapping each row to the specified target type.
- **Contract:**
  - The query executes when a terminal operation is called on the stream.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map each row to. Must not be {@code null} .
- **Returns:** A lazy-evaluated Stream of the specified type
- **See also:** #stream(Jdbc.RowMapper), #list(Class)
- **Signature:** `@SuppressWarnings("resource") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Streams the rows in the first ResultSet using the provided RowMapper.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the RowMapper to transform each row. Must not be {@code null} .
- **Returns:** A lazy-evaluated Stream of mapped objects
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** Jdbc.RowMapper, #stream(Jdbc.BiRowMapper)
- **Signature:** `@SuppressWarnings("resource") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Streams the rows in the first ResultSet using the provided BiRowMapper.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Stream with column-aware mapping try (Stream<FlexibleRecord> stream = preparedQuery.stream((rs, labels) -> { FlexibleRecord record = new FlexibleRecord(); for (String label : labels) { if (!label.startsWith("internal_")) { // Skip internal columns record.addField(label, rs.getObject(label)); } } return record; })) { stream.forEach(record -> processRecord(record)); } } </pre>
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper receiving ResultSet and column labels. Must not be {@code null} .
- **Returns:** A lazy-evaluated Stream of mapped objects
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** Jdbc.BiRowMapper
- **Signature:** `@SuppressWarnings("resource") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Streams the rows in the first ResultSet, filtering with RowFilter and mapping with RowMapper.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to test each row. Must not be {@code null} .
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the mapper for rows that pass the filter. Must not be {@code null} .
- **Returns:** A lazy-evaluated Stream of filtered and mapped objects
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** Jdbc.RowFilter, Jdbc.RowMapper
- **Signature:** `@SuppressWarnings("resource") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Streams the rows in the first ResultSet, filtering with BiRowFilter and mapping with BiRowMapper.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Advanced streaming with column-aware filtering and mapping try (Stream<Report> stream = preparedQuery.stream( (rs, labels) -> labels.contains("published") && rs.getBoolean("published"), (rs, labels) -> { Report report = new Report(); report.setId(rs.getLong("id")); // Only set optional fields if they exist if (labels.contains("author")) { report.setAuthor(rs.getString("author")); } return report; } )) { stream.forEach(report -> publishReport(report)); } } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the BiRowFilter to test each row. Must not be {@code null} .
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the BiRowMapper for filtered rows. Must not be {@code null} .
- **Returns:** A lazy-evaluated Stream of filtered and mapped objects
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowMapper is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** Jdbc.BiRowFilter, Jdbc.BiRowMapper
##### streamAllResultsets(...) -> Stream<Dataset>
- **Signature:** `@Beta public Stream<Dataset> streamAllResultsets()`
- **Summary:** Streams all ResultSets as Datasets from a stored procedure or multi-result query.
- **Contract:**
  - <p> This method is typically used when executing stored procedures that return multiple result sets.
- **Parameters:**
  - (none)
- **Returns:** A stream of Dataset objects, one for each ResultSet returned by the query
- **See also:** #queryAllResultsets(), Dataset
- **Signature:** `@Beta @SuppressWarnings("resource") public <R> Stream<R> streamAllResultsets(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Streams all ResultSets using the specified ResultExtractor to process each ResultSet.
- **Contract:**
  - <p> This method is typically used when executing stored procedures that return multiple result sets.
  - </p> <p> <b> Important: </b> The ResultExtractor should not save or return the ResultSet reference, as it will be automatically closed after processing.
- **Parameters:**
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — the extractor used to process each ResultSet and produce a result. Must not be {@code null} . The ResultSet will be closed after extraction.
- **Returns:** A stream of R extracted from all ResultSets returned by the executed procedure
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided resultExtractor is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** #queryAllResultsets(ResultExtractor), ResultExtractor
- **Signature:** `@Beta @SuppressWarnings("resource") public <R> Stream<R> streamAllResultsets(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Streams all ResultSets using the specified BiResultExtractor to process each ResultSet.
- **Contract:**
  - <p> This method is typically used when executing stored procedures that return multiple result sets.
  - </p> <p> <b> Important: </b> The BiResultExtractor should not save or return the ResultSet reference, as it will be automatically closed after processing.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Extract data with column-aware processing Stream<Report> reports = callableQuery.streamAllResultsets( (rs, columnLabels) -> { List<Report> list = new ArrayList<>(); while (rs.next()) { Report report = new Report(); // Process based on available columns if (columnLabels.contains("status")) { report.setStatus(rs.getString("status")); } list.add(report); } return list; } ); } </pre>
- **Parameters:**
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — the extractor used to process each ResultSet with column labels. Must not be {@code null} . The ResultSet will be closed after extraction.
- **Returns:** A stream of R extracted from all ResultSets returned by the executed procedure
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided resultExtractor is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** #queryAllResultsets(BiResultExtractor), BiResultExtractor
##### exists(...) -> boolean
- **Signature:** `public boolean exists() throws IllegalStateException, SQLException`
- **Summary:** Checks if there is at least one record found by executing the query.
- **Contract:**
  - Checks if there is at least one record found by executing the query.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if user exists boolean userExists = JdbcUtil.prepareQuery(conn, "SELECT * FROM users WHERE email = ?") .setString(1, "john@example.com") .exists(); if (userExists) { // Process existing user } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if there is at least one record found, {@code false} otherwise
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #notExists(), #count()
##### notExists(...) -> boolean
- **Signature:** `@Beta public boolean notExists() throws SQLException`
- **Summary:** Checks if there are no records found by executing the query.
- **Contract:**
  - Checks if there are no records found by executing the query.
  - </b> While {@code !exists()} works, {@code notExists()} better expresses the intent when checking for absence of records, similar to SQL's {@code NOT EXISTS} clause.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if email is available for registration boolean emailAvailable = JdbcUtil.prepareQuery(conn, "SELECT * FROM users WHERE email = ?") .setString(1, "newuser@example.com") .notExists(); if (emailAvailable) { // Proceed with registration } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if there are no records found, {@code false} if at least one record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #exists()
##### ifExists(...) -> void
- **Signature:** `public void ifExists(final Jdbc.RowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the given RowConsumer if a record exists in the result set.
- **Contract:**
  - Executes the given RowConsumer if a record exists in the result set.
  - If at least one row is found, the consumer is called with the first row's ResultSet.
  - </p> <p> <b> Note: </b> Only the first row is processed even if multiple rows exist.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process user if found JdbcUtil.prepareQuery(conn, "SELECT * FROM users WHERE id = ?") .setLong(1, userId) .ifExists(rs -> { String name = rs.getString("name"); String email = rs.getString("email"); sendWelcomeEmail(name, email); }); } </pre>
- **Parameters:**
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to process the first row if it exists. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowConsumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #ifExistsOrElse(RowConsumer, Throwables.Runnable)
- **Signature:** `public void ifExists(final Jdbc.BiRowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the given BiRowConsumer if a record exists in the result set.
- **Contract:**
  - Executes the given BiRowConsumer if a record exists in the result set.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process user with dynamic column handling JdbcUtil.prepareQuery(conn, "SELECT * FROM users WHERE id = ?") .setLong(1, userId) .ifExists((rs, labels) -> { User user = new User(); user.setId(rs.getLong("id")); // Only process columns that exist if (labels.contains("middle_name")) { user.setMiddleName(rs.getString("middle_name")); } processUser(user); }); } </pre>
- **Parameters:**
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the consumer to process the first row with column labels if it exists. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowConsumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #ifExistsOrElse(BiRowConsumer, Throwables.Runnable)
##### ifExistsOrElse(...) -> void
- **Signature:** `public void ifExistsOrElse(final Jdbc.RowConsumer rowConsumer, final Throwables.Runnable<SQLException> orElseAction) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the given RowConsumer if a record exists, otherwise executes the orElseAction.
- **Contract:**
  - Executes the given RowConsumer if a record exists, otherwise executes the orElseAction.
  - <p> This method provides a complete conditional execution pattern: process the first row if it exists, or execute an alternative action if no rows are found.
- **Parameters:**
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to process the first row if it exists. Must not be {@code null} .
  - `orElseAction` (`Throwables.Runnable<SQLException>`) — the action to execute if no record exists. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowConsumer or orElseAction is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public void ifExistsOrElse(final Jdbc.BiRowConsumer rowConsumer, final Throwables.Runnable<SQLException> orElseAction) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the given BiRowConsumer if a record exists, otherwise executes the orElseAction.
- **Contract:**
  - Executes the given BiRowConsumer if a record exists, otherwise executes the orElseAction.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Load configuration or use defaults JdbcUtil.prepareQuery(conn, "SELECT * FROM config WHERE app_id = ?") .setString(1, appId) .ifExistsOrElse( (rs, labels) -> { // Load existing configuration config = new Config(); config.setAppId(rs.getString("app_id")); // Handle optional columns if (labels.contains("custom_settings")) { config.setCustomSettings(rs.getString("custom_settings")); } }, () -> { // Create default configuration config = Config.createDefault(appId); insertDefaultConfig(config); } ); } </pre>
- **Parameters:**
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the consumer to process the first row with column labels if it exists. Must not be {@code null} .
  - `orElseAction` (`Throwables.Runnable<SQLException>`) — the action to execute if no record exists. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowConsumer or orElseAction is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### count(...) -> int
- **Signature:** `@Deprecated public int count() throws IllegalStateException, SQLException`
- **Summary:** Counts all records returned by the query by iterating through the entire result set.
- **Parameters:**
  - (none)
- **Returns:** The total number of records in the result set
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryForInt(), #count(RowFilter)
- **Signature:** `@Beta public int count(final Jdbc.RowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Counts the number of rows that match the given row filter.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to apply to each row. Only rows where this returns {@code true} are counted. Must not be {@code null} .
- **Returns:** The count of rows that match the filter
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #count(BiRowFilter), #anyMatch(RowFilter)
- **Signature:** `public int count(final Jdbc.BiRowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Counts the number of rows that match the given BiRowFilter.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Count rows with specific conditions based on available columns int validCount = JdbcUtil.prepareQuery(conn, "SELECT * FROM products") .count((rs, labels) -> { // Always check required fields if (rs.getDouble("price") <= 0) return false; // Additional check only if column exists if (labels.contains("discontinued")) { return !rs.getBoolean("discontinued"); } return true; }); } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the filter to apply to each row with column labels. Must not be {@code null} .
- **Returns:** The count of rows that match the filter
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #count(RowFilter)
##### anyMatch(...) -> boolean
- **Signature:** `public boolean anyMatch(final Jdbc.RowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Checks if any row in the result set matches the given row filter.
- **Contract:**
  - Checks if any row in the result set matches the given row filter.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if any order is pending boolean hasPendingOrders = JdbcUtil.prepareQuery(conn, "SELECT * FROM orders WHERE customer_id = ?
  - AND date >= ?") .setLong(1, customerId) .setDate(2, startDate) .anyMatch(rs -> "PENDING".equals(rs.getString("status"))); if (hasPendingOrders) { notifyCustomer("You have pending orders"); } } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to test each row. Must not be {@code null} .
- **Returns:** {@code true} if any row matches the filter, {@code false} if no rows match or result set is empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #allMatch(RowFilter), #noneMatch(RowFilter)
- **Signature:** `public boolean anyMatch(final Jdbc.BiRowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Checks if any row in the result set matches the given BiRowFilter.
- **Contract:**
  - Checks if any row in the result set matches the given BiRowFilter.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if any product has invalid data considering available columns boolean hasInvalidProducts = JdbcUtil.prepareQuery(conn, "SELECT * FROM products") .anyMatch((rs, labels) -> { // Check price if (rs.getDouble("price") < 0) return true; // Check optional validation if (labels.contains("min_quantity") && rs.getInt("min_quantity") < 0) { return true; } return false; }); } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the filter to test each row with column labels. Must not be {@code null} .
- **Returns:** {@code true} if any row matches the filter, {@code false} if no rows match or result set is empty
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #anyMatch(RowFilter)
##### allMatch(...) -> boolean
- **Signature:** `public boolean allMatch(final Jdbc.RowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Checks if all rows in the result set match the given RowFilter.
- **Contract:**
  - Checks if all rows in the result set match the given RowFilter.
  - <p> This method returns {@code true} only if every row in the result set satisfies the filter condition.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Verify all items in order are in stock boolean allInStock = JdbcUtil.prepareQuery(conn, "SELECT * FROM order_items WHERE order_id = ?") .setLong(1, orderId) .allMatch(rs -> rs.getInt("quantity") <= rs.getInt("stock_available")); if (allInStock) { processOrder(orderId); } else { notifyOutOfStock(orderId); } } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to test each row. Must not be {@code null} .
- **Returns:** {@code true} if all rows match the filter or result set is empty, {@code false} otherwise
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #anyMatch(RowFilter), #noneMatch(RowFilter)
- **Signature:** `public boolean allMatch(final Jdbc.BiRowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Checks if all rows in the result set match the given BiRowFilter.
- **Contract:**
  - Checks if all rows in the result set match the given BiRowFilter.
  - It returns {@code true} only if every row satisfies the filter condition, with access to column labels for dynamic validation.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Validate all employee records have required fields boolean allValid = JdbcUtil.prepareQuery(conn, "SELECT * FROM employees WHERE dept_id = ?") .setInt(1, deptId) .allMatch((rs, labels) -> { // Required fields if (rs.getString("email") == null) return false; if (rs.getDouble("salary") <= 0) return false; // Optional validation if column exists if (labels.contains("hire_date") && rs.getDate("hire_date") == null) { return false; } return true; }); } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the filter to test each row with column labels. Must not be {@code null} .
- **Returns:** {@code true} if all rows match the filter or result set is empty, {@code false} otherwise
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #allMatch(RowFilter)
##### noneMatch(...) -> boolean
- **Signature:** `public boolean noneMatch(final Jdbc.RowFilter rowFilter) throws SQLException`
- **Summary:** Checks if no rows in the result set match the given RowFilter.
- **Contract:**
  - Checks if no rows in the result set match the given RowFilter.
  - It returns {@code true} only if no row satisfies the filter condition.
  - AND status = 'PENDING'") .setLong(1, customerId) .noneMatch(rs -> rs.getDouble("total_amount") > creditLimit); if (withinCreditLimit) { approveAllPendingOrders(customerId); } } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to test each row. Must not be {@code null} .
- **Returns:** {@code true} if no rows match the filter or result set is empty, {@code false} if any row matches
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #anyMatch(RowFilter), #allMatch(RowFilter)
- **Signature:** `public boolean noneMatch(final Jdbc.BiRowFilter rowFilter) throws SQLException`
- **Summary:** Checks if no rows in the result set match the given BiRowFilter.
- **Contract:**
  - Checks if no rows in the result set match the given BiRowFilter.
  - It provides column-aware filtering and returns {@code true} only if no row satisfies the filter condition.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Ensure no products have conflicting data boolean noConflicts = JdbcUtil.prepareQuery(conn, "SELECT * FROM products WHERE category_id = ?") .setInt(1, categoryId) .noneMatch((rs, labels) -> { // Check for conflicts based on available columns if (labels.contains("special_price") && labels.contains("discount_percent")) { return rs.getDouble("special_price") > 0 && rs.getDouble("discount_percent") > 0; } return false; }); } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the filter to test each row with column labels. Must not be {@code null} .
- **Returns:** {@code true} if no rows match the filter or result set is empty, {@code false} if any row matches
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #anyMatch(BiRowFilter)
##### forEach(...) -> void
- **Signature:** `public void forEach(final Jdbc.RowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Iterates over each row in the result set and applies the given RowConsumer.
- **Parameters:**
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to apply to each row. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowConsumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #forEach(RowFilter, RowConsumer), #forEach(BiRowConsumer)
- **Signature:** `public void forEach(final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Iterates over each row that matches the filter and applies the given RowConsumer.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the filter to apply to each row. Only matching rows are processed. Must not be {@code null} .
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to apply to each filtered row. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowConsumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #forEach(RowConsumer)
- **Signature:** `public void forEach(final Jdbc.BiRowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Iterates over each row in the result set and applies the given BiRowConsumer.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process rows with dynamic column handling JdbcUtil.prepareQuery(conn, "SELECT * FROM products") .forEach((rs, labels) -> { Product product = new Product(); product.setId(rs.getLong("id")); product.setName(rs.getString("name")); // Handle optional columns if (labels.contains("description")) { product.setDescription(rs.getString("description")); } if (labels.contains("category_name")) { product.setCategoryName(rs.getString("category_name")); } processProduct(product); }); } </pre>
- **Parameters:**
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the consumer to apply to each row with column labels. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowConsumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #forEach(BiRowFilter, BiRowConsumer)
- **Signature:** `public void forEach(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Iterates over each row that matches the filter and applies the given BiRowConsumer.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process valid products with dynamic field handling JdbcUtil.prepareQuery(conn, "SELECT p.*, c.name as category_name FROM products p " + "LEFT JOIN categories c ON p.category_id = c.id") .forEach( (rs, labels) -> { // Filter: only active products with category return rs.getBoolean("active") && labels.contains("category_name") && rs.getString("category_name") != null; }, (rs, labels) -> { // Process filtered rows ProductReport report = new ProductReport(); report.setProductId(rs.getLong("id")); report.setProductName(rs.getString("name")); report.setCategoryName(rs.getString("category_name")); // Add optional data if available if (labels.contains("last_updated")) { report.setLastUpdated(rs.getTimestamp("last_updated")); } generateReport(report); } ); } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the filter to apply to each row with column labels. Must not be {@code null} .
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the consumer to apply to each filtered row with column labels. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If rowFilter or rowConsumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
##### foreach(...) -> void
- **Signature:** `@Beta public void foreach(final Consumer<DisposableObjArray> rowConsumer) throws SQLException`
- **Summary:** Iterates over each row and applies the given Consumer to a DisposableObjArray.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process rows with disposable arrays preparedQuery.foreach(row -> { Long id = (Long) row.get(0); String name = (String) row.get(1); Double salary = (Double) row.get(2); if (salary > 50000) { System.out.println("High earner: " + name); } }); } </pre>
- **Parameters:**
  - `rowConsumer` (`Consumer<DisposableObjArray>`) — the consumer to apply to each row's DisposableObjArray. Must not be {@code null} .
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** RowConsumer#oneOff(Consumer), #foreach(Class, Consumer)
- **Signature:** `@Beta public void foreach(final Class<?> entityClass, final Consumer<DisposableObjArray> rowConsumer) throws SQLException`
- **Summary:** Iterates over each row and applies the given Consumer to a DisposableObjArray, using the specified entity class to guide column retrieval.
- **Contract:**
  - } // Process with type-guided retrieval preparedQuery.foreach(User.class, row -> { Long id = (Long) row.get(0); // Retrieved as Long String name = (String) row.get(1); // Retrieved as String LocalDate birthDate = (LocalDate) row.get(2); // Retrieved as LocalDate Boolean active = (Boolean) row.get(3); // Retrieved as Boolean if (active) { sendBirthdayGreeting(id, name, birthDate); } }); } </pre>
- **Parameters:**
  - `entityClass` (`Class<?>`) — the class used to determine proper types for column value retrieval. Must not be {@code null} .
  - `rowConsumer` (`Consumer<DisposableObjArray>`) — the consumer to apply to each row's DisposableObjArray. Must not be {@code null} .
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** RowConsumer#oneOff(Class, Consumer)
##### insert(...) -> Optional<ID>
- **Signature:** `public <ID> Optional<ID> insert() throws SQLException`
- **Summary:** Executes an INSERT statement and retrieves the auto-generated key.
- **Contract:**
  - If no key is generated or the key is a default value (null, 0, etc.), an empty Optional is returned.
- **Parameters:**
  - (none)
- **Returns:** An Optional containing the generated key if available, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #insert(RowMapper), #batchInsert()
- **Signature:** `public <ID> Optional<ID> insert(final Jdbc.RowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException`
- **Summary:** Executes an INSERT statement and retrieves the auto-generated key using a custom extractor.
- **Contract:**
  - <p> This method allows custom extraction of generated keys, useful when dealing with composite keys or non-standard key generation.
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.RowMapper<? extends ID>`) — the function to extract the key from the generated keys ResultSet. The function receives the ResultSet positioned at the generated key row. Must not be {@code null} .
- **Returns:** An Optional containing the generated key if available, otherwise empty. Empty is returned if no key was generated or if the extractor returns {@code null} .
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the statement fails to execute
- **See also:** #insert(BiRowMapper), #insert()
- **Signature:** `public <ID> Optional<ID> insert(final Jdbc.BiRowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException`
- **Summary:** Executes an INSERT statement and retrieves the auto-generated key using a bi-row mapper.
- **Contract:**
  - <p> This method provides access to both the ResultSet and column labels when extracting generated keys, offering more flexibility than the standard row mapper.
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.BiRowMapper<? extends ID>`) — the extractor that receives both ResultSet and column labels. Must not be {@code null} .
- **Returns:** An Optional containing the generated key if it exists, otherwise an empty Optional
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #insert(RowMapper)
##### batchInsert(...) -> List<ID>
- **Signature:** `public <ID> List<ID> batchInsert() throws SQLException`
- **Summary:** Executes a batch INSERT statement and retrieves all generated keys as Long values.
- **Parameters:**
  - (none)
- **Returns:** A list of generated keys. Empty list if no keys were generated.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #batchInsert(RowMapper)
- **Signature:** `public <ID> List<ID> batchInsert(final Jdbc.RowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException`
- **Summary:** Executes a batch INSERT statement and retrieves all generated keys using a custom extractor.
- **Contract:**
  - <p> This method allows custom extraction of generated keys from batch insert operations, useful when dealing with non-numeric keys or composite keys.
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.RowMapper<? extends ID>`) — the extractor to retrieve the auto-generated keys from each row. Must not be {@code null} .
- **Returns:** A list of generated keys. Empty list if no keys were generated.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #batchInsert(), #batchInsert(BiRowMapper)
- **Signature:** `public <ID> List<ID> batchInsert(final Jdbc.BiRowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException`
- **Summary:** Executes a batch INSERT statement and retrieves all generated keys using a bi-row mapper.
- **Contract:**
  - <p> This method provides access to both the ResultSet and column labels when extracting generated keys from batch operations.
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.BiRowMapper<? extends ID>`) — the extractor that receives both ResultSet and column labels. Must not be {@code null} .
- **Returns:** A list of generated keys. Empty list if no keys were generated.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #batchInsert(RowMapper)
##### update(...) -> int
- **Signature:** `public int update() throws IllegalStateException, SQLException`
- **Summary:** Executes an UPDATE, INSERT, or DELETE statement and returns the number of affected rows.
- **Parameters:**
  - (none)
- **Returns:** The number of rows affected by the update. Returns 0 if no rows were affected.
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs or the SQL statement is not a DML statement
- **See also:** #largeUpdate(), #batchUpdate()
##### updateAndReturnGeneratedKeys(...) -> Tuple2<Integer, List<T>>
- **Signature:** `public <T> Tuple2<Integer, List<T>> updateAndReturnGeneratedKeys(final Jdbc.RowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes an UPDATE/INSERT/DELETE statement and returns both the affected row count and generated keys.
- **Contract:**
  - <p> This method is useful when you need to perform an update operation that generates keys (e.g., an INSERT with auto-generated columns or an UPDATE that triggers key generation).
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.RowMapper<T>`) — the extractor to retrieve the auto-generated keys. Must not be {@code null} .
- **Returns:** A tuple containing the number of rows affected and a list of generated keys. The list may be empty if no keys were generated.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided key extractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #updateAndReturnGeneratedKeys(BiRowMapper), #update()
- **Signature:** `public <T> Tuple2<Integer, List<T>> updateAndReturnGeneratedKeys(final Jdbc.BiRowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes an UPDATE/INSERT/DELETE statement and returns both the affected row count and generated keys using a bi-row mapper.
- **Contract:**
  - <p> This method provides access to both the ResultSet and column labels when extracting generated keys from update operations.
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.BiRowMapper<T>`) — the extractor that receives both ResultSet and column labels. Must not be {@code null} .
- **Returns:** A tuple containing the number of rows affected and a list of generated keys
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided key extractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #updateAndReturnGeneratedKeys(RowMapper)
##### batchUpdate(...) -> int\[\]
- **Signature:** `public int[] batchUpdate() throws IllegalStateException, SQLException`
- **Summary:** Executes a batch of UPDATE/INSERT/DELETE statements and returns an array of update counts.
- **Parameters:**
  - (none)
- **Returns:** An array of update counts containing one element for each command in the batch. The elements are ordered according to the order in which commands were added to the batch.
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs or any command in the batch fails
- **See also:** #largeBatchUpdate(), #batchUpdateAndReturnGeneratedKeys(RowMapper)
##### batchUpdateAndReturnGeneratedKeys(...) -> Tuple2<int\[\], List<T>>
- **Signature:** `public <T> Tuple2<int[], List<T>> batchUpdateAndReturnGeneratedKeys(final Jdbc.RowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes a batch update operation and returns both the update counts and generated keys.
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.RowMapper<T>`) — the extractor to retrieve the auto-generated keys. Must not be {@code null} .
- **Returns:** A tuple containing an array of update counts and a list of generated keys
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided key extractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #batchUpdate(), #batchUpdateAndReturnGeneratedKeys(BiRowMapper)
- **Signature:** `public <T> Tuple2<int[], List<T>> batchUpdateAndReturnGeneratedKeys(final Jdbc.BiRowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes a batch update operation and returns both the update counts and generated keys using a bi-row mapper.
- **Contract:**
  - <p> This method provides access to both the ResultSet and column labels when extracting generated keys from batch update operations.
- **Parameters:**
  - `autoGeneratedKeyExtractor` (`Jdbc.BiRowMapper<T>`) — the extractor that receives both ResultSet and column labels. Must not be {@code null} .
- **Returns:** A tuple containing an array of update counts and a list of generated keys
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided key extractor is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #batchUpdateAndReturnGeneratedKeys(RowMapper)
##### largeUpdate(...) -> long
- **Signature:** `public long largeUpdate() throws IllegalStateException, SQLException`
- **Summary:** Executes a large update operation that may affect more rows than can be represented by an int.
- **Contract:**
  - Use this method when working with very large tables or bulk operations.
- **Parameters:**
  - (none)
- **Returns:** The number of rows affected by the update as a long value
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #update(), #largeBatchUpdate()
##### largeBatchUpdate(...) -> long\[\]
- **Signature:** `public long[] largeBatchUpdate() throws IllegalStateException, SQLException`
- **Summary:** Executes a large batch update operation that may affect more rows than can be represented by int values.
- **Parameters:**
  - (none)
- **Returns:** An array containing the number of rows affected by each update in the batch as long values
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #batchUpdate(), #largeUpdate()
##### execute(...) -> boolean
- **Signature:** `public boolean execute() throws IllegalStateException, SQLException`
- **Summary:** Executes the SQL statement which may return multiple results.
- **Contract:**
  - Use this method when the SQL statement may return multiple result sets, update counts, or a combination of both.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code boolean hasResultSet = JdbcUtil.prepareQuery(conn, "CALL complex_procedure(?)") .setInt(1, parameter) .execute(); if (hasResultSet) { // First result is a ResultSet // Use getResultSet() to retrieve it } else { // First result is an update count // Use getUpdateCount() to retrieve it } } </pre> <p> <b> Note: </b> The underlying statement will be closed after execution unless {@link #closeAfterExecution(boolean)} has been set to {@code false} .
- **Parameters:**
  - (none)
- **Returns:** {@code true} if the first result is a ResultSet object; {@code false} if it is an update count or there are no results
- **Throws:**
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #executeThenApply(Throwables.Function), #executeThenApply(Throwables.BiFunction), #executeThenAccept(Throwables.Consumer), #executeThenAccept(Throwables.BiConsumer)
##### executeThenApply(...) -> R
- **Signature:** `public <R> R executeThenApply(final Throwables.Function<? super Stmt, ? extends R, SQLException> getter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the SQL statement and applies the provided function to extract a result.
- **Contract:**
  - This is useful when you need to access statement metadata or handle complex result processing.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get the first result set after execution ResultSet rs = preparedQuery.executeThenApply(stmt -> stmt.getResultSet()); // Get update count and check warnings Integer count = preparedQuery.executeThenApply(stmt -> { int updateCount = stmt.getUpdateCount(); SQLWarning warning = stmt.getWarnings(); if (warning != null) { logger.warn("SQL Warning: " + warning.getMessage()); } return updateCount; }); } </pre>
- **Parameters:**
  - `getter` (`Throwables.Function<? super Stmt, ? extends R, SQLException>`) — the function to apply to the PreparedStatement after execution. Must not be {@code null} .
- **Returns:** The result of applying the function to the PreparedStatement
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided function is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #execute(), #executeThenApply(Throwables.BiFunction)
- **Signature:** `public <R> R executeThenApply(final Throwables.BiFunction<? super Stmt, Boolean, ? extends R, SQLException> getter) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the SQL statement and applies the provided bi-function to extract a result.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process result based on type Object result = preparedQuery.executeThenApply((stmt, isResultSet) -> { if (isResultSet) { return processResultSet(stmt.getResultSet()); } else { return stmt.getUpdateCount(); } }); } </pre>
- **Parameters:**
  - `getter` (`Throwables.BiFunction<? super Stmt, Boolean, ? extends R, SQLException>`) — the function to apply to the PreparedStatement. The first parameter is the executed PreparedStatement, the second parameter indicates if the first result is a ResultSet object. Must not be {@code null} .
- **Returns:** The result of applying the function to the PreparedStatement
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided function is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #executeThenApply(Throwables.Function)
##### executeThenAccept(...) -> void
- **Signature:** `public void executeThenAccept(final Throwables.Consumer<? super Stmt, SQLException> consumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the SQL statement and applies the provided consumer to process the statement.
- **Contract:**
  - This is useful for side effects or when you don't need to return a value.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process warnings after execution preparedQuery.executeThenAccept(stmt -> { SQLWarning warning = stmt.getWarnings(); while (warning != null) { logger.warn("SQL Warning: " + warning.getMessage()); warning = warning.getNextWarning(); } }); // Process multiple result sets preparedQuery.executeThenAccept(stmt -> { boolean hasMoreResults = true; while (hasMoreResults) { if (stmt.getUpdateCount() != -1) { System.out.println("Update count: " + stmt.getUpdateCount()); } else { try (ResultSet rs = stmt.getResultSet()) { processResultSet(rs); } } hasMoreResults = stmt.getMoreResults(); } }); } </pre>
- **Parameters:**
  - `consumer` (`Throwables.Consumer<? super Stmt, SQLException>`) — the consumer to apply to the PreparedStatement after execution. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided consumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #execute(), #executeThenAccept(Throwables.BiConsumer)
- **Signature:** `public void executeThenAccept(final Throwables.BiConsumer<? super Stmt, Boolean, SQLException> consumer) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the SQL statement and applies the provided bi-consumer to process the statement.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code preparedQuery.executeThenAccept((stmt, isResultSet) -> { if (isResultSet) { try (ResultSet rs = stmt.getResultSet()) { while (rs.next()) { System.out.println("Result: " + rs.getString(1)); } } } else { System.out.println("Rows affected: " + stmt.getUpdateCount()); } }); } </pre>
- **Parameters:**
  - `consumer` (`Throwables.BiConsumer<? super Stmt, Boolean, SQLException>`) — the consumer to apply to the PreparedStatement. The first parameter is the executed PreparedStatement, the second parameter indicates if the first result is a ResultSet object. Must not be {@code null} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided consumer is null
  - `java.lang.IllegalStateException` — if this query is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #executeThenAccept(Throwables.Consumer)
##### asyncCall(...) -> ContinuableFuture<R>
- **Signature:** `@Beta public <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super This, ? extends R, SQLException> sqlAction) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Asynchronously executes the provided SQL action using this query instance.
- **Parameters:**
  - `sqlAction` (`Throwables.Function<? super This, ? extends R, SQLException>`) — the SQL action to be executed asynchronously. Must not be {@code null} .
- **Returns:** A ContinuableFuture representing the result of the asynchronous execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided SQL action is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** #asyncCall(Throwables.Function, Executor), #asyncRun(Throwables.Consumer)
- **Signature:** `@Beta public <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super This, ? extends R, SQLException> sqlAction, final Executor executor) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Asynchronously executes the provided SQL action using this query instance with a custom executor.
- **Contract:**
  - This is useful when you want to control the thread pool used for database operations.
- **Parameters:**
  - `sqlAction` (`Throwables.Function<? super This, ? extends R, SQLException>`) — the SQL action to be executed asynchronously. Must not be {@code null} .
  - `executor` (`Executor`) — the executor to use for asynchronous execution. Must not be {@code null} .
- **Returns:** A ContinuableFuture representing the result of the asynchronous execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — If sqlAction or executor is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** #asyncCall(Throwables.Function)
##### asyncRun(...) -> ContinuableFuture<Void>
- **Signature:** `@Beta public ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super This, SQLException> sqlAction) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Asynchronously executes the provided SQL action without returning a result.
- **Parameters:**
  - `sqlAction` (`Throwables.Consumer<? super This, SQLException>`) — the SQL action to be executed asynchronously. Must not be {@code null} .
- **Returns:** A ContinuableFuture representing the completion of the asynchronous execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided SQL action is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** #asyncRun(Throwables.Consumer, Executor), #asyncCall(Throwables.Function)
- **Signature:** `@Beta public ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super This, SQLException> sqlAction, final Executor executor) throws IllegalArgumentException, IllegalStateException`
- **Summary:** Asynchronously executes the provided SQL action without returning a result using a custom executor.
- **Parameters:**
  - `sqlAction` (`Throwables.Consumer<? super This, SQLException>`) — the SQL action to be executed asynchronously. Must not be {@code null} .
  - `executor` (`Executor`) — the executor to use for asynchronous execution. Must not be {@code null} .
- **Returns:** A ContinuableFuture representing the completion of the asynchronous execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — If sqlAction or executor is null
  - `java.lang.IllegalStateException` — if this query is closed
- **See also:** #asyncRun(Throwables.Consumer)
##### close(...) -> void
- **Signature:** `@Override public void close()`
- **Summary:** Closes this query instance and releases any resources associated with it.
- **Contract:**
  - If the instance is already closed, this method does nothing (idempotent).
  - } finally { if (query != null) { query.close(); } } // Or use try-with-resources: try (AbstractQuery<?, ?> query = JdbcUtil.prepareQuery(conn, sql)) { // Use query...
- **Parameters:**
  - (none)
- **See also:** AutoCloseable#close()

### Class CallableQuery (com.landawn.abacus.jdbc.CallableQuery)
A wrapper class for {@link CallableStatement} that provides a fluent API for executing stored procedures and handling OUT parameters.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### setNull(...) -> CallableQuery
- **Signature:** `public CallableQuery setNull(final String parameterName, final int sqlType) throws SQLException`
- **Summary:** Sets the specified named parameter to SQL {@code NULL} .
- **Contract:**
  - <p> <b> Note: </b> You must specify the SQL type of the parameter being set to {@code null} .
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to set to {@code NULL} .
  - `sqlType` (`int`) — the SQL type code defined in {@link java.sql.Types} .
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
- **Signature:** `public CallableQuery setNull(final String parameterName, final int sqlType, final String typeName) throws SQLException`
- **Summary:** Sets the specified named parameter to SQL {@code NULL} .
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to set to {@code NULL} .
  - `sqlType` (`int`) — the SQL type code from {@link java.sql.Types} (e.g., {@code STRUCT} , {@code REF} ).
  - `typeName` (`String`) — the fully-qualified name of the SQL user-defined type.
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
##### setBoolean(...) -> CallableQuery
- **Signature:** `public CallableQuery setBoolean(final String parameterName, final boolean x) throws SQLException`
- **Summary:** Sets the specified named parameter to a boolean value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`boolean`) — the boolean value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setBoolean(final String parameterName, final Boolean x) throws SQLException`
- **Summary:** Sets the specified named parameter to a Boolean value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Boolean`) — the Boolean value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setByte(...) -> CallableQuery
- **Signature:** `public CallableQuery setByte(final String parameterName, final byte x) throws SQLException`
- **Summary:** Sets the specified named parameter to a byte value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`byte`) — the byte value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setByte(final String parameterName, final Byte x) throws SQLException`
- **Summary:** Sets the specified named parameter to a Byte value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Byte`) — the Byte value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setShort(...) -> CallableQuery
- **Signature:** `public CallableQuery setShort(final String parameterName, final short x) throws SQLException`
- **Summary:** Sets the specified named parameter to a short value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`short`) — the short value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setShort(final String parameterName, final Short x) throws SQLException`
- **Summary:** Sets the specified named parameter to a Short value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Short`) — the Short value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setInt(...) -> CallableQuery
- **Signature:** `public CallableQuery setInt(final String parameterName, final int x) throws SQLException`
- **Summary:** Sets the specified named parameter to an int value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`int`) — the int value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setInt(final String parameterName, final Integer x) throws SQLException`
- **Summary:** Sets the specified named parameter to an Integer value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Integer`) — the Integer value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setLong(...) -> CallableQuery
- **Signature:** `public CallableQuery setLong(final String parameterName, final long x) throws SQLException`
- **Summary:** Sets the specified named parameter to a long value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`long`) — the long value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setLong(final String parameterName, final Long x) throws SQLException`
- **Summary:** Sets the specified named parameter to a Long value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Long`) — the Long value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setLong(final String parameterName, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger value as a long for the specified parameter.
- **Contract:**
  - The BigInteger must be within the range of a long value.
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setFloat(...) -> CallableQuery
- **Signature:** `public CallableQuery setFloat(final String parameterName, final float x) throws SQLException`
- **Summary:** Sets the specified named parameter to a float value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`float`) — the float value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setFloat(final String parameterName, final Float x) throws SQLException`
- **Summary:** Sets the specified named parameter to a Float value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Float`) — the Float value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setDouble(...) -> CallableQuery
- **Signature:** `public CallableQuery setDouble(final String parameterName, final double x) throws SQLException`
- **Summary:** Sets the specified named parameter to a double value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`double`) — the double value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setDouble(final String parameterName, final Double x) throws SQLException`
- **Summary:** Sets the specified named parameter to a Double value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Double`) — the Double value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBigDecimal(...) -> CallableQuery
- **Signature:** `public CallableQuery setBigDecimal(final String parameterName, final BigDecimal x) throws SQLException`
- **Summary:** Sets the specified named parameter to a BigDecimal value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`BigDecimal`) — the BigDecimal value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setBigDecimal(final String parameterName, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger value as a BigDecimal for the specified parameter.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBigIntegerAsString(...) -> CallableQuery
- **Signature:** `@Beta public CallableQuery setBigIntegerAsString(final String parameterName, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger value as a String for the specified parameter.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`BigInteger`) — the BigInteger value to set as string, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setString(String, BigInteger), #setBigDecimal(String, BigInteger), #setLong(String, BigInteger)
##### setString(...) -> CallableQuery
- **Signature:** `public CallableQuery setString(final String parameterName, final String x) throws SQLException`
- **Summary:** Sets the specified named parameter to a String value.
- **Contract:**
  - <p> <b> Null Handling: </b> If the {@code x} parameter is {@code null} , the database parameter will be set to SQL NULL.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Setting a non-null string value query.setString("firstName", "John"); // Setting NULL when value is absent String middleName = getMiddleName(); // might return null query.setString("middleName", middleName); } </pre>
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`String`) — the String value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setString(final String parameterName, final CharSequence x) throws SQLException`
- **Summary:** Sets a CharSequence value as a String for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`CharSequence`) — the CharSequence value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setString(final String parameterName, final char x) throws SQLException`
- **Summary:** Sets a char value as a String for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`char`) — the char value to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setString(final String parameterName, final Character x) throws SQLException`
- **Summary:** Sets a Character value as a String for the specified parameter.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Character`) — the Character value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setString(final String parameterName, final BigInteger x) throws SQLException`
- **Summary:** Sets a BigInteger value as a String for the specified parameter.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`BigInteger`) — the BigInteger value to set as string, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setNString(...) -> CallableQuery
- **Signature:** `public CallableQuery setNString(final String parameterName, final String x) throws SQLException`
- **Summary:** Sets the specified named parameter to a national character string value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`String`) — the String value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setDate(...) -> CallableQuery
- **Signature:** `public CallableQuery setDate(final String parameterName, final java.sql.Date x) throws SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Date value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.Date`) — the java.sql.Date value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setDate(final String parameterName, final java.util.Date x) throws SQLException`
- **Summary:** Sets a java.util.Date value as a java.sql.Date for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.util.Date`) — the java.util.Date value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setDate(final String parameterName, final LocalDate x) throws SQLException`
- **Summary:** Sets the specified named parameter to a LocalDate value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`LocalDate`) — the LocalDate value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setTime(...) -> CallableQuery
- **Signature:** `public CallableQuery setTime(final String parameterName, final java.sql.Time x) throws SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Time value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.Time`) — the java.sql.Time value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setTime(final String parameterName, final java.util.Date x) throws SQLException`
- **Summary:** Sets a java.util.Date value as a java.sql.Time for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.util.Date`) — the java.util.Date value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setTime(final String parameterName, final LocalTime x) throws SQLException`
- **Summary:** Sets the specified named parameter to a LocalTime value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`LocalTime`) — the LocalTime value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setTimestamp(...) -> CallableQuery
- **Signature:** `public CallableQuery setTimestamp(final String parameterName, final java.sql.Timestamp x) throws SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Timestamp value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.Timestamp`) — the java.sql.Timestamp value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setTimestamp(final String parameterName, final java.util.Date x) throws SQLException`
- **Summary:** Sets a java.util.Date value as a java.sql.Timestamp for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.util.Date`) — the java.util.Date value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setTimestamp(final String parameterName, final LocalDateTime x) throws SQLException`
- **Summary:** Sets the specified named parameter to a LocalDateTime value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`LocalDateTime`) — the LocalDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setTimestamp(final String parameterName, final ZonedDateTime x) throws SQLException`
- **Summary:** Sets the specified named parameter to a ZonedDateTime value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`ZonedDateTime`) — the ZonedDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setTimestamp(final String parameterName, final OffsetDateTime x) throws SQLException`
- **Summary:** Sets the specified named parameter to an OffsetDateTime value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`OffsetDateTime`) — the OffsetDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setTimestamp(final String parameterName, final Instant x) throws SQLException`
- **Summary:** Sets the specified named parameter to an Instant value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Instant`) — the Instant value to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBytes(...) -> CallableQuery
- **Signature:** `public CallableQuery setBytes(final String parameterName, final byte[] x) throws SQLException`
- **Summary:** Sets a byte array for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`byte[]`) — the byte array to set, or {@code null} to set SQL NULL
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setAsciiStream(...) -> CallableQuery
- **Signature:** `public CallableQuery setAsciiStream(final String parameterName, final InputStream inputStream) throws SQLException`
- **Summary:** Sets an ASCII stream for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `inputStream` (`InputStream`) — the {@code InputStream} object containing the ASCII parameter value
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setAsciiStream(final String parameterName, final InputStream inputStream, final long length) throws SQLException`
- **Summary:** Sets an ASCII stream for the specified parameter with a specified length.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `inputStream` (`InputStream`) — the {@code InputStream} object containing the ASCII parameter value
  - `length` (`long`) — the number of bytes in the stream
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBinaryStream(...) -> CallableQuery
- **Signature:** `public CallableQuery setBinaryStream(final String parameterName, final InputStream inputStream) throws SQLException`
- **Summary:** Sets a binary stream for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `inputStream` (`InputStream`) — the {@code InputStream} object containing the binary parameter value
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setBinaryStream(final String parameterName, final InputStream inputStream, final long length) throws SQLException`
- **Summary:** Sets a binary stream for the specified parameter with a specified length.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `inputStream` (`InputStream`) — the {@code InputStream} object containing the binary parameter value
  - `length` (`long`) — the number of bytes in the stream
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setCharacterStream(...) -> CallableQuery
- **Signature:** `public CallableQuery setCharacterStream(final String parameterName, final Reader reader) throws SQLException`
- **Summary:** Sets a character stream for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the Unicode data
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setCharacterStream(final String parameterName, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets a character stream for the specified parameter with a specified length.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the Unicode data
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setNCharacterStream(...) -> CallableQuery
- **Signature:** `public CallableQuery setNCharacterStream(final String parameterName, final Reader reader) throws SQLException`
- **Summary:** Sets a national character stream for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the Unicode data
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setNCharacterStream(final String parameterName, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets a national character stream for the specified parameter with a specified length.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the Unicode data
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setBlob(...) -> CallableQuery
- **Signature:** `public CallableQuery setBlob(final String parameterName, final java.sql.Blob x) throws SQLException`
- **Summary:** Sets a Blob object for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.Blob`) — a Blob object that maps to a SQL BLOB value
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setBlob(final String parameterName, final InputStream inputStream) throws SQLException`
- **Summary:** Sets a Blob value using an InputStream for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `inputStream` (`InputStream`) — the {@code InputStream} object containing the data to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setBlob(final String parameterName, final InputStream inputStream, final long length) throws SQLException`
- **Summary:** Sets a Blob value using an InputStream with a specified length for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `inputStream` (`InputStream`) — the {@code InputStream} object containing the data to set
  - `length` (`long`) — the number of bytes in the parameter data
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setClob(...) -> CallableQuery
- **Signature:** `public CallableQuery setClob(final String parameterName, final java.sql.Clob x) throws SQLException`
- **Summary:** Sets a Clob object for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.Clob`) — a Clob object that maps to a SQL CLOB value
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setClob(final String parameterName, final Reader reader) throws SQLException`
- **Summary:** Sets a Clob value using a Reader for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the data to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setClob(final String parameterName, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets a Clob value using a Reader with a specified length for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the data to set
  - `length` (`long`) — the number of characters in the parameter data
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setNClob(...) -> CallableQuery
- **Signature:** `public CallableQuery setNClob(final String parameterName, final java.sql.NClob x) throws SQLException`
- **Summary:** Sets an NClob object for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.NClob`) — an NClob object that maps to a SQL NCLOB value
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setNClob(final String parameterName, final Reader reader) throws SQLException`
- **Summary:** Sets an NClob value using a Reader for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the Unicode data to set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setNClob(final String parameterName, final Reader reader, final long length) throws SQLException`
- **Summary:** Sets an NClob value using a Reader with a specified length for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `reader` (`Reader`) — the {@code Reader} object containing the Unicode data to set
  - `length` (`long`) — the number of characters in the parameter data
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setURL(...) -> CallableQuery
- **Signature:** `public CallableQuery setURL(final String parameterName, final URL x) throws SQLException`
- **Summary:** Sets the specified named parameter to a URL value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`URL`) — the java.net.URL object to be set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setSQLXML(...) -> CallableQuery
- **Signature:** `public CallableQuery setSQLXML(final String parameterName, final java.sql.SQLXML x) throws SQLException`
- **Summary:** Sets an SQLXML object for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.SQLXML`) — an SQLXML object that maps to a SQL XML value
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setRowId(...) -> CallableQuery
- **Signature:** `public CallableQuery setRowId(final String parameterName, final java.sql.RowId x) throws SQLException`
- **Summary:** Sets a RowId object for the specified parameter.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`java.sql.RowId`) — the RowId object to be set
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### setObject(...) -> CallableQuery
- **Signature:** `public CallableQuery setObject(final String parameterName, final Object x) throws SQLException`
- **Summary:** Sets the specified named parameter to an object value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Object`) — the object containing the input parameter value
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public CallableQuery setObject(final String parameterName, final Object x, final int sqlType) throws SQLException`
- **Summary:** Sets an object value for the specified parameter with a specified SQL type.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Object`) — the object containing the input parameter value
  - `sqlType` (`int`) — the SQL type code defined in {@link java.sql.Types}
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
- **Signature:** `public CallableQuery setObject(final String parameterName, final Object x, final int sqlType, final int scaleOrLength) throws SQLException`
- **Summary:** Sets an object value for the specified parameter with a specified SQL type and scale.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter
  - `x` (`Object`) — the object containing the input parameter value
  - `sqlType` (`int`) — the SQL type code defined in {@link java.sql.Types}
  - `scaleOrLength` (`int`) — for {@code java.sql.Types.DECIMAL} or {@code java.sql.Types.NUMERIC} types, this is the number of digits after the decimal point. For all other types, this value will be ignored
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
##### setParameters(...) -> CallableQuery
- **Signature:** `public CallableQuery setParameters(final Map<String, ?> parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters from a Map where keys are parameter names and values are parameter values.
- **Parameters:**
  - `parameters` (`Map<String, ?>`) — a map containing parameter names as keys and their corresponding values
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameters map is {@code null}
  - `java.sql.SQLException` — if a database access error occurs or any parameter name is not valid
- **Signature:** `public CallableQuery setParameters(final Object entity, final List<String> parameterNames) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters for this CallableQuery by extracting values from an entity object.
- **Contract:**
  - Each parameter name in the list should correspond to a property name in the entity object.
- **Parameters:**
  - `entity` (`Object`) — the entity object containing the parameter values. Must not be {@code null} .
  - `parameterNames` (`List<String>`) — a list of parameter names corresponding to properties in the entity. Each name should match a property name in the entity class.
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the entity or parameterNames is null
  - `java.sql.SQLException` — if a database access error occurs or if a parameter name doesn't correspond to a valid property in the entity
- **See also:** Beans#getPropNameList(Class), Beans#getPropNames(Class, Collection), JdbcUtil#getNamedParameters(String)
##### registerOutParameter(...) -> CallableQuery
- **Signature:** `public CallableQuery registerOutParameter(final int parameterIndex, final int sqlType) throws SQLException`
- **Summary:** Registers a parameter as an OUT parameter with the specified SQL type.
- **Contract:**
  - <p> OUT parameters must be registered before the statement is executed.
  - The SQL type specified should match the type of data the stored procedure will return for this parameter.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter (starts from 1, not 0)
  - `sqlType` (`int`) — the SQL type code as defined in {@link java.sql.Types}
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterIndex is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(int, int), java.sql.Types
- **Signature:** `public CallableQuery registerOutParameter(final int parameterIndex, final int sqlType, final int scale) throws SQLException`
- **Summary:** Registers a parameter as an OUT parameter with the specified SQL type and scale.
- **Contract:**
  - <p> The scale parameter is particularly important for fixed-point numeric types to ensure proper precision when retrieving the OUT parameter value.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter (starts from 1, not 0)
  - `sqlType` (`int`) — the SQL type code as defined in {@link java.sql.Types}
  - `scale` (`int`) — the number of digits to the right of the decimal point. Used for DECIMAL and NUMERIC types.
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterIndex is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(int, int, int), java.sql.Types#DECIMAL, java.sql.Types#NUMERIC
- **Signature:** `public CallableQuery registerOutParameter(final int parameterIndex, final int sqlType, final String typeName) throws SQLException`
- **Summary:** Registers a parameter as an OUT parameter with a user-defined SQL type name.
- **Contract:**
  - This method is used for database-specific types, user-defined types (UDTs), or when you need to specify the exact SQL type name for proper type mapping.
  - <p> The typeName parameter should be the fully-qualified SQL type name, which may include the schema name if required by the database.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter (starts from 1, not 0)
  - `sqlType` (`int`) — the SQL type code as defined in {@link java.sql.Types}
  - `typeName` (`String`) — the fully-qualified SQL type name. For user-defined types, this should include the schema name if required.
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterIndex is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(int, int, String), java.sql.Types#STRUCT, java.sql.Types#DISTINCT, java.sql.Types#JAVA_OBJECT
- **Signature:** `public CallableQuery registerOutParameter(final String parameterName, final int sqlType) throws SQLException`
- **Summary:** Registers a named parameter as an OUT parameter with the specified SQL type.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter as defined in the stored procedure
  - `sqlType` (`int`) — the SQL type code as defined in {@link java.sql.Types}
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterName is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(String, int), java.sql.Types
- **Signature:** `public CallableQuery registerOutParameter(final String parameterName, final int sqlType, final int scale) throws SQLException`
- **Summary:** Registers a named parameter as an OUT parameter with the specified SQL type and scale.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter as defined in the stored procedure
  - `sqlType` (`int`) — the SQL type code as defined in {@link java.sql.Types}
  - `scale` (`int`) — the number of digits to the right of the decimal point
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterName is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(String, int, int), java.sql.Types#DECIMAL, java.sql.Types#NUMERIC
- **Signature:** `public CallableQuery registerOutParameter(final String parameterName, final int sqlType, final String typeName) throws SQLException`
- **Summary:** Registers a named parameter as an OUT parameter with a user-defined SQL type name.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter as defined in the stored procedure
  - `sqlType` (`int`) — the SQL type code as defined in {@link java.sql.Types}
  - `typeName` (`String`) — the fully-qualified SQL type name
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterName is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(String, int, String), java.sql.Types#STRUCT, java.sql.Types#DISTINCT
- **Signature:** `public CallableQuery registerOutParameter(final int parameterIndex, final SQLType sqlType) throws SQLException`
- **Summary:** Registers a parameter as an OUT parameter using the JDBC 4.2 {@link SQLType} interface.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter (starts from 1, not 0)
  - `sqlType` (`SQLType`) — the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterIndex is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(int, java.sql.SQLType), java.sql.JDBCType
- **Signature:** `public CallableQuery registerOutParameter(final int parameterIndex, final SQLType sqlType, final int scale) throws SQLException`
- **Summary:** Registers a parameter as an OUT parameter using {@link SQLType} with scale specification.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter (starts from 1, not 0)
  - `sqlType` (`SQLType`) — the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation
  - `scale` (`int`) — the number of digits to the right of the decimal point
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterIndex is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(int, java.sql.SQLType, int), java.sql.JDBCType#DECIMAL, java.sql.JDBCType#NUMERIC
- **Signature:** `public CallableQuery registerOutParameter(final int parameterIndex, final SQLType sqlType, final String typeName) throws SQLException`
- **Summary:** Registers a parameter as an OUT parameter using {@link SQLType} with a user-defined type name.
- **Parameters:**
  - `parameterIndex` (`int`) — the index of the parameter (starts from 1, not 0)
  - `sqlType` (`SQLType`) — the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation
  - `typeName` (`String`) — the fully-qualified SQL type name
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterIndex is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(int, java.sql.SQLType, String), java.sql.JDBCType#STRUCT, java.sql.JDBCType#ARRAY
- **Signature:** `public CallableQuery registerOutParameter(final String parameterName, final SQLType sqlType) throws SQLException`
- **Summary:** Registers a named parameter as an OUT parameter using the JDBC 4.2 {@link SQLType} interface.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter as defined in the stored procedure
  - `sqlType` (`SQLType`) — the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterName is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(String, java.sql.SQLType), java.sql.JDBCType
- **Signature:** `public CallableQuery registerOutParameter(final String parameterName, final SQLType sqlType, final int scale) throws SQLException`
- **Summary:** Registers a named parameter as an OUT parameter using {@link SQLType} with scale specification.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter as defined in the stored procedure
  - `sqlType` (`SQLType`) — the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation
  - `scale` (`int`) — the number of digits to the right of the decimal point
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterName is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(String, java.sql.SQLType, int), java.sql.JDBCType#DECIMAL
- **Signature:** `public CallableQuery registerOutParameter(final String parameterName, final SQLType sqlType, final String typeName) throws SQLException`
- **Summary:** Registers a named parameter as an OUT parameter using {@link SQLType} with a user-defined type name.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter as defined in the stored procedure
  - `sqlType` (`SQLType`) — the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation
  - `typeName` (`String`) — the fully-qualified SQL type name
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if parameterName is invalid
- **See also:** java.sql.CallableStatement#registerOutParameter(String, java.sql.SQLType, String), java.sql.JDBCType#STRUCT
##### registerOutParameters(...) -> CallableQuery
- **Signature:** `public CallableQuery registerOutParameters(final Jdbc.ParametersSetter<? super CallableQuery> register) throws IllegalArgumentException, SQLException`
- **Summary:** Registers multiple OUT parameters using a functional interface approach.
- **Contract:**
  - This method allows for more complex registration logic and is useful when you need to register multiple parameters based on dynamic conditions.
  - If an exception occurs during registration, the statement is automatically closed.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code query.registerOutParameters(q -> { q.registerOutParameter(1, Types.INTEGER); q.registerOutParameter(2, Types.VARCHAR); if (includeDetails) { q.registerOutParameter(3, Types.CLOB); } }).execute(); } </pre>
- **Parameters:**
  - `register` (`Jdbc.ParametersSetter<? super CallableQuery>`) — the {@link Jdbc.ParametersSetter} that will register the OUT parameters. Must not be {@code null} .
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if register is null
  - `java.sql.SQLException` — if a database access error occurs during parameter registration
- **Signature:** `public <T> CallableQuery registerOutParameters(final T parameter, final Jdbc.BiParametersSetter<? super CallableQuery, ? super T> register) throws SQLException`
- **Summary:** Registers multiple OUT parameters using a bi-functional interface and an additional context object.
- **Contract:**
  - If an exception occurs during registration, the statement is automatically closed.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code class ReportConfig { boolean includeTotal; boolean includeAvg; // getters } ReportConfig config = new ReportConfig(true, false); query.registerOutParameters(config, (q, cfg) -> { int paramIndex = 1; q.registerOutParameter(paramIndex++, Types.VARCHAR); // always return a status message if (cfg.includeTotal()) { q.registerOutParameter(paramIndex++, Types.DECIMAL); } if (cfg.includeAvg()) { q.registerOutParameter(paramIndex++, Types.DECIMAL, 2); } }).execute(); } </pre>
- **Parameters:**
  - `parameter` (`T`) — the context object to be passed to the {@code BiParametersSetter} .
  - `register` (`Jdbc.BiParametersSetter<? super CallableQuery, ? super T>`) — the {@link Jdbc.BiParametersSetter} that defines the registration logic. Must not be {@code null} .
- **Returns:** this CallableQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs during parameter registration.
##### executeThenApply(...) -> R
- **Signature:** `@Override public <R> R executeThenApply(final Throwables.Function<? super CallableStatement, ? extends R, SQLException> getter) throws SQLException`
- **Summary:** Executes the stored procedure and applies the provided function to the executed CallableStatement.
- **Parameters:**
  - `getter` (`Throwables.Function<? super CallableStatement, ? extends R, SQLException>`) — the function to apply to the executed CallableStatement
- **Returns:** the result of applying the function
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the function throws an exception
- **See also:** JdbcUtil#getOutParameters(CallableStatement, List), JdbcUtil#streamAllResultSets(Statement, Jdbc.ResultExtractor), JdbcUtil#streamAllResultSets(Statement, Jdbc.BiResultExtractor)
- **Signature:** `@Override public <R> R executeThenApply(final Throwables.BiFunction<? super CallableStatement, Boolean, ? extends R, SQLException> getter) throws SQLException`
- **Summary:** Executes the stored procedure and applies the provided bi-function to the executed CallableStatement and a boolean indicating whether the first result is a ResultSet.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Object result = query.executeThenApply((stmt, isResultSet) -> { if (isResultSet) { ResultSet rs = stmt.getResultSet(); // Process result set } else { int updateCount = stmt.getUpdateCount(); // Process update count } return processedResult; }); } </pre>
- **Parameters:**
  - `getter` (`Throwables.BiFunction<? super CallableStatement, Boolean, ? extends R, SQLException>`) — the bi-function to apply. The first parameter is the executed CallableStatement, the second parameter is {@code true} if the first result is a ResultSet, {@code false} otherwise
- **Returns:** the result of applying the bi-function
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the function throws an exception
- **See also:** JdbcUtil#getOutParameters(CallableStatement, List), JdbcUtil#streamAllResultSets(Statement, Jdbc.ResultExtractor)
- **Signature:** `public <R> R executeThenApply(final Throwables.TriFunction<? super CallableStatement, List<Jdbc.OutParam>, Boolean, ? extends R, SQLException> getter) throws SQLException`
- **Summary:** Executes the stored procedure and applies the provided tri-function to process the results with full access to the CallableStatement, OUT parameters, and result type information.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Map<String, Object> results = query.executeThenApply( (stmt, outParams, isResultSet) -> { Map<String, Object> map = new HashMap<>(); // Process OUT parameters for (Jdbc.OutParam param : outParams) { if (param.getParameterName() != null) { map.put(param.getParameterName(), stmt.getObject(param.getParameterName())); } } // Process result set if available if (isResultSet) { ResultSet rs = stmt.getResultSet(); // Add result set data to map } return map; } ); } </pre>
- **Parameters:**
  - `getter` (`Throwables.TriFunction<? super CallableStatement, List<Jdbc.OutParam>, Boolean, ? extends R, SQLException>`) — the tri-function to apply. Parameters are: 1. The executed CallableStatement 2. List of registered OUT parameters 3. Boolean indicating if the first result is a ResultSet
- **Returns:** the result of applying the tri-function
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the function throws an exception
- **See also:** Jdbc.OutParam, JdbcUtil#getOutParameters(CallableStatement, List)
##### executeThenAccept(...) -> void
- **Signature:** `@Override public void executeThenAccept(final Throwables.Consumer<? super CallableStatement, SQLException> consumer) throws SQLException`
- **Summary:** Executes the stored procedure and applies the provided consumer to the executed CallableStatement.
- **Contract:**
  - This method is useful when you need to perform side effects with the statement but don't need to return a value.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code query.executeThenAccept(stmt -> { // Log execution details logger.info("Warnings: " + stmt.getWarnings()); // Process multiple result sets boolean hasResults = true; while (hasResults) { if (stmt.getResultSet() != null) { // Process result set } hasResults = stmt.getMoreResults(); } }); } </pre>
- **Parameters:**
  - `consumer` (`Throwables.Consumer<? super CallableStatement, SQLException>`) — the consumer to apply to the executed CallableStatement
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the consumer throws an exception
- **See also:** JdbcUtil#getOutParameters(CallableStatement, List), JdbcUtil#streamAllResultSets(Statement, Jdbc.ResultExtractor)
- **Signature:** `@Override public void executeThenAccept(final Throwables.BiConsumer<? super CallableStatement, Boolean, SQLException> consumer) throws SQLException`
- **Summary:** Executes the stored procedure and applies the provided bi-consumer to the executed CallableStatement and a boolean indicating the result type.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code query.executeThenAccept((stmt, isResultSet) -> { if (isResultSet) { ResultSet rs = stmt.getResultSet(); while (rs.next()) { System.out.println(rs.getString(1)); } } else { System.out.println("Updated rows: " + stmt.getUpdateCount()); } }); } </pre>
- **Parameters:**
  - `consumer` (`Throwables.BiConsumer<? super CallableStatement, Boolean, SQLException>`) — the bi-consumer to apply. The first parameter is the executed CallableStatement, the second parameter is {@code true} if the first result is a ResultSet
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the consumer throws an exception
- **See also:** JdbcUtil#getOutParameters(CallableStatement, List)
- **Signature:** `public void executeThenAccept(final Throwables.TriConsumer<? super CallableStatement, List<Jdbc.OutParam>, Boolean, SQLException> consumer) throws SQLException`
- **Summary:** Executes the stored procedure and applies the provided tri-consumer for processing with full access to all execution results.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code query.executeThenAccept((stmt, outParams, isResultSet) -> { // Log OUT parameters for (Jdbc.OutParam param : outParams) { if (param.getParameterName() != null) { logger.info(param.getParameterName() + ": " + stmt.getObject(param.getParameterName())); } } // Process first result if (isResultSet) { ResultSet rs = stmt.getResultSet(); // Write results to file or external system } }); } </pre>
- **Parameters:**
  - `consumer` (`Throwables.TriConsumer<? super CallableStatement, List<Jdbc.OutParam>, Boolean, SQLException>`) — the tri-consumer to apply. Parameters are: 1. The executed CallableStatement 2. List of registered OUT parameters 3. Boolean indicating if the first result is a ResultSet
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the consumer throws an exception
- **See also:** Jdbc.OutParam
##### executeAndGetOutParameters(...) -> Jdbc.OutParamResult
- **Signature:** `public Jdbc.OutParamResult executeAndGetOutParameters() throws IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and retrieves all OUT parameter values.
- **Contract:**
  - This method is used when you only need the OUT parameters and don't need to process any result sets returned by the procedure.
- **Parameters:**
  - (none)
- **Returns:** a {@link Jdbc.OutParamResult} containing all OUT parameter values
- **Throws:**
  - `java.lang.IllegalStateException` — if this CallableQuery is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.OutParamResult
##### queryAndGetOutParameters(...) -> Tuple2<Dataset, Jdbc.OutParamResult>
- **Signature:** `public Tuple2<Dataset, Jdbc.OutParamResult> queryAndGetOutParameters() throws SQLException`
- **Summary:** Executes the stored procedure and returns both the first result set (as a Dataset) and OUT parameters.
- **Parameters:**
  - (none)
- **Returns:** a {@link Tuple2} containing the Dataset (first element) and OUT parameters (second element)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryAndGetOutParameters(Jdbc.ResultExtractor), Dataset
- **Signature:** `public <R> Tuple2<R, Jdbc.OutParamResult> queryAndGetOutParameters(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns both the first result set and OUT parameters, using a custom ResultExtractor to process the result set.
- **Parameters:**
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — the {@link Jdbc.ResultExtractor} to process the result set
- **Returns:** a {@link Tuple2} containing the extracted result (first element) and OUT parameters (second element). The first element may be {@code null} if no result set is returned.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if resultExtractor is null
  - `java.lang.IllegalStateException` — if this CallableQuery is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.ResultExtractor
- **Signature:** `public <R> Tuple2<R, Jdbc.OutParamResult> queryAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns both the first result set and OUT parameters, using a BiResultExtractor that has access to both the ResultSet and column labels.
- **Parameters:**
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — the {@link Jdbc.BiResultExtractor} to process the result set
- **Returns:** a {@link Tuple2} containing the extracted result and OUT parameters
- **Throws:**
  - `java.lang.IllegalArgumentException` — if resultExtractor is null
  - `java.lang.IllegalStateException` — if this CallableQuery is closed
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.BiResultExtractor
##### queryAllResultsetsAndGetOutParameters(...) -> Tuple2<List<Dataset>, Jdbc.OutParamResult>
- **Signature:** `public Tuple2<List<Dataset>, Jdbc.OutParamResult> queryAllResultsetsAndGetOutParameters() throws SQLException`
- **Summary:** Executes the stored procedure and returns all result sets as Datasets along with OUT parameters.
- **Parameters:**
  - (none)
- **Returns:** a {@link Tuple2} containing a list of Datasets (one per result set) and OUT parameters
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #queryAllResultsetsAndGetOutParameters(Jdbc.ResultExtractor)
- **Signature:** `public <R> Tuple2<List<R>, Jdbc.OutParamResult> queryAllResultsetsAndGetOutParameters(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws SQLException`
- **Summary:** Executes the stored procedure and returns all result sets along with OUT parameters, using a custom ResultExtractor to process each result set.
- **Contract:**
  - The extractor should not save or return the ResultSet itself as it will be closed after processing.
- **Parameters:**
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — the {@link Jdbc.ResultExtractor} to process each result set. Must not save or return the ResultSet itself.
- **Returns:** a {@link Tuple2} containing a list of extracted results and OUT parameters
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Jdbc.ResultExtractor
- **Signature:** `public <R> Tuple2<List<R>, Jdbc.OutParamResult> queryAllResultsetsAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws SQLException`
- **Summary:** Executes the stored procedure and returns all result sets along with any OUT parameters.
- **Parameters:**
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — the {@code BiResultExtractor} used to convert each result set to type R. Must not be {@code null} . The extractor receives the ResultSet and column labels. Warning: Do not save or return the ResultSet reference as it will be closed.
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of extracted results (one per result set) </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs, the stored procedure fails, or the result extraction fails
- **See also:** #query2ResultsetsAndGetOutParameters(BiResultExtractor, BiResultExtractor), #listAllResultsetsAndGetOutParameters(Class)
##### query2ResultsetsAndGetOutParameters(...) -> Tuple3<R1, R2, Jdbc.OutParamResult>
- **Signature:** `@Beta public <R1, R2> Tuple3<R1, R2, Jdbc.OutParamResult> query2ResultsetsAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns the first two result sets along with OUT parameters.
- **Contract:**
  - <p> If the stored procedure returns fewer than two result sets, the corresponding result values will be {@code null} .
  - If more than two result sets are returned, only the first two are processed.
- **Parameters:**
  - `resultExtractor1` (`Jdbc.BiResultExtractor<? extends R1>`) — the extractor for the first result set. Must not be {@code null} .
  - `resultExtractor2` (`Jdbc.BiResultExtractor<? extends R2>`) — the extractor for the second result set. Must not be {@code null} .
- **Returns:** A {@code Tuple3} containing: <ul> <li> First element: Extracted result from the first result set (or null) </li> <li> Second element: Extracted result from the second result set (or null) </li> <li> Third element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if either {@code resultExtractor1} or {@code resultExtractor2} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #query3ResultsetsAndGetOutParameters(BiResultExtractor, BiResultExtractor, BiResultExtractor), #queryAllResultsetsAndGetOutParameters(BiResultExtractor)
##### query3ResultsetsAndGetOutParameters(...) -> Tuple4<R1, R2, R3, Jdbc.OutParamResult>
- **Signature:** `@Beta public <R1, R2, R3> Tuple4<R1, R2, R3, Jdbc.OutParamResult> query3ResultsetsAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2, final Jdbc.BiResultExtractor<? extends R3> resultExtractor3) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns the first three result sets along with OUT parameters.
- **Contract:**
  - <p> If the stored procedure returns fewer than three result sets, the corresponding result values will be {@code null} .
  - If more than three result sets are returned, only the first three are processed.
- **Parameters:**
  - `resultExtractor1` (`Jdbc.BiResultExtractor<? extends R1>`) — the extractor for the first result set. Must not be {@code null} .
  - `resultExtractor2` (`Jdbc.BiResultExtractor<? extends R2>`) — the extractor for the second result set. Must not be {@code null} .
  - `resultExtractor3` (`Jdbc.BiResultExtractor<? extends R3>`) — the extractor for the third result set. Must not be {@code null} .
- **Returns:** A {@code Tuple4} containing: <ul> <li> First element: Extracted result from the first result set (or null) </li> <li> Second element: Extracted result from the second result set (or null) </li> <li> Third element: Extracted result from the third result set (or null) </li> <li> Fourth element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any of the result extractors is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #query2ResultsetsAndGetOutParameters(BiResultExtractor, BiResultExtractor), #queryAllResultsetsAndGetOutParameters(BiResultExtractor)
##### listAndGetOutParameters(...) -> Tuple2<List<T>, Jdbc.OutParamResult>
- **Signature:** `public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Class<? extends T> targetType) throws IllegalArgumentException, SQLException`
- **Summary:** Executes the stored procedure and returns the first result set as a list of objects along with any OUT parameters.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class of type T to map each row to. Must not be {@code null} . The class must have a default constructor.
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of mapped objects from the result set </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code targetType} is {@code null}
  - `java.sql.SQLException` — if a database access error occurs, the stored procedure fails, or the mapping fails
- **See also:** #listAndGetOutParameters(RowMapper), #listAndGetOutParameters(BiRowMapper)
- **Signature:** `public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns the first result set as a list of objects along with any OUT parameters.
- **Contract:**
  - <p> The {@code RowMapper} receives the {@code ResultSet} positioned at each row and should extract the data to create an instance of type T.
  - This method is useful when you need custom mapping logic that cannot be achieved with automatic mapping.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} to convert each row to type T. Must not be {@code null} . The mapper is called once per row with the ResultSet positioned at that row.
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of mapped objects from the result set </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowMapper} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs, the stored procedure fails, or the row mapper throws an exception
- **See also:** #listAndGetOutParameters(Class), #listAndGetOutParameters(RowFilter, RowMapper)
- **Signature:** `public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws SQLException`
- **Summary:** Executes the stored procedure and returns a filtered result set as a list along with OUT parameters.
- **Contract:**
  - This method allows you to filter rows before mapping, which can improve performance when you only need a subset of the returned data.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the {@code RowFilter} to test each row. Must not be {@code null} . Only rows where the filter returns {@code true} are mapped.
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} to convert filtered rows to type T. Must not be {@code null} .
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of mapped objects from filtered rows </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAndGetOutParameters(BiRowFilter, BiRowMapper)
- **Signature:** `public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns the first result set as a list along with OUT parameters.
- **Contract:**
  - <p> The column labels list is retrieved once and reused for all rows, making this method efficient when you need column metadata for mapping decisions.
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of mapped objects from the result set </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowMapper} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAndGetOutParameters(RowMapper), #listAndGetOutParameters(BiRowFilter, BiRowMapper)
- **Signature:** `public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws SQLException`
- **Summary:** Executes the stored procedure and returns a filtered result set as a list along with OUT parameters.
- **Contract:**
  - <p> This method is ideal for complex scenarios where both filtering and mapping decisions depend on column metadata or when you need to handle dynamic result set structures.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Filter based on dynamic columns and map accordingly try (CallableQuery query = JdbcUtil.prepareCallableQuery(connection, "{call search_products(?, ?, ?)}")) { query.setString(1, searchTerm) .setInt(2, maxResults) .registerOutParameter(3, Types.INTEGER); // total matches Tuple2<List<Product>, Jdbc.OutParamResult> result = query.listAndGetOutParameters( (rs, labels) -> { // Only include products with a discount if the column exists if (labels.contains("discount_percent")) { return rs.getDouble("discount_percent") > 0; } return true; }, (rs, labels) -> { Product p = new Product(); p.setId(rs.getLong("id")); p.setName(rs.getString("name")); if (labels.contains("discount_percent")) { p.setDiscountPercent(rs.getDouble("discount_percent")); } return p; } ); List<Product> discountedProducts = result._1; int totalMatches = result._2.getOutParamValue(3); } } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the {@code BiRowFilter} that receives ResultSet and column labels. Must not be {@code null} .
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of mapped objects from filtered rows </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAndGetOutParameters(RowFilter, RowMapper)
##### listAllResultsetsAndGetOutParameters(...) -> Tuple2<List<List<T>>, Jdbc.OutParamResult>
- **Signature:** `public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Class<? extends T> targetType) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns all result sets as lists along with OUT parameters.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to map each row to. Must not be {@code null} . Applied to all result sets.
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of lists, one per result set </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code targetType} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAllResultsetsAndGetOutParameters(RowMapper), #queryAllResultsetsAndGetOutParameters(BiResultExtractor)
- **Signature:** `public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns all result sets as lists along with OUT parameters.
- **Contract:**
  - <p> The same {@code RowMapper} is applied to all result sets, so this method is best used when all result sets have the same structure or when the mapper can handle variations.
- **Parameters:**
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} to apply to each row in all result sets. Must not be {@code null} .
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of lists, one per result set </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowMapper} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAllResultsetsAndGetOutParameters(Class), #listAllResultsetsAndGetOutParameters(RowFilter, RowMapper)
- **Signature:** `public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns all filtered result sets as lists along with OUT parameters.
- **Contract:**
  - Rows that don't pass the filter are skipped entirely, which can significantly improve performance when processing large result sets.
- **Parameters:**
  - `rowFilter` (`Jdbc.RowFilter`) — the {@code RowFilter} to apply to each row in all result sets. Must not be {@code null} .
  - `rowMapper` (`Jdbc.RowMapper<? extends T>`) — the {@code RowMapper} to apply to filtered rows. Must not be {@code null} .
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of lists of filtered and mapped objects </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowFilter} or {@code rowMapper} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAllResultsetsAndGetOutParameters(BiRowFilter, BiRowMapper)
- **Signature:** `public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns all result sets as lists along with OUT parameters.
- **Contract:**
  - <p> This method is particularly useful when different result sets have different structures but can be mapped to the same target type, or when mapping logic depends on column metadata.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Handle result sets with varying columns try (CallableQuery query = JdbcUtil.prepareCallableQuery(connection, "{call get_hierarchical_data(?)}")) { query.setString(1, rootId); Tuple2<List<List<Node>>, Jdbc.OutParamResult> result = query.listAllResultsetsAndGetOutParameters((rs, labels) -> { Node node = new Node(); node.setId(rs.getString("id")); node.setName(rs.getString("name")); // Different result sets may have different attributes if (labels.contains("parent_id")) { node.setParentId(rs.getString("parent_id")); } if (labels.contains("level")) { node.setLevel(rs.getInt("level")); } if (labels.contains("children_count")) { node.setChildrenCount(rs.getInt("children_count")); } return node; }); List<Node> rootNodes = result._1.get(0); List<Node> childNodes = result._1.get(1); List<Node> leafNodes = result._1.get(2); } } </pre>
- **Parameters:**
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of lists, one per result set </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowMapper} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAllResultsetsAndGetOutParameters(RowMapper)
- **Signature:** `public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException`
- **Summary:** Executes the stored procedure and returns all filtered result sets as lists along with OUT parameters.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Complex filtering and mapping across heterogeneous result sets try (CallableQuery query = JdbcUtil.prepareCallableQuery(connection, "{call analyze_customer_360(?)}")) { query.setLong(1, customerId); Tuple2<List<List<CustomerData>>, Jdbc.OutParamResult> result = query.listAllResultsetsAndGetOutParameters( (rs, labels) -> { // Filter based on available columns if (labels.contains("is_active")) { return rs.getBoolean("is_active"); } else if (labels.contains("status")) { return "ACTIVE".equals(rs.getString("status")); } return true; // Include all rows if no status column }, (rs, labels) -> { CustomerData data = new CustomerData(); data.setType(determineTypeFromColumns(labels)); // Map common fields if (labels.contains("id")) data.setId(rs.getLong("id")); if (labels.contains("value")) data.setValue(rs.getBigDecimal("value")); // Map type-specific fields if (labels.contains("order_date")) { data.setDate(rs.getTimestamp("order_date")); data.setDescription(rs.getString("product_name")); } else if (labels.contains("interaction_date")) { data.setDate(rs.getTimestamp("interaction_date")); data.setDescription(rs.getString("interaction_type")); } return data; } ); List<CustomerData> orders = result._1.get(0); List<CustomerData> interactions = result._1.get(1); List<CustomerData> preferences = result._1.get(2); } } </pre>
- **Parameters:**
  - `rowFilter` (`Jdbc.BiRowFilter`) — the {@code BiRowFilter} that receives ResultSet and column labels. Must not be {@code null} .
  - `rowMapper` (`Jdbc.BiRowMapper<? extends T>`) — the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .
- **Returns:** A {@code Tuple2} containing: <ul> <li> First element: List of lists of filtered and mapped objects </li> <li> Second element: {@code Jdbc.OutParamResult} containing all OUT parameters </li> </ul>
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code rowFilter} or {@code rowMapper} is {@code null}
  - `java.lang.IllegalStateException` — if this query has already been closed
  - `java.sql.SQLException` — if a database access error occurs or the stored procedure fails
- **See also:** #listAllResultsetsAndGetOutParameters(RowFilter, RowMapper)

### Class DBLock (com.landawn.abacus.jdbc.DBLock)
Provides a robust distributed locking mechanism leveraging a dedicated database table.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### lock(...) -> String
- **Signature:** `public String lock(final String target)`
- **Summary:** Attempts to acquire a distributed lock on the specified target resource using default settings.
- **Contract:**
  - <p> If the lock is successfully acquired, a unique lock code is returned, which must be used to release the lock later.
  - If the lock cannot be acquired within the timeout, {@code null} is returned.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, "my_locks_table"); String resourceIdentifier = "report_generation_task"; String lockCode = dbLock.lock(resourceIdentifier); if (lockCode != null) { try { System.out.println("Lock acquired for: " + resourceIdentifier); // Perform the critical operation that requires exclusive access // ...
  - } catch (InterruptedException e) { Thread.currentThread().interrupt(); System.err.println("Operation interrupted: " + e.getMessage()); } finally { // Ensure the lock is released, even if an error occurs dbLock.unlock(resourceIdentifier, lockCode); System.out.println("Lock released for: " + resourceIdentifier); } } else { System.out.println("Failed to acquire lock for: " + resourceIdentifier + " within default timeout."); } } </pre>
- **Parameters:**
  - `target` (`String`) — the unique identifier of the resource to lock. Must not be {@code null} or empty.
- **Returns:** a unique {@code String} code representing the acquired lock, or {@code null} if the lock could not be acquired within the default timeout.
- **See also:** #lock(String, long, long), #DEFAULT_LOCK_LIVE_TIME, #DEFAULT_TIMEOUT
- **Signature:** `public String lock(final String target, final long timeout)`
- **Summary:** Attempts to acquire a distributed lock on the specified target resource with a custom timeout.
- **Contract:**
  - If successful, a unique lock code is returned; otherwise, {@code null} is returned.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, "my_locks_table"); String resourceIdentifier = "data_export_job"; long customTimeout = 15 * 1000; // Wait up to 15 seconds String lockCode = dbLock.lock(resourceIdentifier, customTimeout); if (lockCode != null) { try { System.out.println("Lock acquired for: " + resourceIdentifier); // Execute the data export logic // ...
- **Parameters:**
  - `target` (`String`) — the unique identifier of the resource to lock. Must not be {@code null} or empty.
  - `timeout` (`long`) — the maximum time in milliseconds to wait for the lock. Must be non-negative.
- **Returns:** a unique {@code String} code representing the acquired lock, or {@code null} if the lock could not be acquired within the specified timeout.
- **See also:** #lock(String, long, long, long), #DEFAULT_LOCK_LIVE_TIME
- **Signature:** `public String lock(final String target, final long liveTime, final long timeout)`
- **Summary:** Attempts to acquire a distributed lock on the specified target resource with custom lock duration (live time) and acquisition timeout.
- **Contract:**
  - <p> The acquired lock will automatically expire after {@code liveTime} milliseconds if not refreshed.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, "my_locks_table"); String resourceIdentifier = "batch_processing_queue"; long lockDuration = 10 * 60 * 1000; // Lock for 10 minutes long waitTimeout = 30 * 1000; // Wait up to 30 seconds to acquire String lockCode = dbLock.lock(resourceIdentifier, lockDuration, waitTimeout); if (lockCode != null) { try { System.out.println("Lock acquired for: " + resourceIdentifier); // Execute the batch processing logic // ...
- **Parameters:**
  - `target` (`String`) — the unique identifier of the resource to lock. Must not be {@code null} or empty.
  - `liveTime` (`long`) — the duration in milliseconds for which the lock is valid. Must be positive.
  - `timeout` (`long`) — the maximum time in milliseconds to wait for the lock. Must be non-negative.
- **Returns:** a unique {@code String} code representing the acquired lock, or {@code null} if the lock could not be acquired within the specified timeout.
- **See also:** #lock(String, long, long, long)
- **Signature:** `public String lock(final String target, final long liveTime, final long timeout, final long retryInterval) throws IllegalStateException`
- **Summary:** Attempts to acquire a distributed lock on the specified target resource with full control over lock duration, acquisition timeout, and retry behavior.
- **Contract:**
  - If the initial attempt fails (meaning another process holds the lock), it will repeatedly retry after {@code retryInterval} milliseconds until the total {@code timeout} is reached.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, "my_locks_table"); String resourceIdentifier = "inventory_update_process"; long lockDuration = 5 * 60 * 1000; // Lock for 5 minutes long acquisitionTimeout = 10 * 1000; // Wait up to 10 seconds long retryInterval = 500; // Retry every 500 milliseconds String lockCode = dbLock.lock(resourceIdentifier, lockDuration, acquisitionTimeout, retryInterval); if (lockCode != null) { try { System.out.println("Lock acquired for: " + resourceIdentifier); // Perform the inventory update // ...
- **Parameters:**
  - `target` (`String`) — the unique identifier of the resource to lock. Must not be {@code null} or empty.
  - `liveTime` (`long`) — the duration in milliseconds for which the lock is valid. Must be positive.
  - `timeout` (`long`) — the maximum time in milliseconds to wait for the lock. Must be non-negative.
  - `retryInterval` (`long`) — the time in milliseconds to wait between retry attempts. A value of 0 means immediate retry without delay. Must be non-negative.
- **Returns:** a unique {@code String} code representing the acquired lock, or {@code null} if the lock could not be acquired within the specified timeout.
- **Throws:**
  - `java.lang.IllegalStateException` — if this {@code DBLock} instance has been closed.
##### unlock(...) -> boolean
- **Signature:** `public boolean unlock(final String target, final String code) throws IllegalStateException`
- **Summary:** Releases the distributed lock on the specified target resource.
- **Contract:**
  - The lock is released only if the provided {@code code} matches the unique code associated with the currently held lock for that target.
  - <p> If the lock is successfully released, the corresponding entry is removed from the database table.
  - If the lock does not exist, or if the provided code does not match the stored code, the operation will fail (return {@code false} ).
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, "my_locks_table"); String resourceIdentifier = "configuration_update"; String lockCode = dbLock.lock(resourceIdentifier, 30000, 5000); // Acquire lock for 30s, wait 5s if (lockCode != null) { try { System.out.println("Lock acquired for: " + resourceIdentifier); // Perform configuration update // ...
  - } finally { boolean released = dbLock.unlock(resourceIdentifier, lockCode); if (released) { System.out.println("Lock successfully released for: " + resourceIdentifier); } else { System.err.println("Failed to release lock for: " + resourceIdentifier + ".
- **Parameters:**
  - `target` (`String`) — the unique identifier of the resource whose lock is to be released. Must not be {@code null} or empty.
  - `code` (`String`) — the unique code obtained during lock acquisition. Must not be {@code null} .
- **Returns:** {@code true} if the lock was successfully released; {@code false} otherwise (e.g., lock not found, code mismatch).
- **Throws:**
  - `java.lang.IllegalStateException` — if this {@code DBLock} instance has been closed.
##### close(...) -> void
- **Signature:** `public void close()`
- **Summary:** Closes this {@code DBLock} instance, releasing all associated resources.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, "my_locks_table"); try { // Perform operations using the DBLock instance String lockCode = dbLock.lock("some_resource"); if (lockCode != null) { try { // ...
- **Parameters:**
  - (none)

### Record DBProductInfo (com.landawn.abacus.jdbc.DBProductInfo)
A record that encapsulates database product information including the product name, version string, and parsed version enum.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `record DBProductInfo(String productName, String productVersion, DBVersion version) { // NOSONAR }`
- **Parameters:**
  - `productName` (`String`)
  - `productVersion` (`String`)
  - `version` (`DBVersion`)

### Enum DBVersion (com.landawn.abacus.jdbc.DBVersion)
Enumeration representing various database products and their major versions.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### isMySQL(...) -> boolean
- **Signature:** `public boolean isMySQL()`
- **Summary:** Checks if this {@code DBVersion} enum constant represents any variant of MySQL.
- **Contract:**
  - Checks if this {@code DBVersion} enum constant represents any variant of MySQL.
  - <p> The check is performed by verifying if the enum constant's name starts with "MySQL" (case-insensitive).
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(connection); DBVersion currentDbVersion = dbInfo.version(); if (currentDbVersion.isMySQL()) { System.out.println("Connected to a MySQL database."); // Apply MySQL-specific SQL or optimizations } else { System.out.println("Not a MySQL database."); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if this {@code DBVersion} is a MySQL variant, {@code false} otherwise.
##### isPostgreSQL(...) -> boolean
- **Signature:** `public boolean isPostgreSQL()`
- **Summary:** Checks if this {@code DBVersion} enum constant represents any variant of PostgreSQL.
- **Contract:**
  - Checks if this {@code DBVersion} enum constant represents any variant of PostgreSQL.
  - <p> The check is performed by verifying if the enum constant's name starts with "PostgreSQL" (case-insensitive).
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(connection); DBVersion currentDbVersion = dbInfo.version(); if (currentDbVersion.isPostgreSQL()) { System.out.println("Connected to a PostgreSQL database."); // Apply PostgreSQL-specific SQL or features like JSONB } else { System.out.println("Not a PostgreSQL database."); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if this {@code DBVersion} is a PostgreSQL variant, {@code false} otherwise.

### Class EmptyHandler (com.landawn.abacus.jdbc.EmptyHandler)
A no-operation implementation of {@link Jdbc.Handler} for DAO instances.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public EmptyHandler()`
- **Summary:** Constructs a new EmptyHandler instance.
- **Contract:**
  - <p> This no-operation handler is used internally by the framework as a placeholder when no actual handling logic is required.
- **Parameters:**
  - (none)

### Enum FetchDirection (com.landawn.abacus.jdbc.FetchDirection)
Enumeration representing the direction in which rows of a {@link ResultSet} will be processed.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### valueOf(...) -> FetchDirection
- **Signature:** `public static FetchDirection valueOf(final int intValue)`
- **Summary:** Returns the {@code FetchDirection} enum constant that corresponds to the given JDBC integer constant value.
- **Parameters:**
  - `intValue` (`int`) — the JDBC integer constant representing a fetch direction (e.g., {@link ResultSet#FETCH_FORWARD} , {@link ResultSet#FETCH_REVERSE} , {@link ResultSet#FETCH_UNKNOWN} ).
- **Returns:** the corresponding {@code FetchDirection} enum constant.

#### Public Instance Methods
##### intValue(...) -> int
- **Signature:** `public int intValue()`
- **Summary:** Returns the raw JDBC integer constant value associated with this {@code FetchDirection} .
- **Parameters:**
  - (none)
- **Returns:** the JDBC integer constant value (e.g., {@link ResultSet#FETCH_FORWARD} ).

### Enum IsolationLevel (com.landawn.abacus.jdbc.IsolationLevel)
Enumeration representing the standard transaction isolation levels defined by JDBC.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### valueOf(...) -> IsolationLevel
- **Signature:** `public static IsolationLevel valueOf(final int intValue)`
- **Summary:** Returns the {@code IsolationLevel} enum constant that corresponds to the given JDBC integer constant value.
- **Parameters:**
  - `intValue` (`int`) — the JDBC integer constant representing a transaction isolation level (e.g., {@link Connection#TRANSACTION_READ_COMMITTED} ).
- **Returns:** the corresponding {@code IsolationLevel} enum constant.

#### Public Instance Methods
##### intValue(...) -> int
- **Signature:** `public int intValue()`
- **Summary:** Returns the raw JDBC integer constant value associated with this {@code IsolationLevel} .
- **Parameters:**
  - (none)
- **Returns:** the JDBC integer constant value (e.g., {@link Connection#TRANSACTION_READ_COMMITTED} ).

### Class Jdbc (com.landawn.abacus.jdbc.Jdbc)
Provides a collection of utility interfaces and classes for simplifying JDBC operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Interface ParametersSetter (com.landawn.abacus.jdbc.Jdbc.ParametersSetter)
A functional interface for setting parameters on a prepared query statement.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### accept(...) -> void
- **Signature:** `@Override void accept(QS preparedQuery) throws SQLException`
- **Summary:** Sets the parameters on the given prepared query statement.
- **Parameters:**
  - `preparedQuery` (`QS`) — the prepared query statement (e.g., {@code PreparedStatement} ) to set parameters on.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or if the statement is closed.

### Interface BiParametersSetter (com.landawn.abacus.jdbc.Jdbc.BiParametersSetter)
A functional interface for setting parameters on a prepared query using a parameter object.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### createForArray(...) -> BiParametersSetter<PreparedStatement, T\[\]>
- **Signature:** `@Beta @SequentialOnly @Stateful static <T> BiParametersSetter<PreparedStatement, T[]> createForArray(final List<String> fieldNameList, final Class<?> entityClass)`
- **Summary:** Creates a stateful {@code BiParametersSetter} for setting parameters from an array.
- **Contract:**
  - It should not be cached, shared, or used in parallel streams.
  - A new instance should be created for each use.
- **Parameters:**
  - `fieldNameList` (`List<String>`) — the list of property names from the {@code entityClass} . The order must match the order of values in the input array and the '?' placeholders in the SQL statement.
  - `entityClass` (`Class<?>`) — the entity class used to infer the data type for each parameter.
- **Returns:** a stateful {@code BiParametersSetter} . Do not cache, reuse, or use it in parallel streams.
##### createForList(...) -> BiParametersSetter<PreparedStatement, List<T>>
- **Signature:** `@Beta @SequentialOnly @Stateful static <T> BiParametersSetter<PreparedStatement, List<T>> createForList(final List<String> fieldNameList, final Class<?> entityClass)`
- **Summary:** Creates a stateful {@code BiParametersSetter} for setting parameters from a {@code List} .
- **Contract:**
  - It should not be cached, shared, or used in parallel streams.
  - A new instance should be created for each use.
- **Parameters:**
  - `fieldNameList` (`List<String>`) — the list of property names from the {@code entityClass} . The order must match the order of values in the input list and the '?' placeholders in the SQL statement.
  - `entityClass` (`Class<?>`) — the entity class used to infer the data type for each parameter.
- **Returns:** a stateful {@code BiParametersSetter} . Do not cache, reuse, or use it in parallel streams.

#### Public Instance Methods
##### accept(...) -> void
- **Signature:** `@Override void accept(QS preparedQuery, T param) throws SQLException`
- **Summary:** Sets the parameters on the given prepared query using the provided parameter object.
- **Parameters:**
  - `preparedQuery` (`QS`) — the prepared query to set parameters on
  - `param` (`T`) — the parameter object containing values to set
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed {@code PreparedStatement}

### Interface TriParametersSetter (com.landawn.abacus.jdbc.Jdbc.TriParametersSetter)
A functional interface for setting parameters on a prepared query, providing access to the parsed SQL structure.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### accept(...) -> void
- **Signature:** `@Override void accept(ParsedSql parsedSql, QS preparedQuery, T param) throws SQLException`
- **Summary:** Sets parameters on the given prepared query using parsed SQL information and a parameter object.
- **Parameters:**
  - `parsedSql` (`ParsedSql`) — the parsed SQL containing information about the query and its parameters
  - `preparedQuery` (`QS`) — the prepared query to set parameters on
  - `param` (`T`) — the parameter object containing values to set
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed {@code PreparedStatement}

### Interface ResultExtractor (com.landawn.abacus.jdbc.Jdbc.ResultExtractor)
A functional interface for extracting a result from a {@code ResultSet} .

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### toMap(...) -> ResultExtractor<Map<K, V>>
- **Signature:** `static <K, V> ResultExtractor<Map<K, V>> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor)`
- **Summary:** Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a {@code Map} .
- **Contract:**
  - If duplicate keys are encountered, an {@code IllegalStateException} will be thrown.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
- **Returns:** a {@code ResultExtractor} that produces a {@code Map}
- **See also:** #toMap(RowMapper, RowMapper, BinaryOperator)
- **Signature:** `static <K, V, M extends Map<K, V>> ResultExtractor<M> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} .
- **Contract:**
  - If duplicate keys are encountered, an {@code IllegalStateException} will be thrown.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code ResultExtractor} that produces a custom {@code Map}
- **Signature:** `static <K, V> ResultExtractor<Map<K, V>> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction)`
- **Summary:** Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a {@code Map} , with a specified function to merge values of duplicate keys.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
  - `mergeFunction` (`BinaryOperator<V>`) — a function to resolve collisions between values associated with the same key
- **Returns:** a {@code ResultExtractor} that produces a {@code Map}
- **See also:** Fn#throwingMerger(), Fn#replacingMerger(), Fn#ignoringMerger()
- **Signature:** `static <K, V, M extends Map<K, V>> ResultExtractor<M> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} , with a specified function to merge values of duplicate keys.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
  - `mergeFunction` (`BinaryOperator<V>`) — a function to resolve collisions between values associated with the same key
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code ResultExtractor} that produces a custom {@code Map}
- **See also:** Fn#throwingMerger(), Fn#replacingMerger(), Fn#ignoringMerger()
- **Signature:** `@Deprecated static <K, V, D> ResultExtractor<Map<K, D>> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row, which is then fed into the collector
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} to process values associated with each key
- **Returns:** a {@code ResultExtractor} that produces a {@code Map}
- **See also:** #groupTo(RowMapper, RowMapper, Collector)
- **Signature:** `@Deprecated static <K, V, D, M extends Map<K, D>> ResultExtractor<M> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row, which is then fed into the collector
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} to process values associated with each key
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code ResultExtractor} that produces a custom {@code Map}
- **See also:** #groupTo(RowMapper, RowMapper, Collector, Supplier)
##### toMultimap(...) -> ResultExtractor<ListMultimap<K, V>>
- **Signature:** `static <K, V> ResultExtractor<ListMultimap<K, V>> toMultimap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a {@code ListMultimap} , where each key can be associated with multiple values.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
- **Returns:** a {@code ResultExtractor} that produces a {@code ListMultimap}
- **Signature:** `static <K, V, C extends Collection<V>, M extends Multimap<K, V, C>> ResultExtractor<M> toMultimap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Supplier<? extends M> multimapSupplier)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a custom {@code Multimap} .
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
  - `multimapSupplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Multimap} instance
- **Returns:** a {@code ResultExtractor} that produces a custom {@code Multimap}
##### groupTo(...) -> ResultExtractor<Map<K, List<V>>>
- **Signature:** `static <K, V> ResultExtractor<Map<K, List<V>>> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a {@code Map} where each key is associated with a {@code List} of values.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
- **Returns:** a {@code ResultExtractor} that produces a {@code Map} with {@code List} values
- **Signature:** `static <K, V, M extends Map<K, List<V>>> ResultExtractor<M> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a custom {@code Map} where each key is associated with a {@code List} of values.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code ResultExtractor} that produces a custom {@code Map} with {@code List} values
- **Signature:** `static <K, V, D> ResultExtractor<Map<K, D>> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} for aggregating values associated with each key
- **Returns:** a {@code ResultExtractor} that produces a {@code Map} with collected values
- **Signature:** `static <K, V, D, M extends Map<K, D>> ResultExtractor<M> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code ResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`RowMapper<? extends K>`) — a {@code RowMapper} to extract the key from each row
  - `valueExtractor` (`RowMapper<? extends V>`) — a {@code RowMapper} to extract the value from each row
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} for aggregating values associated with each key
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code ResultExtractor} that produces a custom {@code Map} with collected values
##### toList(...) -> ResultExtractor<List<T>>
- **Signature:** `static <T> ResultExtractor<List<T>> toList(final RowMapper<? extends T> rowMapper)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, where each object is created by applying the given {@code rowMapper} to each row.
- **Parameters:**
  - `rowMapper` (`RowMapper<? extends T>`) — the function to map each row to an element
- **Returns:** a {@code ResultExtractor} that produces a {@code List}
- **Signature:** `static <T> ResultExtractor<List<T>> toList(final RowFilter rowFilter, final RowMapper<? extends T> rowMapper)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, including only the rows that satisfy the {@code rowFilter} .
- **Parameters:**
  - `rowFilter` (`RowFilter`) — a predicate to filter rows from the result set
  - `rowMapper` (`RowMapper<? extends T>`) — the function to map each accepted row to an element
- **Returns:** a {@code ResultExtractor} that produces a filtered {@code List}
- **Signature:** `static <T> ResultExtractor<List<T>> toList(final Class<? extends T> targetClass)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of entities.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class of the entities to be created
- **Returns:** a {@code ResultExtractor} that produces a {@code List} of entities
- **See also:** BiResultExtractor#toList(Class)
##### toMergedList(...) -> ResultExtractor<List<T>>
- **Signature:** `static <T> ResultExtractor<List<T>> toMergedList(final Class<? extends T> targetClass)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} from a JOIN query into a {@code List} of merged entities.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class of the entities to create and merge
- **Returns:** a {@code ResultExtractor} that produces a {@code List} of merged entities
- **See also:** Dataset#toMergedEntities(Class)
- **Signature:** `static <T> ResultExtractor<List<T>> toMergedList(final Class<? extends T> targetClass, final String idPropNameForMerge)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of merged entities, using a specific property to identify unique entities for merging.
- **Contract:**
  - This is useful when the default ID detection is not sufficient.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class of the entities to create and merge
  - `idPropNameForMerge` (`String`) — the property name to use for identifying unique entities to merge
- **Returns:** a {@code ResultExtractor} that produces a {@code List} of merged entities
- **See also:** Dataset#toMergedEntities(Collection, Collection, Class)
- **Signature:** `static <T> ResultExtractor<List<T>> toMergedList(final Class<? extends T> targetClass, final Collection<String> idPropNamesForMerge)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of merged entities, using a composite key (multiple properties) to identify unique entities for merging.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class of the entities to create and merge
  - `idPropNamesForMerge` (`Collection<String>`) — the collection of property names that form the composite key for merging
- **Returns:** a {@code ResultExtractor} that produces a {@code List} of merged entities
- **See also:** Dataset#toMergedEntities(Collection, Collection, Class)
##### toDataset(...) -> ResultExtractor<Dataset>
- **Signature:** `static ResultExtractor<Dataset> toDataset(final Class<?> entityClassForExtractor)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} .
- **Parameters:**
  - `entityClassForExtractor` (`Class<?>`) — the class used to map column names to property types
- **Returns:** a {@code ResultExtractor} that produces a {@code Dataset}
- **Signature:** `static ResultExtractor<Dataset> toDataset(final Class<?> entityClassForExtractor, final Map<String, String> prefixAndFieldNameMap)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} with custom field name mapping for nested objects.
- **Parameters:**
  - `entityClassForExtractor` (`Class<?>`) — the class used to map fields from columns
  - `prefixAndFieldNameMap` (`Map<String, String>`) — a map where keys are column prefixes and values are field name prefixes for dot notation
- **Returns:** a {@code ResultExtractor} that produces a {@code Dataset}
- **Signature:** `static ResultExtractor<Dataset> toDataset(final RowFilter rowFilter)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} , including only the rows that satisfy the specified filter.
- **Parameters:**
  - `rowFilter` (`RowFilter`) — a predicate to filter rows
- **Returns:** a {@code ResultExtractor} that produces a filtered {@code Dataset}
- **Signature:** `static ResultExtractor<Dataset> toDataset(final RowExtractor rowExtractor)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} using a custom {@code RowExtractor} for fine-grained control over value extraction.
- **Parameters:**
  - `rowExtractor` (`RowExtractor`) — the custom row extractor to process each row
- **Returns:** a {@code ResultExtractor} that produces a {@code Dataset}
- **Signature:** `static ResultExtractor<Dataset> toDataset(final RowFilter rowFilter, final RowExtractor rowExtractor)`
- **Summary:** Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} using both a filter and a custom row extractor.
- **Parameters:**
  - `rowFilter` (`RowFilter`) — a predicate to filter rows
  - `rowExtractor` (`RowExtractor`) — the custom row extractor to process each accepted row
- **Returns:** a {@code ResultExtractor} that produces a filtered {@code Dataset}
##### to(...) -> ResultExtractor<R>
- **Signature:** `static <R> ResultExtractor<R> to(final Throwables.Function<Dataset, R, SQLException> after)`
- **Summary:** Creates a {@code ResultExtractor} that first converts the {@code ResultSet} to a {@code Dataset} and then applies a transformation function to it.
- **Parameters:**
  - `after` (`Throwables.Function<Dataset, R, SQLException>`) — the function to apply to the intermediate {@code Dataset}
- **Returns:** a {@code ResultExtractor} that produces the transformed result

#### Public Instance Methods
##### apply(...) -> T
- **Signature:** `@Override T apply(ResultSet rs) throws SQLException`
- **Summary:** Extracts a result from the given {@code ResultSet} .
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} to extract data from; may be {@code null} .
- **Returns:** the extracted result.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs.
##### andThen(...) -> ResultExtractor<R>
- **Signature:** `default <R> ResultExtractor<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)`
- **Summary:** Returns a composed {@code ResultExtractor} that first applies this extractor to the {@code ResultSet} and then applies the {@code after} function to the result.
- **Parameters:**
  - `after` (`Throwables.Function<? super T, ? extends R, SQLException>`) — the function to apply after this extractor is applied
- **Returns:** a composed {@code ResultExtractor}
##### toBiResultExtractor(...) -> BiResultExtractor<T>
- **Signature:** `default BiResultExtractor<T> toBiResultExtractor()`
- **Summary:** Converts this {@code ResultExtractor} to a {@code BiResultExtractor} .
- **Parameters:**
  - (none)
- **Returns:** a {@code BiResultExtractor} that delegates to this extractor.

### Interface BiResultExtractor (com.landawn.abacus.jdbc.Jdbc.BiResultExtractor)
A functional interface for extracting a result from a {@code ResultSet} , with access to the list of column labels from the result set's metadata.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### toMap(...) -> BiResultExtractor<Map<K, V>>
- **Signature:** `static <K, V> BiResultExtractor<Map<K, V>> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor)`
- **Summary:** Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a {@code Map} .
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
- **Returns:** a {@code BiResultExtractor} that produces a {@code Map}
- **Signature:** `static <K, V, M extends Map<K, V>> BiResultExtractor<M> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} .
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code BiResultExtractor} that produces a custom {@code Map}
- **Signature:** `static <K, V> BiResultExtractor<Map<K, V>> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction)`
- **Summary:** Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a {@code Map} , with a specified function to merge values of duplicate keys.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `mergeFunction` (`BinaryOperator<V>`) — a function to resolve collisions for the same key
- **Returns:** a {@code BiResultExtractor} that produces a {@code Map}
- **See also:** Fn#throwingMerger(), Fn#replacingMerger(), Fn#ignoringMerger()
- **Signature:** `static <K, V, M extends Map<K, V>> BiResultExtractor<M> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} , with a specified function to merge values of duplicate keys.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `mergeFunction` (`BinaryOperator<V>`) — a function to resolve collisions for the same key
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code BiResultExtractor} that produces a custom {@code Map}
- **See also:** Fn#throwingMerger(), Fn#replacingMerger(), Fn#ignoringMerger()
- **Signature:** `@Deprecated static <K, V, D> BiResultExtractor<Map<K, D>> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} to process values for each key
- **Returns:** a {@code BiResultExtractor} that produces a {@code Map}
- **See also:** #groupTo(BiRowMapper, BiRowMapper, Collector)
- **Signature:** `@Deprecated static <K, V, D, M extends Map<K, D>> BiResultExtractor<M> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} to process values for each key
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code BiResultExtractor} that produces a custom {@code Map}
- **See also:** #groupTo(BiRowMapper, BiRowMapper, Collector, Supplier)
##### toMultimap(...) -> BiResultExtractor<ListMultimap<K, V>>
- **Signature:** `static <K, V> BiResultExtractor<ListMultimap<K, V>> toMultimap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a {@code ListMultimap} , where each key can be associated with multiple values.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
- **Returns:** a {@code BiResultExtractor} that produces a {@code ListMultimap}
- **Signature:** `static <K, V, C extends Collection<V>, M extends Multimap<K, V, C>> BiResultExtractor<M> toMultimap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Supplier<? extends M> multimapSupplier)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a custom {@code Multimap} .
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `multimapSupplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Multimap} instance
- **Returns:** a {@code BiResultExtractor} that produces a custom {@code Multimap}
##### groupTo(...) -> BiResultExtractor<Map<K, List<V>>>
- **Signature:** `static <K, V> BiResultExtractor<Map<K, List<V>>> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a {@code Map} where each key is associated with a {@code List} of values.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
- **Returns:** a {@code BiResultExtractor} that produces a {@code Map} with {@code List} values
- **Signature:** `static <K, V, M extends Map<K, List<V>>> BiResultExtractor<M> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a custom {@code Map} where each key is associated with a {@code List} of values.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code BiResultExtractor} that produces a custom {@code Map} with {@code List} values
- **Signature:** `static <K, V, D> BiResultExtractor<Map<K, D>> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} for aggregating values associated with each key
- **Returns:** a {@code BiResultExtractor} that produces a {@code Map} with collected values
- **Signature:** `static <K, V, D, M extends Map<K, D>> BiResultExtractor<M> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)`
- **Summary:** Creates a {@code BiResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.
- **Parameters:**
  - `keyExtractor` (`BiRowMapper<? extends K>`) — a {@code BiRowMapper} to extract the key from each row
  - `valueExtractor` (`BiRowMapper<? extends V>`) — a {@code BiRowMapper} to extract the value from each row
  - `downstream` (`Collector<? super V, ?, D>`) — the {@code Collector} for aggregating values associated with each key
  - `supplier` (`Supplier<? extends M>`) — a {@code Supplier} that provides a new, empty {@code Map} instance
- **Returns:** a {@code BiResultExtractor} that produces a custom {@code Map} with collected values
##### toList(...) -> BiResultExtractor<List<T>>
- **Signature:** `static <T> BiResultExtractor<List<T>> toList(final BiRowMapper<? extends T> rowMapper)`
- **Summary:** Creates a {@code BiResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, where each object is created by applying the given {@code rowMapper} to each row.
- **Parameters:**
  - `rowMapper` (`BiRowMapper<? extends T>`) — the function to map each row to an element
- **Returns:** a {@code BiResultExtractor} that produces a {@code List}
- **Signature:** `static <T> BiResultExtractor<List<T>> toList(final BiRowFilter rowFilter, final BiRowMapper<? extends T> rowMapper)`
- **Summary:** Creates a {@code BiResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, including only the rows that satisfy the {@code rowFilter} .
- **Parameters:**
  - `rowFilter` (`BiRowFilter`) — a predicate to filter rows
  - `rowMapper` (`BiRowMapper<? extends T>`) — the function to map each accepted row to an element
- **Returns:** a {@code BiResultExtractor} that produces a filtered {@code List}
- **Signature:** `static <T> BiResultExtractor<List<T>> toList(final Class<? extends T> targetClass)`
- **Summary:** Creates a {@code BiResultExtractor} that converts a {@code ResultSet} into a {@code List} of entities.
- **Contract:**
  - While the returned {@code BiResultExtractor} itself is stateless, for performance-critical scenarios, consider creating the stateful {@code BiRowMapper} once and reusing it if the result set structure is consistent.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class of the entities to be created
- **Returns:** a {@code BiResultExtractor} that produces a {@code List} of entities.
- **See also:** ResultExtractor#toList(Class), BiRowMapper#to(Class)

#### Public Instance Methods
##### apply(...) -> T
- **Signature:** `@Override T apply(ResultSet rs, List<String> columnLabels) throws SQLException`
- **Summary:** Extracts a result from the given {@code ResultSet} using column label information.
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} to extract data from
  - `columnLabels` (`List<String>`) — the list of column labels from the result set's metadata
- **Returns:** the extracted result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### andThen(...) -> BiResultExtractor<R>
- **Signature:** `default <R> BiResultExtractor<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)`
- **Summary:** Returns a composed {@code BiResultExtractor} that first applies this extractor to the {@code ResultSet} and then applies the {@code after} function to the result.
- **Parameters:**
  - `after` (`Throwables.Function<? super T, ? extends R, SQLException>`) — the function to apply after this extractor is applied
- **Returns:** a composed {@code BiResultExtractor}

### Interface RowMapper (com.landawn.abacus.jdbc.Jdbc.RowMapper)
A functional interface for mapping the current row of a {@code ResultSet} to an object.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### combine(...) -> RowMapper<Tuple2<T, U>>
- **Signature:** `static <T, U> RowMapper<Tuple2<T, U>> combine(final RowMapper<? extends T> rowMapper1, final RowMapper<? extends U> rowMapper2)`
- **Summary:** Combines two {@code RowMapper} instances into a single mapper that returns a {@code Tuple2} containing the results of both.
- **Parameters:**
  - `rowMapper1` (`RowMapper<? extends T>`) — the first mapper; must not be null
  - `rowMapper2` (`RowMapper<? extends U>`) — the second mapper; must not be null
- **Returns:** a new {@code RowMapper} that produces a {@code Tuple2}
- **Signature:** `static <A, B, C> RowMapper<Tuple3<A, B, C>> combine(final RowMapper<? extends A> rowMapper1, final RowMapper<? extends B> rowMapper2, final RowMapper<? extends C> rowMapper3)`
- **Summary:** Combines three {@code RowMapper} instances into a single mapper that returns a {@code Tuple3} containing the results of all three.
- **Parameters:**
  - `rowMapper1` (`RowMapper<? extends A>`) — the first mapper; must not be null
  - `rowMapper2` (`RowMapper<? extends B>`) — the second mapper; must not be null
  - `rowMapper3` (`RowMapper<? extends C>`) — the third mapper; must not be null
- **Returns:** a new {@code RowMapper} that produces a {@code Tuple3}
##### toArray(...) -> RowMapper<Object\[\]>
- **Signature:** `@Beta @SequentialOnly @Stateful static RowMapper<Object[]> toArray(final ColumnGetter<?> columnGetterForAll)`
- **Summary:** Creates a stateful {@code RowMapper} that maps all columns of a row to an {@code Object\[\]} .
- **Contract:**
  - It should not be cached, shared, or used in parallel streams.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code RowMapper<Object\[\]> arrayMapper = RowMapper.toArray(ColumnGetter.GET_OBJECT); // When applied to a row: Object\[\] rowData = arrayMapper.apply(rs); } </pre>
- **Parameters:**
  - `columnGetterForAll` (`ColumnGetter<?>`) — the {@code ColumnGetter} used to retrieve the value for every column
- **Returns:** a stateful {@code RowMapper} that maps a row to an {@code Object\[\]}
##### toList(...) -> RowMapper<List<Object>>
- **Signature:** `@Beta @SequentialOnly @Stateful static RowMapper<List<Object>> toList(final ColumnGetter<?> columnGetterForAll)`
- **Summary:** Creates a stateful {@code RowMapper} that maps all columns of a row to a {@code List<Object>} .
- **Contract:**
  - It should not be cached, shared, or used in parallel streams.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code RowMapper<List<Object>> listMapper = RowMapper.toList(ColumnGetter.GET_OBJECT); // When applied to a row: List<Object> rowData = listMapper.apply(rs); } </pre>
- **Parameters:**
  - `columnGetterForAll` (`ColumnGetter<?>`) — the {@code ColumnGetter} used to retrieve the value for every column
- **Returns:** a stateful {@code RowMapper} that maps a row to a {@code List<Object>}
##### toCollection(...) -> RowMapper<C>
- **Signature:** `@Beta @SequentialOnly @Stateful static <C extends Collection<?>> RowMapper<C> toCollection(final ColumnGetter<?> columnGetterForAll, final IntFunction<? extends C> supplier)`
- **Summary:** Creates a stateful {@code RowMapper} that maps all columns of a row to a {@code Collection} .
- **Contract:**
  - It should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - `columnGetterForAll` (`ColumnGetter<?>`) — the {@code ColumnGetter} used to retrieve the value for every column
  - `supplier` (`IntFunction<? extends C>`) — a function that takes the column count and returns a new {@code Collection} instance
- **Returns:** a stateful {@code RowMapper} that maps a row to a {@code Collection}
##### toDisposableObjArray(...) -> RowMapper<DisposableObjArray>
- **Signature:** `@Beta @SequentialOnly @Stateful static RowMapper<DisposableObjArray> toDisposableObjArray()`
- **Summary:** Creates a stateful {@code RowMapper} that maps a row to a reusable {@code DisposableObjArray} .
- **Contract:**
  - You must process or copy its contents before the next row is mapped.
- **Parameters:**
  - (none)
- **Returns:** a stateful {@code RowMapper} for high-performance, single-threaded row processing
- **Signature:** `@Beta @SequentialOnly @Stateful static RowMapper<DisposableObjArray> toDisposableObjArray(final Class<?> entityClass)`
- **Summary:** Creates a stateful {@code RowMapper} that maps a row to a reusable {@code DisposableObjArray} , using type information from an entity class to perform appropriate type conversions for each column.
- **Contract:**
  - You must process or copy its contents before the next row is mapped.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the class used to infer the data type for each column based on matching property names
- **Returns:** a stateful {@code RowMapper} for high-performance, type-aware, single-threaded row processing
##### builder(...) -> RowMapperBuilder
- **Signature:** `static RowMapperBuilder builder()`
- **Summary:** Creates a new {@code RowMapperBuilder} with a default column getter of {@code ColumnGetter.GET_OBJECT} .
- **Parameters:**
  - (none)
- **Returns:** a new {@code RowMapperBuilder}
- **Signature:** `static RowMapperBuilder builder(final ColumnGetter<?> defaultColumnGetter)`
- **Summary:** Creates a new {@code RowMapperBuilder} with the specified default column getter.
- **Parameters:**
  - `defaultColumnGetter` (`ColumnGetter<?>`) — the default {@code ColumnGetter} to use for unconfigured columns
- **Returns:** a new {@code RowMapperBuilder}

#### Public Instance Methods
##### apply(...) -> T
- **Signature:** `@Override T apply(ResultSet rs) throws SQLException`
- **Summary:** Maps the current row of the given {@code ResultSet} to an object of type {@code T} .
- **Contract:**
  - This method should not advance the ResultSet cursor (e.g., call {@code rs.next()} ).
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} positioned at the row to be mapped
- **Returns:** the mapped object of type {@code T}
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs during column value retrieval
##### andThen(...) -> RowMapper<R>
- **Signature:** `default <R> RowMapper<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)`
- **Summary:** Returns a composed {@code RowMapper} that first applies this mapper to the row and then applies the {@code after} function to the result.
- **Parameters:**
  - `after` (`Throwables.Function<? super T, ? extends R, SQLException>`) — the function to apply to the result of this mapper; must not be null
- **Returns:** a composed {@code RowMapper}
##### toBiRowMapper(...) -> BiRowMapper<T>
- **Signature:** `default BiRowMapper<T> toBiRowMapper()`
- **Summary:** Converts this {@code RowMapper} to a {@code BiRowMapper} .
- **Parameters:**
  - (none)
- **Returns:** a {@code BiRowMapper} that delegates to this {@code RowMapper} .

### Class RowMapperBuilder (com.landawn.abacus.jdbc.Jdbc.RowMapper.RowMapperBuilder)
A fluent builder for creating customized, stateful {@code RowMapper} instances.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### getBoolean(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getBoolean(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code boolean} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getByte(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getByte(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code byte} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getShort(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getShort(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code short} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getInt(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getInt(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve an {@code int} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getLong(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getLong(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code long} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getFloat(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getFloat(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code float} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getDouble(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getDouble(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code double} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getBigDecimal(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getBigDecimal(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code BigDecimal} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getString(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getString(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code String} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getDate(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getDate(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code java.sql.Date} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getTime(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getTime(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code java.sql.Time} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getTimestamp(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder getTimestamp(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve a {@code java.sql.Timestamp} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
##### getObject(...) -> RowMapperBuilder
- **Signature:** `@Deprecated public RowMapperBuilder getObject(final int columnIndex)`
- **Summary:** Configures the mapper to retrieve an {@code Object} value from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
- **Returns:** this builder instance for method chaining
- **Signature:** `public RowMapperBuilder getObject(final int columnIndex, final Class<?> type)`
- **Summary:** Configures the mapper to retrieve an object of a specific type from the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
  - `type` (`Class<?>`) — the target class type to convert the column value to
- **Returns:** this builder instance for method chaining
##### get(...) -> RowMapperBuilder
- **Signature:** `public RowMapperBuilder get(final int columnIndex, final ColumnGetter<?> columnGetter) throws IllegalArgumentException`
- **Summary:** Configures the mapper to use a custom {@code ColumnGetter} for the specified column index.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column
  - `columnGetter` (`ColumnGetter<?>`) — the custom {@code ColumnGetter} to use
- **Returns:** this builder instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnIndex} is not positive or {@code columnGetter} is null
##### toArray(...) -> RowMapper<Object\[\]>
- **Signature:** `@SequentialOnly @Stateful public RowMapper<Object[]> toArray()`
- **Summary:** Builds and returns a stateful {@code RowMapper} that maps each row to an {@code Object\[\]} .
- **Contract:**
  - <p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - (none)
- **Returns:** a new stateful {@code RowMapper<Object\[\]>}
##### toList(...) -> RowMapper<List<Object>>
- **Signature:** `@SequentialOnly @Stateful public RowMapper<List<Object>> toList()`
- **Summary:** Builds and returns a stateful {@code RowMapper} that maps each row to a {@code List<Object>} .
- **Contract:**
  - <p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - (none)
- **Returns:** a new stateful {@code RowMapper<List<Object>>}
##### toCollection(...) -> RowMapper<C>
- **Signature:** `@SequentialOnly @Stateful public <C extends Collection<?>> RowMapper<C> toCollection(final IntFunction<? extends C> supplier)`
- **Summary:** Builds and returns a stateful {@code RowMapper} that maps each row to a {@code Collection} .
- **Contract:**
  - <p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - `supplier` (`IntFunction<? extends C>`) — a function that provides a new collection instance, given the column count
- **Returns:** a new stateful {@code RowMapper<C>}
##### toMap(...) -> RowMapper<Map<String, Object>>
- **Signature:** `@SequentialOnly @Stateful public RowMapper<Map<String, Object>> toMap()`
- **Summary:** Builds and returns a stateful {@code RowMapper} that maps each row to a {@code Map<String, Object>} , where keys are the column labels.
- **Contract:**
  - <p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - (none)
- **Returns:** a new stateful {@code RowMapper<Map<String, Object>>}
- **Signature:** `@SequentialOnly @Stateful public RowMapper<Map<String, Object>> toMap(final IntFunction<? extends Map<String, Object>> mapSupplier)`
- **Summary:** Builds and returns a stateful {@code RowMapper} that maps each row to a {@code Map<String, Object>} , using the provided supplier to create the map instance.
- **Contract:**
  - <p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - `mapSupplier` (`IntFunction<? extends Map<String, Object>>`) — a function that provides a new map instance, given the column count
- **Returns:** a new stateful {@code RowMapper<Map<String, Object>>}
##### to(...) -> RowMapper<R>
- **Signature:** `@SequentialOnly @Stateful public <R> RowMapper<R> to(final Throwables.Function<DisposableObjArray, R, SQLException> finisher)`
- **Summary:** Builds a stateful {@code RowMapper} that processes row values into a final object using a custom finisher function.
- **Parameters:**
  - `finisher` (`Throwables.Function<DisposableObjArray, R, SQLException>`) — a function that transforms the row's values into the final result object
- **Returns:** a new stateful {@code RowMapper<R>}
- **Signature:** `@SequentialOnly @Stateful public <R> RowMapper<R> to(final Throwables.BiFunction<List<String>, DisposableObjArray, R, SQLException> finisher)`
- **Summary:** Builds a stateful {@code RowMapper} that uses a custom finisher function which receives both the column labels and the row values (as a {@code DisposableObjArray} ).
- **Parameters:**
  - `finisher` (`Throwables.BiFunction<List<String>, DisposableObjArray, R, SQLException>`) — a function that transforms column labels and row values into the final result object
- **Returns:** a new stateful {@code RowMapper<R>}

### Interface BiRowMapper (com.landawn.abacus.jdbc.Jdbc.BiRowMapper)
A functional interface for mapping the current row of a {@code ResultSet} to an object, with access to the list of column labels.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### combine(...) -> BiRowMapper<Tuple2<T, U>>
- **Signature:** `static <T, U> BiRowMapper<Tuple2<T, U>> combine(final BiRowMapper<? extends T> rowMapper1, final BiRowMapper<? extends U> rowMapper2)`
- **Summary:** Combines two {@code BiRowMapper} instances into a single mapper that returns a {@code Tuple2} containing the results of both.
- **Parameters:**
  - `rowMapper1` (`BiRowMapper<? extends T>`) — the first mapper; must not be null
  - `rowMapper2` (`BiRowMapper<? extends U>`) — the second mapper; must not be null
- **Returns:** a new {@code BiRowMapper} that produces a {@code Tuple2}
- **Signature:** `static <A, B, C> BiRowMapper<Tuple3<A, B, C>> combine(final BiRowMapper<? extends A> rowMapper1, final BiRowMapper<? extends B> rowMapper2, final BiRowMapper<? extends C> rowMapper3)`
- **Summary:** Combines three {@code BiRowMapper} instances into a single mapper that returns a {@code Tuple3} containing the results of all three.
- **Parameters:**
  - `rowMapper1` (`BiRowMapper<? extends A>`) — the first mapper; must not be null
  - `rowMapper2` (`BiRowMapper<? extends B>`) — the second mapper; must not be null
  - `rowMapper3` (`BiRowMapper<? extends C>`) — the third mapper; must not be null
- **Returns:** a new {@code BiRowMapper} that produces a {@code Tuple3}
##### to(...) -> BiRowMapper<T>
- **Signature:** `@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass)`
- **Summary:** Creates a stateful {@code BiRowMapper} that maps a row to an instance of the specified {@code targetClass} .
- **Contract:**
  - It should not be cached or shared for use with different SQL queries (which may have different column structures), nor should it be used in parallel streams.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class to map rows to
- **Returns:** a new stateful {@code BiRowMapper} . Do not cache or reuse across different query structures.
- **Signature:** `@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final boolean ignoreNonMatchedColumns)`
- **Summary:** Creates a stateful {@code BiRowMapper} that maps a row to an instance of the specified {@code targetClass} , with an option to ignore columns in the {@code ResultSet} that do not have a matching property in the class.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class to map rows to
  - `ignoreNonMatchedColumns` (`boolean`) — if {@code true} , columns without a corresponding property in {@code targetClass} are ignored; if {@code false} , an {@code IllegalArgumentException} is thrown.
- **Returns:** a new stateful {@code BiRowMapper} . Do not cache or reuse across different query structures.
- **Signature:** `@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final Predicate<? super String> columnNameFilter, final Function<? super String, String> columnNameConverter)`
- **Summary:** Creates a stateful {@code BiRowMapper} with custom filtering and conversion for column names before mapping them to object properties.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class to map rows to
  - `columnNameFilter` (`Predicate<? super String>`) — a predicate to filter which columns should be considered for mapping
  - `columnNameConverter` (`Function<? super String, String>`) — a function to transform column names before matching them to properties
- **Returns:** a new stateful {@code BiRowMapper} . Do not cache or reuse across different query structures.
- **Signature:** `@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final Predicate<? super String> columnNameFilter, final Function<? super String, String> columnNameConverter, final boolean ignoreNonMatchedColumns)`
- **Summary:** Creates a stateful {@code BiRowMapper} with full customization over column filtering, name conversion, and handling of non-matched columns.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class to map rows to
  - `columnNameFilter` (`Predicate<? super String>`) — a predicate to filter which columns should be considered for mapping
  - `columnNameConverter` (`Function<? super String, String>`) — a function to transform column names before matching them to properties
  - `ignoreNonMatchedColumns` (`boolean`) — if {@code true} , filtered columns without a corresponding property are ignored; if {@code false} , an {@code IllegalArgumentException} is thrown.
- **Returns:** a new stateful {@code BiRowMapper} . Do not cache or reuse across different query structures.
- **Signature:** `@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> entityClass, final Map<String, String> prefixAndFieldNameMap)`
- **Summary:** Creates a stateful {@code BiRowMapper} for a target entity class, using a map to resolve column name prefixes to nested property paths.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `entityClass` (`Class<? extends T>`) — the class to map rows to
  - `prefixAndFieldNameMap` (`Map<String, String>`) — a map where keys are column prefixes and values are corresponding property paths
- **Returns:** a new stateful {@code BiRowMapper} . Do not cache or reuse across different query structures.
- **Signature:** `@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> entityClass, final Map<String, String> prefixAndFieldNameMap, final boolean ignoreNonMatchedColumns)`
- **Summary:** Creates a stateful {@code BiRowMapper} with prefix-to-property mapping and an option to ignore non-matched columns.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `entityClass` (`Class<? extends T>`) — the class to map rows to
  - `prefixAndFieldNameMap` (`Map<String, String>`) — a map where keys are column prefixes and values are corresponding property paths
  - `ignoreNonMatchedColumns` (`boolean`) — if {@code true} , columns without a matching property are ignored
- **Returns:** a new stateful {@code BiRowMapper} . Do not cache or reuse across different query structures.
##### toMap(...) -> BiRowMapper<Map<String, Object>>
- **Signature:** `static BiRowMapper<Map<String, Object>> toMap(final BiPredicate<String, Object> valueFilter, final IntFunction<? extends Map<String, Object>> mapSupplier)`
- **Summary:** Creates a {@code BiRowMapper} that converts a row to a {@code Map} , including only the entries that satisfy the given key-value filter.
- **Parameters:**
  - `valueFilter` (`BiPredicate<String, Object>`) — a bi-predicate to test column names and their corresponding values
  - `mapSupplier` (`IntFunction<? extends Map<String, Object>>`) — a function that provides a new map instance, given the column count
- **Returns:** a {@code BiRowMapper} that produces a filtered {@code Map}
- **Signature:** `@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final RowExtractor rowExtractor, final BiPredicate<String, Object> valueFilter, final IntFunction<? extends Map<String, Object>> mapSupplier)`
- **Summary:** Creates a stateful {@code BiRowMapper} that converts a row to a {@code Map} using a custom {@code RowExtractor} and then filters the results.
- **Contract:**
  - This method is useful when you need custom value extraction logic (via {@code RowExtractor} ) combined with filtering.
  - It should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - `rowExtractor` (`RowExtractor`) — the custom extractor to get values from the {@code ResultSet} row
  - `valueFilter` (`BiPredicate<String, Object>`) — a bi-predicate to test column names and their corresponding values
  - `mapSupplier` (`IntFunction<? extends Map<String, Object>>`) — a function that provides a new map instance, given the column count
- **Returns:** a new stateful {@code BiRowMapper} .
- **Signature:** `@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final Function<? super String, String> columnNameConverter)`
- **Summary:** Creates a stateful {@code BiRowMapper} that converts a row to a {@code Map} , applying a conversion function to each column name to generate the map keys.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `columnNameConverter` (`Function<? super String, String>`) — a function to transform column names into map keys
- **Returns:** a new stateful {@code BiRowMapper} .
- **Signature:** `@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final Function<? super String, String> columnNameConverter, final IntFunction<? extends Map<String, Object>> mapSupplier)`
- **Summary:** Creates a stateful {@code BiRowMapper} that converts a row to a custom {@code Map} , applying a conversion function to each column name to generate the map keys.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `columnNameConverter` (`Function<? super String, String>`) — a function to transform column names into map keys
  - `mapSupplier` (`IntFunction<? extends Map<String, Object>>`) — a function that provides a new map instance, given the column count
- **Returns:** a new stateful {@code BiRowMapper} .
- **Signature:** `@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final RowExtractor rowExtractor)`
- **Summary:** Creates a stateful {@code BiRowMapper} that converts a row to a {@code Map} using a custom {@code RowExtractor} .
- **Contract:**
  - This method is useful when you need custom value extraction logic for all columns, producing a HashMap with original column names as keys.
  - It should not be cached, shared, or used in parallel streams.
- **Parameters:**
  - `rowExtractor` (`RowExtractor`) — the custom extractor to get values from the {@code ResultSet} row
- **Returns:** a new stateful {@code BiRowMapper} .
- **Signature:** `@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final RowExtractor rowExtractor, final Function<? super String, String> columnNameConverter, final IntFunction<? extends Map<String, Object>> mapSupplier)`
- **Summary:** Creates a stateful {@code BiRowMapper} that converts a row to a custom {@code Map} using a {@code RowExtractor} and applying a conversion to the column names for keys.
- **Contract:**
  - It should not be cached, shared across different query structures, or used in parallel streams.
- **Parameters:**
  - `rowExtractor` (`RowExtractor`) — the custom extractor to get values from the row
  - `columnNameConverter` (`Function<? super String, String>`) — a function to transform column names into map keys
  - `mapSupplier` (`IntFunction<? extends Map<String, Object>>`) — a function that provides a new map instance, given the column count
- **Returns:** a new stateful {@code BiRowMapper} .
##### toArray(...) -> BiRowMapper<Object\[\]>
- **Signature:** `@Beta static BiRowMapper<Object[]> toArray(final ColumnGetter<?> columnGetterForAll)`
- **Summary:** Creates a {@code BiRowMapper} that maps all columns of a row to an {@code Object\[\]} .
- **Parameters:**
  - `columnGetterForAll` (`ColumnGetter<?>`) — the {@code ColumnGetter} used for every column
- **Returns:** a {@code BiRowMapper} that produces an {@code Object\[\]}
##### toList(...) -> BiRowMapper<List<Object>>
- **Signature:** `@Beta static BiRowMapper<List<Object>> toList(final ColumnGetter<?> columnGetterForAll)`
- **Summary:** Creates a {@code BiRowMapper} that maps all columns of a row to a {@code List<Object>} .
- **Parameters:**
  - `columnGetterForAll` (`ColumnGetter<?>`) — the {@code ColumnGetter} used for every column
- **Returns:** a {@code BiRowMapper} that produces a {@code List<Object>}
##### toCollection(...) -> BiRowMapper<C>
- **Signature:** `@Beta static <C extends Collection<?>> BiRowMapper<C> toCollection(final ColumnGetter<?> columnGetterForAll, final IntFunction<? extends C> supplier)`
- **Summary:** Creates a {@code BiRowMapper} that maps all columns of a row to a {@code Collection} .
- **Parameters:**
  - `columnGetterForAll` (`ColumnGetter<?>`) — the {@code ColumnGetter} used for every column
  - `supplier` (`IntFunction<? extends C>`) — a function that takes the column count and returns a new {@code Collection} instance
- **Returns:** a {@code BiRowMapper} that produces a {@code Collection}
##### toDisposableObjArray(...) -> BiRowMapper<DisposableObjArray>
- **Signature:** `@Beta @SequentialOnly @Stateful static BiRowMapper<DisposableObjArray> toDisposableObjArray()`
- **Summary:** Creates a stateful {@code BiRowMapper} that maps a row to a reusable {@code DisposableObjArray} .
- **Contract:**
  - You must process or copy its contents before the next row is mapped.
- **Parameters:**
  - (none)
- **Returns:** a stateful {@code BiRowMapper} for high-performance, single-threaded row processing
- **Signature:** `@Beta @SequentialOnly @Stateful static BiRowMapper<DisposableObjArray> toDisposableObjArray(final Class<?> entityClass)`
- **Summary:** Creates a stateful {@code BiRowMapper} that maps a row to a reusable {@code DisposableObjArray} , using type information from an entity class to perform type conversions for each column.
- **Contract:**
  - You must process or copy its contents before the next row is mapped.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the class used to infer the data type for each column based on matching property names
- **Returns:** a stateful {@code BiRowMapper} for high-performance, type-aware, single-threaded row processing
##### builder(...) -> BiRowMapperBuilder
- **Signature:** `static BiRowMapperBuilder builder()`
- **Summary:** Creates a new {@code BiRowMapperBuilder} with a default column getter of {@code ColumnGetter.GET_OBJECT} .
- **Parameters:**
  - (none)
- **Returns:** a new {@code BiRowMapperBuilder}
- **Signature:** `static BiRowMapperBuilder builder(final ColumnGetter<?> defaultColumnGetter)`
- **Summary:** Creates a new {@code BiRowMapperBuilder} with the specified default column getter.
- **Parameters:**
  - `defaultColumnGetter` (`ColumnGetter<?>`) — the default {@code ColumnGetter} to use for unconfigured columns
- **Returns:** a new {@code BiRowMapperBuilder}

#### Public Instance Methods
##### apply(...) -> T
- **Signature:** `@Override T apply(ResultSet rs, List<String> columnLabels) throws SQLException`
- **Summary:** Maps the current row of the given {@code ResultSet} to an object of type {@code T} , using the provided list of column labels.
- **Contract:**
  - This method should not advance the ResultSet cursor.
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} positioned at the row to be mapped
  - `columnLabels` (`List<String>`) — the list of column labels from the result set's metadata
- **Returns:** the mapped object of type {@code T}
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs during column value retrieval
##### andThen(...) -> BiRowMapper<R>
- **Signature:** `default <R> BiRowMapper<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)`
- **Summary:** Returns a composed {@code BiRowMapper} that first applies this mapper to the row and then applies the {@code after} function to the result.
- **Parameters:**
  - `after` (`Throwables.Function<? super T, ? extends R, SQLException>`) — the function to apply to the result of this mapper; must not be null
- **Returns:** a composed {@code BiRowMapper}
##### toRowMapper(...) -> RowMapper<T>
- **Signature:** `@Deprecated @SequentialOnly @Stateful default RowMapper<T> toRowMapper()`
- **Summary:** Converts this {@code BiRowMapper} to a stateful {@code RowMapper} .
- **Parameters:**
  - (none)
- **Returns:** a stateful {@code RowMapper} . Do not cache, share, or use it in parallel streams.
- **See also:** RowMapper#toBiRowMapper()

### Class BiRowMapperBuilder (com.landawn.abacus.jdbc.Jdbc.BiRowMapper.BiRowMapperBuilder)
A fluent builder for creating customized, stateful {@code BiRowMapper} instances.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### getBoolean(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getBoolean(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code boolean} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getByte(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getByte(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code byte} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getShort(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getShort(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code short} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getInt(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getInt(final String columnName)`
- **Summary:** Configures the mapper to retrieve an {@code int} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getLong(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getLong(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code long} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getFloat(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getFloat(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code float} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getDouble(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getDouble(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code double} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getBigDecimal(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getBigDecimal(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code BigDecimal} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getString(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getString(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code String} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getDate(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getDate(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code java.sql.Date} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getTime(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getTime(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code java.sql.Time} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getTimestamp(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder getTimestamp(final String columnName)`
- **Summary:** Configures the mapper to retrieve a {@code java.sql.Timestamp} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
##### getObject(...) -> BiRowMapperBuilder
- **Signature:** `@Deprecated public BiRowMapperBuilder getObject(final String columnName)`
- **Summary:** Configures the mapper to retrieve an {@code Object} value from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
- **Returns:** this builder instance for method chaining
- **Signature:** `public BiRowMapperBuilder getObject(final String columnName, final Class<?> type)`
- **Summary:** Configures the mapper to retrieve an object of a specific type from the specified column.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
  - `type` (`Class<?>`) — the target class type to convert the column value to
- **Returns:** this builder instance for method chaining
##### get(...) -> BiRowMapperBuilder
- **Signature:** `public BiRowMapperBuilder get(final String columnName, final ColumnGetter<?> columnGetter) throws IllegalArgumentException`
- **Summary:** Configures the mapper to use a custom {@code ColumnGetter} for the specified column name.
- **Parameters:**
  - `columnName` (`String`) — the name of the column
  - `columnGetter` (`ColumnGetter<?>`) — the custom {@code ColumnGetter} to use for this column
- **Returns:** this builder instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnName} is null/empty or {@code columnGetter} is null
##### to(...) -> BiRowMapper<T>
- **Signature:** `@SequentialOnly @Stateful public <T> BiRowMapper<T> to(final Class<? extends T> targetClass)`
- **Summary:** Builds and returns a stateful {@code BiRowMapper} that maps each row to an instance of the specified {@code targetClass} .
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class to map rows to
- **Returns:** a new stateful {@code BiRowMapper<T>}
- **Signature:** `@SequentialOnly @Stateful public <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final boolean ignoreNonMatchedColumns)`
- **Summary:** Builds and returns a stateful {@code BiRowMapper} that maps each row to an instance of the specified {@code targetClass} , with an option to ignore columns that don't match any property.
- **Parameters:**
  - `targetClass` (`Class<? extends T>`) — the class to map rows to
  - `ignoreNonMatchedColumns` (`boolean`) — if {@code true} , columns without a corresponding property are ignored
- **Returns:** a new stateful {@code BiRowMapper<T>}

### Interface RowConsumer (com.landawn.abacus.jdbc.Jdbc.RowConsumer)
A functional interface for consuming a single row of a {@code ResultSet} without returning a value.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### create(...) -> RowConsumer
- **Signature:** `@Beta @SequentialOnly @Stateful static RowConsumer create(final Throwables.ObjIntConsumer<? super ResultSet, SQLException> consumerForAll)`
- **Summary:** Creates a stateful {@code RowConsumer} that iterates over all columns in each row and applies the specified action.
- **Contract:**
  - Therefore, it should not be reused across different queries with varying column counts or used in parallel streams.
  - A new instance should be created for each distinct query execution.
- **Parameters:**
  - `consumerForAll` (`Throwables.ObjIntConsumer<? super ResultSet, SQLException>`) — the action to be performed for each column. The first parameter is the {@code ResultSet} , and the second is the 1-based column index.
- **Returns:** a new stateful {@code RowConsumer} .
##### oneOff(...) -> RowConsumer
- **Signature:** `@Beta @SequentialOnly @Stateful static RowConsumer oneOff(final Consumer<DisposableObjArray> consumer)`
- **Summary:** Creates a stateful {@code RowConsumer} that converts each row into a reusable {@code DisposableObjArray} and passes it to the specified consumer.
- **Contract:**
  - This consumer should not be reused across different queries with varying column counts or used in parallel streams.
- **Parameters:**
  - `consumer` (`Consumer<DisposableObjArray>`) — the consumer to process the {@code DisposableObjArray} for each row.
- **Returns:** a new stateful {@code RowConsumer} .
- **Signature:** `@Beta @SequentialOnly @Stateful static RowConsumer oneOff(final Class<?> entityClass, final Consumer<DisposableObjArray> consumer)`
- **Summary:** Creates a stateful {@code RowConsumer} that converts each row into a reusable {@code DisposableObjArray} using type information from a specified entity class, then passes it to the consumer.
- **Contract:**
  - This consumer should not be reused across different queries or used in parallel streams.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the class used to infer column types for fetching values from the {@code ResultSet} .
  - `consumer` (`Consumer<DisposableObjArray>`) — the consumer to process the typed {@code DisposableObjArray} for each row.
- **Returns:** a new stateful {@code RowConsumer} .

#### Public Instance Methods
##### accept(...) -> void
- **Signature:** `@Override void accept(ResultSet rs) throws SQLException`
- **Summary:** Performs this operation on the given {@code ResultSet} .
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} positioned at the current row to be consumed.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs.
##### andThen(...) -> RowConsumer
- **Signature:** `default RowConsumer andThen(final Throwables.Consumer<? super ResultSet, SQLException> after)`
- **Summary:** Returns a composed {@code RowConsumer} that performs, in sequence, this operation followed by the {@code after} operation.
- **Parameters:**
  - `after` (`Throwables.Consumer<? super ResultSet, SQLException>`) — the operation to perform after this operation.
- **Returns:** a composed {@code RowConsumer} that performs in sequence this operation followed by the {@code after} operation.
##### toBiRowConsumer(...) -> BiRowConsumer
- **Signature:** `default BiRowConsumer toBiRowConsumer()`
- **Summary:** Converts this {@code RowConsumer} to a {@link BiRowConsumer} , which also accepts a list of column labels.
- **Parameters:**
  - (none)
- **Returns:** a {@code BiRowConsumer} that delegates to this consumer.

### Interface BiRowConsumer (com.landawn.abacus.jdbc.Jdbc.BiRowConsumer)
A functional interface for consuming a single row of a {@code ResultSet} along with its column labels.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### create(...) -> BiRowConsumer
- **Signature:** `@Beta static BiRowConsumer create(final Throwables.ObjIntConsumer<? super ResultSet, SQLException> consumerForAll)`
- **Summary:** Creates a {@code BiRowConsumer} that iterates over all columns in each row and applies the specified action.
- **Parameters:**
  - `consumerForAll` (`Throwables.ObjIntConsumer<? super ResultSet, SQLException>`) — the action to be performed for each column. The first parameter is the {@code ResultSet} , and the second is the 1-based column index.
- **Returns:** a new {@code BiRowConsumer} .
##### oneOff(...) -> BiRowConsumer
- **Signature:** `@Beta @SequentialOnly @Stateful static BiRowConsumer oneOff(final BiConsumer<List<String>, DisposableObjArray> consumer)`
- **Summary:** Creates a stateful {@code BiRowConsumer} that converts each row into a reusable {@code DisposableObjArray} and passes it, along with column labels, to the specified consumer.
- **Contract:**
  - This consumer should not be reused in parallel streams.
- **Parameters:**
  - `consumer` (`BiConsumer<List<String>, DisposableObjArray>`) — the consumer to process the column labels and {@code DisposableObjArray} for each row.
- **Returns:** a new stateful {@code BiRowConsumer} .
- **Signature:** `@Beta @SequentialOnly @Stateful static BiRowConsumer oneOff(final Class<?> entityClass, final BiConsumer<List<String>, DisposableObjArray> consumer)`
- **Summary:** Creates a stateful {@code BiRowConsumer} that converts each row into a reusable {@code DisposableObjArray} using type information from a specified entity class.
- **Contract:**
  - This consumer should not be reused across different queries or in parallel streams.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the class used to infer column types for fetching values from the {@code ResultSet} .
  - `consumer` (`BiConsumer<List<String>, DisposableObjArray>`) — the consumer to process the column labels and typed {@code DisposableObjArray} for each row.
- **Returns:** a new stateful {@code BiRowConsumer} .

#### Public Instance Methods
##### accept(...) -> void
- **Signature:** `@Override void accept(ResultSet rs, List<String> columnLabels) throws SQLException`
- **Summary:** Performs this operation on the given {@code ResultSet} and column labels.
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} positioned at the current row to be consumed.
  - `columnLabels` (`List<String>`) — the list of column labels from the result set metadata.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs.
##### andThen(...) -> BiRowConsumer
- **Signature:** `default BiRowConsumer andThen(final Throwables.BiConsumer<? super ResultSet, ? super List<String>, SQLException> after)`
- **Summary:** Returns a composed {@code BiRowConsumer} that performs, in sequence, this operation followed by the {@code after} operation.
- **Parameters:**
  - `after` (`Throwables.BiConsumer<? super ResultSet, ? super List<String>, SQLException>`) — the operation to perform after this operation.
- **Returns:** a composed {@code BiRowConsumer} that performs in sequence this operation followed by the {@code after} operation.

### Interface RowFilter (com.landawn.abacus.jdbc.Jdbc.RowFilter)
A functional interface that represents a predicate (boolean-valued function) of one {@code ResultSet} argument.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### test(...) -> boolean
- **Signature:** `@Override boolean test(final ResultSet rs) throws SQLException`
- **Summary:** Evaluates this filter on the given {@code ResultSet} .
- **Contract:**
  - This method should be fast enough to avoid holding DB connections for a long time or slowing down overall performance.
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} positioned at the current row.
- **Returns:** {@code true} if the row should be included, {@code false} otherwise.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs.
##### negate(...) -> RowFilter
- **Signature:** `@Override default RowFilter negate()`
- **Summary:** Returns a filter that represents the logical negation of this filter.
- **Parameters:**
  - (none)
- **Returns:** a new {@code RowFilter} that is the negation of this filter.
##### and(...) -> RowFilter
- **Signature:** `default RowFilter and(final Throwables.Predicate<? super ResultSet, SQLException> other)`
- **Summary:** Returns a composed filter that represents a short-circuiting logical AND of this filter and another.
- **Parameters:**
  - `other` (`Throwables.Predicate<? super ResultSet, SQLException>`) — a {@code RowFilter} that will be logically-ANDed with this filter.
- **Returns:** a new composed {@code RowFilter} .
##### toBiRowFilter(...) -> BiRowFilter
- **Signature:** `default BiRowFilter toBiRowFilter()`
- **Summary:** Converts this {@code RowFilter} to a {@link BiRowFilter} , which also accepts a list of column labels.
- **Parameters:**
  - (none)
- **Returns:** a {@code BiRowFilter} that delegates to this filter.

### Interface BiRowFilter (com.landawn.abacus.jdbc.Jdbc.BiRowFilter)
A functional interface that represents a predicate (boolean-valued function) of a {@code ResultSet} and its column labels.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### test(...) -> boolean
- **Signature:** `@Override boolean test(ResultSet rs, List<String> columnLabels) throws SQLException`
- **Summary:** Evaluates this filter on the given {@code ResultSet} and column labels.
- **Contract:**
  - This method should be fast enough to avoid holding DB connections for a long time or slowing down overall performance.
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} positioned at the current row.
  - `columnLabels` (`List<String>`) — the list of column labels from the result set metadata.
- **Returns:** {@code true} if the row should be included, {@code false} otherwise.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs.
##### negate(...) -> BiRowFilter
- **Signature:** `default BiRowFilter negate()`
- **Summary:** Returns a filter that represents the logical negation of this filter.
- **Parameters:**
  - (none)
- **Returns:** a new {@code BiRowFilter} that is the negation of this filter.
##### and(...) -> BiRowFilter
- **Signature:** `default BiRowFilter and(final Throwables.BiPredicate<? super ResultSet, ? super List<String>, SQLException> other)`
- **Summary:** Returns a composed filter that represents a short-circuiting logical AND of this filter and another.
- **Parameters:**
  - `other` (`Throwables.BiPredicate<? super ResultSet, ? super List<String>, SQLException>`) — a {@code BiRowFilter} that will be logically-ANDed with this filter.
- **Returns:** a new composed {@code BiRowFilter} .

### Interface RowExtractor (com.landawn.abacus.jdbc.Jdbc.RowExtractor)
A functional interface for extracting data from the current row of a {@code ResultSet} into a target {@code Object} array.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### createBy(...) -> RowExtractor
- **Signature:** `@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch)`
- **Summary:** Creates a stateful {@code RowExtractor} that maps {@code ResultSet} columns to an {@code Object} array based on the properties of the given entity class.
- **Contract:**
  - It should not be reused across queries with different column structures or in parallel streams.
- **Parameters:**
  - `entityClassForFetch` (`Class<?>`) — the entity class whose properties guide the type mapping.
- **Returns:** a new stateful {@code RowExtractor} .
- **Signature:** `@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch, final Map<String, String> prefixAndFieldNameMap)`
- **Summary:** Creates a stateful {@code RowExtractor} based on an entity class, with custom mapping for column prefixes to field name prefixes.
- **Contract:**
  - <p> <b> Warning: </b> The returned extractor is stateful and should not be reused across different queries or in parallel streams.
- **Parameters:**
  - `entityClassForFetch` (`Class<?>`) — the entity class for type mapping.
  - `prefixAndFieldNameMap` (`Map<String, String>`) — a map where keys are column prefixes and values are corresponding entity field prefixes.
- **Returns:** a new stateful {@code RowExtractor} .
- **Signature:** `@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch, final List<String> columnLabels)`
- **Summary:** Creates a stateful {@code RowExtractor} based on an entity class, using a predefined list of column labels.
- **Contract:**
  - <p> <b> Warning: </b> The returned extractor is stateful and should not be reused across different queries or in parallel streams.
- **Parameters:**
  - `entityClassForFetch` (`Class<?>`) — the entity class for type mapping.
  - `columnLabels` (`List<String>`) — the explicit list of column labels to use for mapping.
- **Returns:** a new stateful {@code RowExtractor} .
- **Signature:** `@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch, final List<String> columnLabels, final Map<String, String> prefixAndFieldNameMap)`
- **Summary:** Creates a stateful {@code RowExtractor} with comprehensive customization options, including an entity class for type mapping, an explicit list of column labels, and a prefix map for complex mappings.
- **Contract:**
  - It should not be reused across queries with different column structures or in parallel streams.
- **Parameters:**
  - `entityClassForFetch` (`Class<?>`) — the entity class for type mapping.
  - `columnLabels` (`List<String>`) — an optional list of column labels to use for mapping. If {@code null} , they are discovered from the {@code ResultSet} .
  - `prefixAndFieldNameMap` (`Map<String, String>`) — an optional map for mapping column prefixes to field name prefixes.
- **Returns:** a new stateful {@code RowExtractor} .
##### create(...) -> RowExtractorBuilder
- **Signature:** `static RowExtractorBuilder create(final ColumnGetter<?> defaultColumnGetter)`
- **Summary:** Creates a {@link RowExtractorBuilder} with a specified default {@code ColumnGetter} .
- **Parameters:**
  - `defaultColumnGetter` (`ColumnGetter<?>`) — the default {@code ColumnGetter} to use.
- **Returns:** a new {@code RowExtractorBuilder} .
##### builder(...) -> RowExtractorBuilder
- **Signature:** `static RowExtractorBuilder builder()`
- **Summary:** Creates a {@link RowExtractorBuilder} with a default behavior of retrieving all column values as {@code Object} instances using {@code ColumnGetter.GET_OBJECT} .
- **Parameters:**
  - (none)
- **Returns:** a new {@code RowExtractorBuilder} .
- **Signature:** `static RowExtractorBuilder builder(final ColumnGetter<?> defaultColumnGetter)`
- **Summary:** Creates a {@link RowExtractorBuilder} with a specified default {@code ColumnGetter} .
- **Parameters:**
  - `defaultColumnGetter` (`ColumnGetter<?>`) — the default {@code ColumnGetter} to use for unconfigured columns.
- **Returns:** a new {@code RowExtractorBuilder} .

#### Public Instance Methods
##### accept(...) -> void
- **Signature:** `@Override void accept(final ResultSet rs, final Object[] outputRow) throws SQLException`
- **Summary:** Extracts data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} positioned at a valid row.
  - `outputRow` (`Object[]`) — the array to be populated with data from the current row.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs.

### Class RowExtractorBuilder (com.landawn.abacus.jdbc.Jdbc.RowExtractor.RowExtractorBuilder)
A builder for creating customized {@link RowExtractor} instances.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### getBoolean(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getBoolean(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code boolean} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getByte(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getByte(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code byte} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getShort(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getShort(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code short} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getInt(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getInt(final int columnIndex)`
- **Summary:** Configures the extractor to get an {@code int} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getLong(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getLong(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code long} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getFloat(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getFloat(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code float} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getDouble(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getDouble(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code double} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getBigDecimal(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getBigDecimal(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code BigDecimal} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getString(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getString(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code String} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getDate(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getDate(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code java.sql.Date} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getTime(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getTime(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code java.sql.Time} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getTimestamp(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder getTimestamp(final int columnIndex)`
- **Summary:** Configures the extractor to get a {@code java.sql.Timestamp} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
##### getObject(...) -> RowExtractorBuilder
- **Signature:** `@Deprecated public RowExtractorBuilder getObject(final int columnIndex)`
- **Summary:** Configures the extractor to get an {@code Object} value from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** this builder instance for fluent chaining.
- **Signature:** `public RowExtractorBuilder getObject(final int columnIndex, final Class<?> type)`
- **Summary:** Configures the extractor to get an {@code Object} of a specific type from the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
  - `type` (`Class<?>`) — the class type to which the column value should be converted.
- **Returns:** this builder instance for fluent chaining.
##### get(...) -> RowExtractorBuilder
- **Signature:** `public RowExtractorBuilder get(final int columnIndex, final ColumnGetter<?> columnGetter) throws IllegalArgumentException`
- **Summary:** Configures the extractor to use a custom {@code ColumnGetter} for the specified column.
- **Parameters:**
  - `columnIndex` (`int`) — the 1-based index of the column.
  - `columnGetter` (`ColumnGetter<?>`) — the custom {@code ColumnGetter} to use for this column.
- **Returns:** this builder instance for fluent chaining.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code columnIndex} is not positive or {@code columnGetter} is {@code null} .
##### build(...) -> RowExtractor
- **Signature:** `@SequentialOnly @Stateful public RowExtractor build()`
- **Summary:** Builds a stateful {@code RowExtractor} based on the configured column getters.
- **Contract:**
  - It should not be cached or reused across different queries or in parallel streams.
  - A new instance should be built for each distinct query execution.
- **Parameters:**
  - (none)
- **Returns:** a new stateful {@code RowExtractor} .

### Interface ColumnGetter (com.landawn.abacus.jdbc.Jdbc.ColumnGetter)
A functional interface for extracting a typed value from a specified column of a {@code ResultSet} .

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### get(...) -> ColumnGetter<T>
- **Signature:** `static <T> ColumnGetter<T> get(final Class<? extends T> cls)`
- **Summary:** Retrieves a cached or creates a new {@code ColumnGetter} for the specified class type.
- **Parameters:**
  - `cls` (`Class<? extends T>`) — the class for which to get a {@code ColumnGetter} .
- **Returns:** a {@code ColumnGetter} for the specified type.
- **Signature:** `static <T> ColumnGetter<T> get(final Type<? extends T> type)`
- **Summary:** Retrieves a cached or creates a new {@code ColumnGetter} for the specified Abacus-common {@code Type} .
- **Parameters:**
  - `type` (`Type<? extends T>`) — the {@code Type} for which to get a {@code ColumnGetter} .
- **Returns:** a {@code ColumnGetter} for the specified type.

#### Public Instance Methods
##### apply(...) -> V
- **Signature:** `V apply(ResultSet rs, int columnIndex) throws SQLException`
- **Summary:** Extracts a value from the specified column of the given {@code ResultSet} .
- **Parameters:**
  - `rs` (`ResultSet`) — the {@code ResultSet} to extract from.
  - `columnIndex` (`int`) — the 1-based index of the column.
- **Returns:** the extracted value of type {@code V} .
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs.

### Class Columns (com.landawn.abacus.jdbc.Jdbc.Columns)
A utility class containing helpers and constants for column-specific operations, primarily focused on single-column results.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Class ColumnOne (com.landawn.abacus.jdbc.Jdbc.Columns.ColumnOne)
A utility class providing predefined {@link RowMapper} and {@link BiParametersSetter} instances for operations on the first column of a {@code ResultSet} or the first parameter of a {@code PreparedStatement} .

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### getObject(...) -> RowMapper<T>
- **Signature:** `public static <T> RowMapper<T> getObject()`
- **Summary:** Gets a generic {@code RowMapper} that extracts a value as an {@code Object} from the first column.
- **Parameters:**
  - (none)
- **Returns:** a {@code RowMapper} that extracts an {@code Object} from the first column.
##### get(...) -> RowMapper<T>
- **Signature:** `public static <T> RowMapper<T> get(final Class<? extends T> firstColumnType)`
- **Summary:** Gets a {@code RowMapper} that extracts a value of the specified type from the first column.
- **Parameters:**
  - `firstColumnType` (`Class<? extends T>`) — the class of the value in the first column.
- **Returns:** a {@code RowMapper} for the specified type.
- **Signature:** `@SuppressWarnings("cast") public static <T> RowMapper<T> get(final Type<? extends T> type)`
- **Summary:** Gets a {@code RowMapper} that extracts a value of the specified Abacus-common {@code Type} from the first column.
- **Parameters:**
  - `type` (`Type<? extends T>`) — the {@code Type} of the value in the first column.
- **Returns:** a {@code RowMapper} for the specified type.
##### readJson(...) -> RowMapper<T>
- **Signature:** `public static <T> RowMapper<T> readJson(final Class<? extends T> targetType)`
- **Summary:** Creates a {@code RowMapper} that reads a JSON string from the first column and deserializes it into an object of the specified target type.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to deserialize the JSON string into.
- **Returns:** a {@code RowMapper} that performs JSON deserialization.
##### readXml(...) -> RowMapper<T>
- **Signature:** `public static <T> RowMapper<T> readXml(final Class<? extends T> targetType)`
- **Summary:** Creates a {@code RowMapper} that reads an XML string from the first column and deserializes it into an object of the specified target type.
- **Parameters:**
  - `targetType` (`Class<? extends T>`) — the class to deserialize the XML string into.
- **Returns:** a {@code RowMapper} that performs XML deserialization.
##### set(...) -> BiParametersSetter<AbstractQuery, T>
- **Signature:** `@SuppressWarnings("rawtypes") public static <T> BiParametersSetter<AbstractQuery, T> set(final Class<T> type)`
- **Summary:** Creates a {@code BiParametersSetter} for setting a value of the specified type as the first parameter of a {@code PreparedStatement} .
- **Parameters:**
  - `type` (`Class<T>`) — the class of the parameter.
- **Returns:** a {@code BiParametersSetter} for the specified type.
- **Signature:** `@SuppressWarnings("rawtypes") public static <T> BiParametersSetter<AbstractQuery, T> set(final Type<T> type)`
- **Summary:** Creates a {@code BiParametersSetter} for setting a value of the specified Abacus-common {@code Type} as the first parameter of a {@code PreparedStatement} .
- **Parameters:**
  - `type` (`Type<T>`) — the {@code Type} of the parameter.
- **Returns:** a {@code BiParametersSetter} for the specified type.

#### Public Instance Methods
- (none)

### Class OutParam (com.landawn.abacus.jdbc.Jdbc.OutParam)
Represents an output parameter for a stored procedure call.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### of(...) -> OutParam
- **Signature:** `public static OutParam of(int parameterIndex, int sqlType)`
- **Summary:** A factory method to create an {@code OutParam} with the specified index and SQL type.
- **Parameters:**
  - `parameterIndex` (`int`) — the 1-based index of the parameter.
  - `sqlType` (`int`) — the SQL type from {@code java.sql.Types} .
- **Returns:** a new {@code OutParam} instance.

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `class OutParam { /** * The 1-based index of the parameter in the stored procedure call. */ private int parameterIndex; /** * The name of the parameter. This is optional and used for named parameter calls. */ private String parameterName; /** * The SQL type of the parameter, as defined in {@code java.sql.Types}. */ private int sqlType; /** * The database-specific type name. This is generally used for user-defined or complex types. */ private String typeName; /** * The number of digits to the right of the decimal point, for {@code DECIMAL} or {@code NUMERIC} types. */ private int scale; /** * A factory method to create an {@code OutParam} with the specified index and SQL type. * * @param parameterIndex the 1-based index of the parameter. * @param sqlType the SQL type from {@code java.sql.Types}. * @return a new {@code OutParam} instance. */ public static OutParam of(int parameterIndex, int sqlType) { final OutParam outParam = new OutParam(); outParam.setParameterIndex(parameterIndex); outParam.setSqlType(sqlType); return outParam; } } /** * A container for the results of output parameters from a stored procedure execution. * It provides methods to retrieve parameter values by their index or name. */ @EqualsAndHashCode @ToString public static final class OutParamResult { private final List<OutParam> outParams; private final Map<Object, Object> outParamValues; /** * Constructs an {@code OutParamResult} with the specified output parameters and their values. * * @param outParams the list of {@code OutParam} definitions. * @param outParamValues a map of output parameter values, keyed by index or name. */ OutParamResult(final List<OutParam> outParams, final Map<Object, Object> outParamValues) { this.outParams = outParams; this.outParamValues = outParamValues; } /** * Retrieves the value of an output parameter by its 1-based index. * * @param <T> expected parameter value type * @param parameterIndex the 1-based index of the parameter. * @return the parameter value, cast to type {@code T}. May be {@code null}. */ public <T> T getOutParamValue(final int parameterIndex) { return (T) outParamValues.get(parameterIndex); } /** * Retrieves the value of an output parameter by its name. * * @param <T> expected parameter value type * @param parameterName the name of the parameter. * @return the parameter value, cast to type {@code T}. May be {@code null}. */ public <T> T getOutParamValue(final String parameterName) { return (T) outParamValues.get(parameterName); } /** * Returns a map containing all output parameter values. The keys of the map are * either the parameter index ({@code Integer}) or name ({@code String}). * * @return an unmodifiable map of all output parameter values. */ public Map<Object, Object> getOutParamValues() { return outParamValues; } /** * Returns the list of {@link OutParam} definitions that were used to register the output parameters. * * @return an unmodifiable list of {@code OutParam} objects. */ public List<OutParam> getOutParams() { return outParams; } } /** * A handler interface for intercepting method invocations on DAO proxies, similar to an Aspect-Oriented * Programming (AOP) interceptor. It allows for executing custom logic before and after a DAO method is called. * * <p><b>Usage Examples:</b></p> * <pre>{@code * Handler<UserDao> loggingHandler = new Handler<>() { * public void beforeInvoke(UserDao proxy, Object[] args, Tuple3<Method, ..., ...> sig) { * System.out.println("Calling method: " + sig._1.getName()); * } * public void afterInvoke(Object result, UserDao proxy, Object[] args, Tuple3<Method, ..., ...> sig) { * System.out.println("Method returned: " + result); * } * }; * }</pre> * * @param <P> DAO proxy type */ @Beta public interface Handler<P> { /** * This method is invoked before the actual DAO method is called. It can be used for * logging, argument validation, security checks, or transaction management. * * @param proxy the proxy instance on which the method was invoked. * @param args the arguments passed to the method. * @param methodSignature a tuple containing the {@code Method} object, a list of parameter types, and the return type. */ @SuppressWarnings("unused") default void beforeInvoke(final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { // empty action. } /** * This method is invoked after the DAO method completes, whether successfully or with an exception. * It can be used for logging results, result transformation, or resource cleanup. * * @param result the value returned by the method. If the method's return type is void, this will be {@code null}. * @param proxy the proxy instance on which the method was invoked. * @param args the arguments passed to the method. * @param methodSignature a tuple containing the {@code Method} object, a list of parameter types, and the return type. */ @SuppressWarnings("unused") default void afterInvoke(final Object result, final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { // empty action. } } /** * A factory for creating and managing {@link Handler} instances. It provides a central registry * for handlers and supports integration with the Spring Framework's application context. */ public static final class HandlerFactory { @SuppressWarnings("rawtypes") static final Handler EMPTY = new Handler() { // Do nothing. }; private static final Map<String, Handler<?>> handlerPool = new ConcurrentHashMap<>(); private static final SpringApplicationContext springAppContext; static { handlerPool.put(ClassUtil.getCanonicalClassName(Handler.class), EMPTY); handlerPool.put(ClassUtil.getClassName(EMPTY.getClass()), EMPTY); SpringApplicationContext tmp = null; try { tmp = new SpringApplicationContext(); } catch (final Throwable e) { // ignore. } springAppContext = tmp; } /** * Registers a handler by creating a new instance of the specified handler class. * The handler is registered using its canonical class name as the qualifier. * * @param handlerClass the handler class to instantiate and register. * @return {@code true} if the handler was registered successfully, {@code false} if a handler with the same name already exists. * @throws IllegalArgumentException if {@code handlerClass} is {@code null}. */ public static boolean register(final Class<? extends Handler<?>> handlerClass) throws IllegalArgumentException { N.checkArgNotNull(handlerClass, cs.handlerClass); return register(N.newInstance(handlerClass)); } /** * Registers a handler instance. The handler is registered using its canonical class name as the qualifier. * * @param handler the handler instance to register. * @return {@code true} if the handler was registered successfully, {@code false} if a handler with the same name already exists. * @throws IllegalArgumentException if {@code handler} is {@code null}. */ public static boolean register(final Handler<?> handler) throws IllegalArgumentException { N.checkArgNotNull(handler, cs.handler); return register(ClassUtil.getCanonicalClassName(handler.getClass()), handler); } /** * Registers a handler instance with a specific qualifier string. * * @param qualifier the unique identifier for the handler. * @param handler the handler instance to register. * @return {@code true} if the handler was registered successfully, {@code false} if a handler with the same qualifier already exists. * @throws IllegalArgumentException if {@code qualifier} is empty or {@code handler} is {@code null}. */ public static boolean register(final String qualifier, final Handler<?> handler) throws IllegalArgumentException { N.checkArgNotEmpty(qualifier, cs.qualifier); N.checkArgNotNull(handler, cs.handler); if (handlerPool.containsKey(qualifier)) { return false; } handlerPool.put(qualifier, handler); return true; } /** * Retrieves a handler by its qualifier. It first checks the internal registry, and if not found, * it attempts to retrieve it from the Spring application context if available. * * @param qualifier the unique identifier for the handler. * @return the handler instance, or {@code null} if not found. * @throws IllegalArgumentException if {@code qualifier} is empty. */ public static Handler<?> get(final String qualifier) { //NOSONAR N.checkArgNotEmpty(qualifier, cs.qualifier); Handler<?> result = handlerPool.get(qualifier); if (result == null && springAppContext != null) { final Object bean = springAppContext.getBean(qualifier); if (bean instanceof Handler) { result = (Handler<?>) bean; handlerPool.put(qualifier, result); } } return result; } /** * Retrieves a handler by its class. It first checks the internal registry using the class's * canonical name as the qualifier. If not found, it attempts to retrieve it from the Spring * application context. * * @param handlerClass the class of the handler to retrieve. * @return the handler instance, or {@code null} if not found. * @throws IllegalArgumentException if {@code handlerClass} is {@code null}. */ public static Handler<?> get(final Class<? extends Handler<?>> handlerClass) { //NOSONAR N.checkArgNotNull(handlerClass, cs.handlerClass); final String qualifier = ClassUtil.getCanonicalClassName(handlerClass); Handler<?> result = handlerPool.get(qualifier); if (result == null && springAppContext != null) { result = springAppContext.getBean(handlerClass); if (result == null) { final Object bean = springAppContext.getBean(qualifier); if (bean instanceof Handler) { result = (Handler<?>) bean; } } if (result != null) { handlerPool.put(qualifier, result); } } return result; } /** * Retrieves a handler by its class. If the handler is not found in the registry or Spring context, * a new instance is created, registered, and returned. * * @param handlerClass the class of the handler to retrieve or create. * @return the existing or newly created handler instance. * @throws IllegalArgumentException if {@code handlerClass} is {@code null}. */ public static Handler<?> getOrCreate(final Class<? extends Handler<?>> handlerClass) { //NOSONAR N.checkArgNotNull(handlerClass, cs.handlerClass); Handler<?> result = get(handlerClass); if (result == null) { try { result = N.newInstance(handlerClass); if (result != null) { register(result); } } catch (final Throwable e) { // ignore } } return result; } /** * Creates a {@code Handler} with a custom action to be executed before method invocation. * * @param <T> proxy type * @param <E> exception type that action can throw * @param beforeInvokeAction the action to perform before the method is called. * @return a new {@code Handler} instance. * @throws IllegalArgumentException if {@code beforeInvokeAction} is {@code null}. */ public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction) throws IllegalArgumentException { N.checkArgNotNull(beforeInvokeAction, cs.beforeInvokeAction); return new Handler<>() { @Override public void beforeInvoke(final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { beforeInvokeAction.accept(targetObject, args, methodSignature); } }; } /** * Creates a {@code Handler} with a custom action to be executed after method invocation. * * @param <T> proxy type * @param <E> exception type that action can throw * @param afterInvokeAction the action to perform after the method returns. * @return a new {@code Handler} instance. * @throws IllegalArgumentException if {@code afterInvokeAction} is {@code null}. */ public static <T, E extends RuntimeException> Handler<T> create( final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException { N.checkArgNotNull(afterInvokeAction, cs.afterInvokeAction); return new Handler<>() { @Override public void afterInvoke(final Object result, final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { afterInvokeAction.accept(result, targetObject, args, methodSignature); } }; } /** * Creates a {@code Handler} with custom actions to be executed both before and after method invocation. * * @param <T> proxy type * @param <E> exception type that actions can throw * @param beforeInvokeAction the action to perform before the method is called. * @param afterInvokeAction the action to perform after the method returns. * @return a new {@code Handler} instance. * @throws IllegalArgumentException if either action is {@code null}. */ public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction, final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException { N.checkArgNotNull(beforeInvokeAction, cs.beforeInvokeAction); N.checkArgNotNull(afterInvokeAction, cs.afterInvokeAction); return new Handler<>() { @Override public void beforeInvoke(final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { beforeInvokeAction.accept(targetObject, args, methodSignature); } @Override public void afterInvoke(final Object result, final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { afterInvokeAction.accept(result, targetObject, args, methodSignature); } }; } private HandlerFactory() { // singleton. } } /** * An interface for caching the results of DAO method calls. Implementations can provide * various caching strategies (e.g., in-memory, distributed) to improve application performance. * * <p>The default cache key format is: {@code fullMethodName#tableName#jsonArrayOfParameters}.</p> * <p>Example: {@code com.example.UserDao.findById#users#[123]}</p> */ public interface DaoCache { /** * Creates a {@code DaoCache} with a specified capacity and eviction delay, backed by a {@code LocalCache}. * * @param capacity the maximum number of entries in the cache. * @param evictDelay the interval in milliseconds for the eviction scheduler to run. * @return a new {@code DaoCache} instance. */ static DaoCache create(final int capacity, final long evictDelay) { return new DefaultDaoCache(capacity, evictDelay); } /** * Creates a {@code DaoCache} backed by a simple {@code java.util.HashMap}. This cache does not * perform automatic eviction. * * @return a new {@code DaoCache} instance backed by a {@code HashMap}. */ static DaoCache createByMap() { return new DaoCacheByMap(); } /** * Creates a {@code DaoCache} backed by the provided {@code Map}. This allows for using custom * map implementations (e.g., {@code ConcurrentHashMap}) for caching. * * @param map the map to use for caching. * @return a new {@code DaoCache} instance backed by the provided map. */ static DaoCache createByMap(Map<String, Object> map) { return new DaoCacheByMap(map); } /** * Retrieves a cached result. The implementation can use the provided parameters to customize * the cache key generation if needed. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key (fullMethodName#tableName#jsonArrayOfParameters). * @param daoProxy the DAO proxy instance on which the method was called. * @param args the arguments passed to the method. * @param methodSignature a tuple containing method metadata. * @return the cached result, or {@code null} if not found. */ Object get(String defaultCacheKey, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); /** * Caches a result with default time-to-live (TTL) settings. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key. * @param result the method result to cache. * @param daoProxy the DAO proxy instance. * @param args the method arguments. * @param methodSignature a tuple containing method metadata. * @return {@code true} if the result was cached successfully. */ boolean put(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); /** * Caches a result with custom time-to-live (TTL) and idle time settings. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key. * @param result the method result to cache. * @param liveTime the maximum time in milliseconds the entry should live in the cache. * @param maxIdleTime the maximum time in milliseconds the entry can remain idle before being evicted. * @param daoProxy the DAO proxy instance. * @param args the method arguments. * @param methodSignature a tuple containing method metadata. * @return {@code true} if the result was cached successfully. */ boolean put(String defaultCacheKey, Object result, final long liveTime, final long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); /** * Updates the cache after a data modification operation (e.g., insert, update, delete). This method * is responsible for invalidating or clearing cache entries that may be affected by the operation. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key from the modification method. * @param result the result of the modification operation (e.g., number of rows affected). * @param daoProxy the DAO proxy instance. * @param args the arguments of the modification method. * @param methodSignature a tuple containing method metadata. */ void update(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); } /** * The default implementation of {@link DaoCache}, using a {@link KeyedObjectPool} for in-memory caching * with support for time-to-live (TTL) and idle time-based eviction. */ public static final class DefaultDaoCache implements DaoCache { private final KeyedObjectPool<String, PoolableWrapper<Object>> pool; /** * Creates a {@code DefaultDaoCache} with a specified capacity and eviction delay. * * @param capacity the maximum number of entries the cache can hold. * @param evictDelay the interval in milliseconds for the background eviction thread. */ public DefaultDaoCache(final int capacity, final long evictDelay) { pool = PoolFactory.createKeyedObjectPool(capacity, evictDelay); } @Override @SuppressWarnings("unused") public Object get(final String defaultCacheKey, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { final PoolableWrapper<Object> w = pool.get(defaultCacheKey); return w == null ? null : w.value(); } @Override @SuppressWarnings("unused") public boolean put(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { N.checkArgNotNull(defaultCacheKey, "Key cannot be null"); return pool.put(defaultCacheKey, Poolable.wrap(result, JdbcUtil.DEFAULT_CACHE_LIVE_TIME, JdbcUtil.DEFAULT_CACHE_MAX_IDLE_TIME)); } @Override public boolean put(String defaultCacheKey, Object result, long liveTime, long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { N.checkArgNotNull(defaultCacheKey, "Key cannot be null"); return pool.put(defaultCacheKey, Poolable.wrap(result, liveTime, maxIdleTime)); } /** * Implements cache invalidation. If the table name can be determined from the cache key, * it removes all cache entries associated with that table. Otherwise, it clears the entire cache. * No action is taken for update operations that affect zero rows. */ @Override @SuppressWarnings("unused") public void update(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { final Method method = methodSignature._1; if (JdbcUtil.BUILT_IN_DAO_UPDATE_METHODS.contains(method)) { if ((methodSignature._3.equals(int.class) || methodSignature._3.equals(long.class)) && (result != null && ((Number) result).longValue() == 0)) { return; } } final String updatedTableName = Strings.substringBetween(defaultCacheKey, JdbcUtil.CACHE_KEY_SPLITOR); if (Strings.isEmpty(updatedTableName)) { pool.clear(); } else { pool.keySet().stream().filter(k -> Strings.containsIgnoreCase(k, updatedTableName)).toList().forEach(pool::remove); } } } /** * A simple implementation of {@link DaoCache} that uses a standard {@code java.util.Map} * as the backing cache. It does not support automatic eviction or TTL. */ record DaoCacheByMap(Map<String, Object> cache) implements DaoCache { /** * Creates a {@code DaoCacheByMap} with a new {@code HashMap}. */ public DaoCacheByMap() { this(new HashMap<>()); } /** * Creates a {@code DaoCacheByMap} with a {@code HashMap} of a specified initial capacity. * * @param capacity the initial capacity for the backing {@code HashMap}. */ public DaoCacheByMap(final int capacity) { this(new HashMap<>(capacity)); } /** * Creates a {@code DaoCacheByMap} backed by a provided map instance. * * @param cache the map to be used for caching. */ DaoCacheByMap { } @Override @SuppressWarnings("unused") public Object get(final String defaultCacheKey, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { return cache.get(defaultCacheKey); } @Override @SuppressWarnings("unused") public boolean put(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { cache.put(defaultCacheKey, result); return true; } @Override public boolean put(String defaultCacheKey, Object result, long liveTime, long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { cache.put(defaultCacheKey, result); return true; } /** * Implements cache invalidation. If the table name can be determined from the cache key, * it removes all entries whose keys contain that table name. Otherwise, it clears the entire cache. * No action is taken for update operations that affect zero rows. */ @Override @SuppressWarnings("unused") public void update(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { final Method method = methodSignature._1; if (JdbcUtil.BUILT_IN_DAO_UPDATE_METHODS.contains(method)) { if ((methodSignature._3.equals(int.class) || methodSignature._3.equals(long.class)) && (result != null && ((Number) result).longValue() == 0)) { return; } } final String updatedTableName = Strings.substringBetween(defaultCacheKey, JdbcUtil.CACHE_KEY_SPLITOR); if (Strings.isEmpty(updatedTableName)) { cache.clear(); } else { cache.entrySet().removeIf(e -> Strings.containsIgnoreCase(e.getKey(), updatedTableName)); } } } }`
- **Parameters:**
  - (none)

### Class OutParamResult (com.landawn.abacus.jdbc.Jdbc.OutParamResult)
A container for the results of output parameters from a stored procedure execution.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### getOutParamValue(...) -> T
- **Signature:** `public <T> T getOutParamValue(final int parameterIndex)`
- **Summary:** Retrieves the value of an output parameter by its 1-based index.
- **Parameters:**
  - `parameterIndex` (`int`) — the 1-based index of the parameter.
- **Returns:** the parameter value, cast to type {@code T} . May be {@code null} .
- **Signature:** `public <T> T getOutParamValue(final String parameterName)`
- **Summary:** Retrieves the value of an output parameter by its name.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter.
- **Returns:** the parameter value, cast to type {@code T} . May be {@code null} .
##### getOutParamValues(...) -> Map<Object, Object>
- **Signature:** `public Map<Object, Object> getOutParamValues()`
- **Summary:** Returns a map containing all output parameter values.
- **Parameters:**
  - (none)
- **Returns:** an unmodifiable map of all output parameter values.
##### getOutParams(...) -> List<OutParam>
- **Signature:** `public List<OutParam> getOutParams()`
- **Summary:** Returns the list of {@link OutParam} definitions that were used to register the output parameters.
- **Parameters:**
  - (none)
- **Returns:** an unmodifiable list of {@code OutParam} objects.

### Interface Handler (com.landawn.abacus.jdbc.Jdbc.Handler)
A handler interface for intercepting method invocations on DAO proxies, similar to an Aspect-Oriented Programming (AOP) interceptor.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### beforeInvoke(...) -> void
- **Signature:** `@SuppressWarnings("unused") default void beforeInvoke(final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Summary:** This method is invoked before the actual DAO method is called.
- **Parameters:**
  - `proxy` (`P`) — the proxy instance on which the method was invoked.
  - `args` (`Object[]`) — the arguments passed to the method.
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`) — a tuple containing the {@code Method} object, a list of parameter types, and the return type.
##### afterInvoke(...) -> void
- **Signature:** `@SuppressWarnings("unused") default void afterInvoke(final Object result, final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Summary:** This method is invoked after the DAO method completes, whether successfully or with an exception.
- **Parameters:**
  - `result` (`Object`) — the value returned by the method. If the method's return type is void, this will be {@code null} .
  - `proxy` (`P`) — the proxy instance on which the method was invoked.
  - `args` (`Object[]`) — the arguments passed to the method.
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`) — a tuple containing the {@code Method} object, a list of parameter types, and the return type.

### Class HandlerFactory (com.landawn.abacus.jdbc.Jdbc.HandlerFactory)
A factory for creating and managing {@link Handler} instances.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### register(...) -> boolean
- **Signature:** `public static boolean register(final Class<? extends Handler<?>> handlerClass) throws IllegalArgumentException`
- **Summary:** Registers a handler by creating a new instance of the specified handler class.
- **Parameters:**
  - `handlerClass` (`Class<? extends Handler<?>>`) — the handler class to instantiate and register.
- **Returns:** {@code true} if the handler was registered successfully, {@code false} if a handler with the same name already exists.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code handlerClass} is {@code null} .
- **Signature:** `public static boolean register(final Handler<?> handler) throws IllegalArgumentException`
- **Summary:** Registers a handler instance.
- **Parameters:**
  - `handler` (`Handler<?>`) — the handler instance to register.
- **Returns:** {@code true} if the handler was registered successfully, {@code false} if a handler with the same name already exists.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code handler} is {@code null} .
- **Signature:** `public static boolean register(final String qualifier, final Handler<?> handler) throws IllegalArgumentException`
- **Summary:** Registers a handler instance with a specific qualifier string.
- **Parameters:**
  - `qualifier` (`String`) — the unique identifier for the handler.
  - `handler` (`Handler<?>`) — the handler instance to register.
- **Returns:** {@code true} if the handler was registered successfully, {@code false} if a handler with the same qualifier already exists.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code qualifier} is empty or {@code handler} is {@code null} .
##### get(...) -> Handler<?>
- **Signature:** `public static Handler<?> get(final String qualifier)`
- **Summary:** Retrieves a handler by its qualifier.
- **Contract:**
  - It first checks the internal registry, and if not found, it attempts to retrieve it from the Spring application context if available.
- **Parameters:**
  - `qualifier` (`String`) — the unique identifier for the handler.
- **Returns:** the handler instance, or {@code null} if not found.
- **Signature:** `public static Handler<?> get(final Class<? extends Handler<?>> handlerClass)`
- **Summary:** Retrieves a handler by its class.
- **Contract:**
  - If not found, it attempts to retrieve it from the Spring application context.
- **Parameters:**
  - `handlerClass` (`Class<? extends Handler<?>>`) — the class of the handler to retrieve.
- **Returns:** the handler instance, or {@code null} if not found.
##### getOrCreate(...) -> Handler<?>
- **Signature:** `public static Handler<?> getOrCreate(final Class<? extends Handler<?>> handlerClass)`
- **Summary:** Retrieves a handler by its class.
- **Contract:**
  - If the handler is not found in the registry or Spring context, a new instance is created, registered, and returned.
- **Parameters:**
  - `handlerClass` (`Class<? extends Handler<?>>`) — the class of the handler to retrieve or create.
- **Returns:** the existing or newly created handler instance.
##### create(...) -> Handler<T>
- **Signature:** `public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction) throws IllegalArgumentException`
- **Summary:** Creates a {@code Handler} with a custom action to be executed before method invocation.
- **Parameters:**
  - `beforeInvokeAction` (`Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>`) — the action to perform before the method is called.
- **Returns:** a new {@code Handler} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code beforeInvokeAction} is {@code null} .
- **Signature:** `public static <T, E extends RuntimeException> Handler<T> create( final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException`
- **Summary:** Creates a {@code Handler} with a custom action to be executed after method invocation.
- **Parameters:**
  - `afterInvokeAction` (`Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>`) — the action to perform after the method returns.
- **Returns:** a new {@code Handler} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code afterInvokeAction} is {@code null} .
- **Signature:** `public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction, final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException`
- **Summary:** Creates a {@code Handler} with custom actions to be executed both before and after method invocation.
- **Parameters:**
  - `beforeInvokeAction` (`Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>`) — the action to perform before the method is called.
  - `afterInvokeAction` (`Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>`) — the action to perform after the method returns.
- **Returns:** a new {@code Handler} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — if either action is {@code null} .

#### Public Instance Methods
- (none)

### Interface DaoCache (com.landawn.abacus.jdbc.Jdbc.DaoCache)
An interface for caching the results of DAO method calls.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### create(...) -> DaoCache
- **Signature:** `static DaoCache create(final int capacity, final long evictDelay)`
- **Summary:** Creates a {@code DaoCache} with a specified capacity and eviction delay, backed by a {@code LocalCache} .
- **Parameters:**
  - `capacity` (`int`) — the maximum number of entries in the cache.
  - `evictDelay` (`long`) — the interval in milliseconds for the eviction scheduler to run.
- **Returns:** a new {@code DaoCache} instance.
##### createByMap(...) -> DaoCache
- **Signature:** `static DaoCache createByMap()`
- **Summary:** Creates a {@code DaoCache} backed by a simple {@code java.util.HashMap} .
- **Parameters:**
  - (none)
- **Returns:** a new {@code DaoCache} instance backed by a {@code HashMap} .
- **Signature:** `static DaoCache createByMap(Map<String, Object> map)`
- **Summary:** Creates a {@code DaoCache} backed by the provided {@code Map} .
- **Parameters:**
  - `map` (`Map<String, Object>`) — the map to use for caching.
- **Returns:** a new {@code DaoCache} instance backed by the provided map.

#### Public Instance Methods
##### get(...) -> Object
- **Signature:** `Object get(String defaultCacheKey, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Summary:** Retrieves a cached result.
- **Contract:**
  - The implementation can use the provided parameters to customize the cache key generation if needed.
  - <p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments.
- **Parameters:**
  - `defaultCacheKey` (`String`) — the default cache key (fullMethodName#tableName#jsonArrayOfParameters).
  - `daoProxy` (`Object`) — the DAO proxy instance on which the method was called.
  - `args` (`Object[]`) — the arguments passed to the method.
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`) — a tuple containing method metadata.
- **Returns:** the cached result, or {@code null} if not found.
##### put(...) -> boolean
- **Signature:** `boolean put(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Summary:** Caches a result with default time-to-live (TTL) settings.
- **Contract:**
  - <p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments.
- **Parameters:**
  - `defaultCacheKey` (`String`) — the default cache key.
  - `result` (`Object`) — the method result to cache.
  - `daoProxy` (`Object`) — the DAO proxy instance.
  - `args` (`Object[]`) — the method arguments.
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`) — a tuple containing method metadata.
- **Returns:** {@code true} if the result was cached successfully.
- **Signature:** `boolean put(String defaultCacheKey, Object result, final long liveTime, final long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Summary:** Caches a result with custom time-to-live (TTL) and idle time settings.
- **Contract:**
  - <p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments.
- **Parameters:**
  - `defaultCacheKey` (`String`) — the default cache key.
  - `result` (`Object`) — the method result to cache.
  - `liveTime` (`long`) — the maximum time in milliseconds the entry should live in the cache.
  - `maxIdleTime` (`long`) — the maximum time in milliseconds the entry can remain idle before being evicted.
  - `daoProxy` (`Object`) — the DAO proxy instance.
  - `args` (`Object[]`) — the method arguments.
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`) — a tuple containing method metadata.
- **Returns:** {@code true} if the result was cached successfully.
##### update(...) -> void
- **Signature:** `void update(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Summary:** Updates the cache after a data modification operation (e.g., insert, update, delete).
- **Contract:**
  - <p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments.
- **Parameters:**
  - `defaultCacheKey` (`String`) — the default cache key from the modification method.
  - `result` (`Object`) — the result of the modification operation (e.g., number of rows affected).
  - `daoProxy` (`Object`) — the DAO proxy instance.
  - `args` (`Object[]`) — the arguments of the modification method.
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`) — a tuple containing method metadata.

### Class DefaultDaoCache (com.landawn.abacus.jdbc.Jdbc.DefaultDaoCache)
The default implementation of {@link DaoCache} , using a {@link KeyedObjectPool} for in-memory caching with support for time-to-live (TTL) and idle time-based eviction.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public DefaultDaoCache(final int capacity, final long evictDelay)`
- **Summary:** Creates a {@code DefaultDaoCache} with a specified capacity and eviction delay.
- **Parameters:**
  - `capacity` (`int`) — the maximum number of entries the cache can hold.
  - `evictDelay` (`long`) — the interval in milliseconds for the background eviction thread.
##### get(...) -> Object
- **Signature:** `@Override @SuppressWarnings("unused") public Object get(final String defaultCacheKey, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Parameters:**
  - `defaultCacheKey` (`String`)
  - `daoProxy` (`Object`)
  - `args` (`Object[]`)
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`)
- **Returns:** unspecified
##### put(...) -> boolean
- **Signature:** `@Override @SuppressWarnings("unused") public boolean put(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Parameters:**
  - `defaultCacheKey` (`String`)
  - `result` (`Object`)
  - `daoProxy` (`Object`)
  - `args` (`Object[]`)
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`)
- **Returns:** unspecified
- **Signature:** `@Override public boolean put(String defaultCacheKey, Object result, long liveTime, long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Parameters:**
  - `defaultCacheKey` (`String`)
  - `result` (`Object`)
  - `liveTime` (`long`)
  - `maxIdleTime` (`long`)
  - `daoProxy` (`Object`)
  - `args` (`Object[]`)
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`)
- **Returns:** unspecified
##### update(...) -> void
- **Signature:** `@Override @SuppressWarnings("unused") public void update(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)`
- **Summary:** Implements cache invalidation.
- **Contract:**
  - If the table name can be determined from the cache key, it removes all cache entries associated with that table.
- **Parameters:**
  - `defaultCacheKey` (`String`)
  - `result` (`Object`)
  - `daoProxy` (`Object`)
  - `args` (`Object[]`)
  - `methodSignature` (`Tuple3<Method, ImmutableList<Class<?>>, Class<?>>`)

### Class JdbcCodeGenerationUtil (com.landawn.abacus.jdbc.JdbcCodeGenerationUtil)
Utility class for generating JDBC-related code including entity classes and SQL statements.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### generateEntityClass(...) -> String
- **Signature:** `public static String generateEntityClass(final DataSource ds, final String tableName)`
- **Summary:** Generates an entity class for the specified table using default configuration.
- **Parameters:**
  - `ds` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the entity class
- **Returns:** The generated entity class as a string containing the complete Java source code
- **Signature:** `public static String generateEntityClass(final DataSource ds, final String tableName, final EntityCodeConfig config)`
- **Summary:** Generates an entity class for the specified table with custom configuration.
- **Parameters:**
  - `ds` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the entity class
  - `config` (`EntityCodeConfig`) — The configuration for customizing the generated entity class. If {@code null} , default configuration is used
- **Returns:** The generated entity class as a string containing the complete Java source code
- **Signature:** `public static String generateEntityClass(final DataSource ds, final String entityName, final String query)`
- **Summary:** Generates an entity class using a custom SQL query to determine the entity structure.
- **Parameters:**
  - `ds` (`DataSource`) — The data source to connect to the database
  - `entityName` (`String`) — The name of the entity class to generate
  - `query` (`String`) — The SQL query to execute for retrieving the table metadata. The query should return an empty result set
- **Returns:** The generated entity class as a string containing the complete Java source code
- **Signature:** `public static String generateEntityClass(final DataSource ds, final String entityName, final String query, final EntityCodeConfig config)`
- **Summary:** Generates an entity class using a custom SQL query and configuration.
- **Parameters:**
  - `ds` (`DataSource`) — The data source to connect to the database
  - `entityName` (`String`) — The name of the entity class to generate
  - `query` (`String`) — The SQL query to execute for retrieving the table metadata. The query should return an empty result set
  - `config` (`EntityCodeConfig`) — The configuration for customizing the generated entity class. If {@code null} , default configuration is used
- **Returns:** The generated entity class as a string containing the complete Java source code
- **Signature:** `public static String generateEntityClass(final Connection conn, final String tableName)`
- **Summary:** Generates an entity class for the specified table using an existing database connection.
- **Contract:**
  - This method is useful when you already have an open connection and want to avoid creating a new one.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the entity class
- **Returns:** The generated entity class as a string containing the complete Java source code
- **Signature:** `public static String generateEntityClass(final Connection conn, final String tableName, final EntityCodeConfig config)`
- **Summary:** Generates an entity class for the specified table using an existing connection and custom configuration.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the entity class
  - `config` (`EntityCodeConfig`) — The configuration for customizing the generated entity class. If {@code null} , default configuration is used
- **Returns:** The generated entity class as a string containing the complete Java source code
- **Signature:** `public static String generateEntityClass(final Connection conn, final String entityName, final String query)`
- **Summary:** Generates an entity class using an existing connection and a custom SQL query.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `entityName` (`String`) — The name of the entity class to generate
  - `query` (`String`) — The SQL query to execute for retrieving the table metadata. The query should return an empty result set
- **Returns:** The generated entity class as a string containing the complete Java source code
- **Signature:** `public static String generateEntityClass(final Connection conn, final String entityName, final String query, final EntityCodeConfig config)`
- **Summary:** Generates an entity class using an existing connection, custom SQL query, and configuration.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `entityName` (`String`) — The name of the entity class to generate
  - `query` (`String`) — The SQL query to execute for retrieving the table metadata. The query should return an empty result set
  - `config` (`EntityCodeConfig`) — The configuration for customizing the generated entity class. If {@code null} , default configuration is used
- **Returns:** The generated entity class as a string containing the complete Java source code
##### generateSelectSql(...) -> String
- **Signature:** `public static String generateSelectSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException`
- **Summary:** Generates a SELECT SQL statement for the specified table.
- **Contract:**
  - Column names are properly escaped with backticks if they contain special characters.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the SELECT statement
- **Returns:** A SELECT SQL statement string with all columns from the table
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateSelectSql(final Connection conn, final String tableName)`
- **Summary:** Generates a SELECT SQL statement for the specified table using an existing connection.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the SELECT statement
- **Returns:** A SELECT SQL statement string with all columns from the table
- **Signature:** `public static String generateSelectSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames, final String whereClause) throws UncheckedSQLException`
- **Summary:** Generates a SELECT SQL statement for the specified table, excluding certain columns and applying a WHERE clause.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the SELECT statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the SELECT statement
  - `whereClause` (`String`) — An optional WHERE clause to append to the SELECT statement (without the "WHERE" keyword)
- **Returns:** A SELECT SQL statement string with specified columns excluded and an optional WHERE clause
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateSelectSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames, final String whereClause) throws UncheckedSQLException`
- **Summary:** Generates a SELECT SQL statement for the specified table using an existing connection, excluding certain columns and applying a WHERE clause.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the SELECT statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the SELECT statement
  - `whereClause` (`String`) — An optional WHERE clause to append to the SELECT statement (without the "WHERE" keyword)
- **Returns:** A SELECT SQL statement string with specified columns excluded and an optional WHERE clause
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### generateInsertSql(...) -> String
- **Signature:** `public static String generateInsertSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException`
- **Summary:** Generates an INSERT SQL statement for the specified table.
- **Contract:**
  - Column names are properly escaped with backticks if they contain special characters.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the INSERT statement
- **Returns:** An INSERT SQL statement string with positional parameters for all columns
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateInsertSql(final Connection conn, final String tableName)`
- **Summary:** Generates an INSERT SQL statement for the specified table using an existing connection.
- **Contract:**
  - Column names are properly escaped with backticks if they contain special characters.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the INSERT statement
- **Returns:** An INSERT SQL statement string with positional parameters for all columns
- **Signature:** `public static String generateInsertSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames) throws UncheckedSQLException`
- **Summary:** Generates an INSERT SQL statement for the specified table, excluding certain columns.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the INSERT statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns
- **Returns:** An INSERT SQL statement string with positional parameters for all included columns
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs or the table cannot be queried
- **Signature:** `public static String generateInsertSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames)`
- **Summary:** Generates an INSERT SQL statement for the specified table, excluding certain columns.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the INSERT statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns
- **Returns:** An INSERT SQL statement string with positional parameters for all included columns
- **See also:** #generateInsertSql(Connection, String), #generateInsertSql(DataSource, String, Collection), #generateNamedInsertSql(Connection, String, Collection)
##### generateNamedInsertSql(...) -> String
- **Signature:** `public static String generateNamedInsertSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException`
- **Summary:** Generates a named INSERT SQL statement for the specified table.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the named INSERT statement
- **Returns:** An INSERT SQL statement string with named parameters based on camelCase column names
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateNamedInsertSql(final Connection conn, final String tableName)`
- **Summary:** Generates a named INSERT SQL statement for the specified table using an existing connection.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the named INSERT statement
- **Returns:** An INSERT SQL statement string with named parameters based on camelCase column names
- **Signature:** `public static String generateNamedInsertSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames) throws UncheckedSQLException`
- **Summary:** Generates a named INSERT SQL statement for the specified table, excluding certain columns.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the named INSERT statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns
- **Returns:** An INSERT SQL statement string with named parameters for all included columns
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs or the table cannot be queried
- **Signature:** `public static String generateNamedInsertSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames)`
- **Summary:** Generates a named INSERT SQL statement for the specified table using an existing connection, excluding certain columns.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the named INSERT statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns
- **Returns:** An INSERT SQL statement string with named parameters for all included columns
- **See also:** #generateNamedInsertSql(Connection, String), #generateNamedInsertSql(DataSource, String, Collection), #generateInsertSql(Connection, String, Collection)
##### generateUpdateSql(...) -> String
- **Signature:** `public static String generateUpdateSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException`
- **Summary:** Generates an UPDATE SQL statement for the specified table.
- **Contract:**
  - Note: Users should append an appropriate WHERE clause before executing.
  - No WHERE clause - must be added manually.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the UPDATE statement
- **Returns:** An UPDATE SQL statement string with positional parameters for all columns (no WHERE clause)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateUpdateSql(final Connection conn, final String tableName)`
- **Summary:** Generates an UPDATE SQL statement for the specified table using an existing connection.
- **Contract:**
  - Note: Users should append an appropriate WHERE clause before executing.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the UPDATE statement
- **Returns:** An UPDATE SQL statement string with positional parameters for all columns (no WHERE clause)
- **Signature:** `public static String generateUpdateSql(final DataSource dataSource, final String tableName, final String keyColumnName) throws UncheckedSQLException`
- **Summary:** Generates an UPDATE SQL statement for the specified table with a WHERE clause based on a single column.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the UPDATE statement
  - `keyColumnName` (`String`) — The column name to use in the WHERE clause
- **Returns:** An UPDATE SQL statement string with positional parameters for all columns and a WHERE clause
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateUpdateSql(final Connection conn, final String tableName, final String keyColumnName)`
- **Summary:** Generates an UPDATE SQL statement for the specified table with a WHERE clause based on a single column using an existing connection.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the UPDATE statement
  - `keyColumnName` (`String`) — The column name to use in the WHERE clause
- **Returns:** An UPDATE SQL statement string with positional parameters for all columns except the one in the WHERE clause
- **Signature:** `public static String generateUpdateSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause) throws UncheckedSQLException`
- **Summary:** Generates an UPDATE SQL statement for the specified table through a data source, excluding certain columns and applying WHERE conditions with an optional custom WHERE clause.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the UPDATE statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the SET clause. Can be {@code null} or empty
  - `keyColumnNames` (`Collection<String>`) — A collection of column names to use in the WHERE clause. Can be {@code null} or empty
  - `whereClause` (`String`) — An optional additional WHERE clause to append (without the "WHERE" keyword). Can be {@code null} or empty
- **Returns:** An UPDATE SQL statement string with positional parameters for SET clause and WHERE conditions
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs or the table cannot be queried
- **See also:** #generateUpdateSql(Connection, String, String), #generateUpdateSql(Connection, String, Collection, Collection, String), #generateNamedUpdateSql(DataSource, String, Collection, Collection, String)
- **Signature:** `public static String generateUpdateSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause)`
- **Summary:** Generates an UPDATE SQL statement for the specified table using an existing connection, excluding certain columns and applying WHERE conditions with an optional custom WHERE clause.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the UPDATE statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the SET clause. Can be {@code null} or empty
  - `keyColumnNames` (`Collection<String>`) — A collection of column names to use in the WHERE clause. Can be {@code null} or empty
  - `whereClause` (`String`) — An optional additional WHERE clause to append (without the "WHERE" keyword). Can be {@code null} or empty
- **Returns:** An UPDATE SQL statement string with positional parameters for SET clause and WHERE conditions
- **See also:** #generateUpdateSql(Connection, String, String), #generateUpdateSql(DataSource, String, Collection, Collection, String), #generateNamedUpdateSql(Connection, String, Collection, Collection, String)
##### generateNamedUpdateSql(...) -> String
- **Signature:** `public static String generateNamedUpdateSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException`
- **Summary:** Generates a named UPDATE SQL statement for the specified table.
- **Contract:**
  - Note: Users should append an appropriate WHERE clause before executing.
  - No WHERE clause - must be added manually.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the named UPDATE statement
- **Returns:** An UPDATE SQL statement string with named parameters based on camelCase column names (no WHERE clause)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateNamedUpdateSql(final Connection conn, final String tableName)`
- **Summary:** Generates a named UPDATE SQL statement for the specified table using an existing connection.
- **Contract:**
  - Note: Users should append an appropriate WHERE clause before executing.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the named UPDATE statement
- **Returns:** An UPDATE SQL statement string with named parameters based on camelCase column names (no WHERE clause)
- **Signature:** `public static String generateNamedUpdateSql(final DataSource dataSource, final String tableName, final String keyColumnName) throws UncheckedSQLException`
- **Summary:** Generates a named UPDATE SQL statement for the specified table with a WHERE clause based on a single column.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the named UPDATE statement
  - `keyColumnName` (`String`) — The column name to use in the WHERE clause
- **Returns:** An UPDATE SQL statement string with named parameters and a WHERE clause based on camelCase column names
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `public static String generateNamedUpdateSql(final Connection conn, final String tableName, final String keyColumnName)`
- **Summary:** Generates a named UPDATE SQL statement for the specified table with a WHERE clause based on a single column using an existing connection.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the named UPDATE statement
  - `keyColumnName` (`String`) — The column name to use in the WHERE clause
- **Returns:** An UPDATE SQL statement string with named parameters and a WHERE clause based on camelCase column names
- **Signature:** `public static String generateNamedUpdateSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause) throws UncheckedSQLException`
- **Summary:** Generates a named UPDATE SQL statement for the specified table through a data source, excluding certain key columns and applying WHERE conditions with an optional custom WHERE clause.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `tableName` (`String`) — The name of the table for which to generate the named UPDATE statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the SET clause. Can be {@code null} or empty
  - `keyColumnNames` (`Collection<String>`) — A collection of column names to use in the WHERE clause. Can be {@code null} or empty
  - `whereClause` (`String`) — An optional additional WHERE clause to append (without the "WHERE" keyword). Can be {@code null} or empty
- **Returns:** An UPDATE SQL statement string with named parameters for SET clause and WHERE conditions
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs or the table cannot be queried
- **Signature:** `public static String generateNamedUpdateSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause)`
- **Summary:** Generates a named UPDATE SQL statement for the specified table using an existing connection, excluding certain key columns and applying WHERE conditions with an optional custom WHERE clause.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use
  - `tableName` (`String`) — The name of the table for which to generate the UPDATE statement
  - `excludedColumnNames` (`Collection<String>`) — A collection of column names to exclude from the SET clause. Can be {@code null} or empty
  - `keyColumnNames` (`Collection<String>`) — A collection of column names to use in the WHERE clause. Can be {@code null} or empty
  - `whereClause` (`String`) — An optional additional WHERE clause to append (without the "WHERE" keyword). Can be {@code null} or empty
- **Returns:** An UPDATE SQL statement string with named parameters for SET clause and WHERE conditions
- **See also:** #generateNamedUpdateSql(Connection, String, String), #generateNamedUpdateSql(DataSource, String, Collection, Collection, String), #generateUpdateSql(Connection, String, Collection, Collection, String)
##### convertInsertSqlToUpdateSql(...) -> String
- **Signature:** `@Beta public static String convertInsertSqlToUpdateSql(final DataSource dataSource, final String insertSql)`
- **Summary:** Converts an INSERT SQL statement to an UPDATE SQL statement.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `insertSql` (`String`) — The INSERT SQL statement to convert
- **Returns:** An UPDATE SQL statement derived from the INSERT statement
- **Signature:** `@Beta public static String convertInsertSqlToUpdateSql(final DataSource dataSource, final String insertSql, final String whereClause)`
- **Summary:** Converts an INSERT SQL statement to an UPDATE SQL statement with a specified WHERE clause.
- **Parameters:**
  - `dataSource` (`DataSource`) — The data source to connect to the database
  - `insertSql` (`String`) — The INSERT SQL statement to convert
  - `whereClause` (`String`) — The WHERE clause to append to the UPDATE statement (without the WHERE keyword)
- **Returns:** An UPDATE SQL statement derived from the INSERT statement with the specified WHERE clause

#### Public Instance Methods
- (none)

### Class EntityCodeConfig (com.landawn.abacus.jdbc.JdbcCodeGenerationUtil.EntityCodeConfig)
Configuration class for customizing entity code generation.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `class EntityCodeConfig { /** * The source directory where the generated entity class file will be saved. * If specified, the generated class will be written to this directory following the package structure. * Example: "./src/main/java" */ private String srcDir; /** * The package name for the generated entity class. * Example: "com.example.entity" */ private String packageName; /** * The class name for the generated entity. * If not specified, it will be derived from the table name using camelCase conversion. */ private String className; /** * Function to convert database column names to Java field names. * First parameter is entity/table name, second is column name. * Default implementation converts column names to camelCase. * Example: (tableName, columnName) -> Strings.toCamelCase(columnName) */ private BiFunction<String, String, String> fieldNameConverter; /** * Function to convert database column types to Java field types. * Parameters: entity/table name, field name, column name, column class name (from ResultSetMetaData). * Example: (entity, field, column, className) -> className.replace("java.lang.", "") */ private QuadFunction<String, String, String, String, String> fieldTypeConverter; /** * List of customized field mappings. * Each tuple contains: (column name, field name, field class). * Allows overriding default field names and types for specific columns. */ private List<Tuple3<String, String, Class<?>>> customizedFields; /** * List of customized database type annotations. * Each tuple contains: (field name, database type). * Used to generate @Type annotations for special database types. */ private List<Tuple2<String, String>> customizedFieldDbTypes; /** * Whether to use boxed types (Integer, Long, etc.) instead of primitives (int, long, etc.). * Default is {@code false} (uses primitives where possible). */ private boolean useBoxedType; private boolean mapBigIntegerToLong; private boolean mapBigDecimalToDouble; private Collection<String> readOnlyFields; private Collection<String> nonUpdatableFields; private Collection<String> idFields; private String idField; private Collection<String> excludedFields; private String additionalFieldsOrLines; private List<String> classNamesToImport; private Class<? extends Annotation> tableAnnotationClass; private Class<? extends Annotation> columnAnnotationClass; private Class<? extends Annotation> idAnnotationClass; private boolean chainAccessor; private boolean generateBuilder; private boolean generateCopyMethod; private boolean generateFieldNameTable; private boolean extendFieldNameTableClassName; // private String fieldNameTableClassName; // Always be "NT"; // private List<Tuple2<String, String>> customizedJsonFields; @Beta private JsonXmlConfig jsonXmlConfig; /** * Configuration for JSON and XML serialization/deserialization settings. * * <p>This class allows customization of how entity fields are serialized to * and deserialized from JSON and XML formats. It includes settings for naming * conventions, field filtering, date/time formatting, and enum handling.</p> * * <p>This feature is marked as {@code @Beta} and may be subject to changes * in future releases.</p> */ @Builder @Data @AllArgsConstructor @Accessors(chain = true) public static class JsonXmlConfig { private NamingPolicy namingPolicy; private String ignoredFields; private String dateFormat; private String timeZone; private String numberFormat; private EnumType enumerated; /** * Constructs a new JsonXmlConfig instance with default values. */ public JsonXmlConfig() { } } } }`
- **Parameters:**
  - (none)

### Class JsonXmlConfig (com.landawn.abacus.jdbc.JdbcCodeGenerationUtil.EntityCodeConfig.JsonXmlConfig)
Configuration for JSON and XML serialization/deserialization settings.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### <init>(...) -> void
- **Signature:** `public JsonXmlConfig()`
- **Summary:** Constructs a new JsonXmlConfig instance with default values.
- **Parameters:**
  - (none)

### Class JdbcUtil (com.landawn.abacus.jdbc.JdbcUtil)
A comprehensive, production-ready utility class providing enterprise-grade JDBC operations with advanced database access patterns, transaction management, and performance optimization features.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### getDBProductInfo(...) -> DBProductInfo
- **Signature:** `public static DBProductInfo getDBProductInfo(final javax.sql.DataSource ds) throws UncheckedSQLException`
- **Summary:** Retrieves the database product information from the given DataSource.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code DataSource dataSource = ...; // Obtain a DataSource instance DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(dataSource); System.out.println("Database Product Name: " + dbInfo.productName()); System.out.println("Database Product Version: " + dbInfo.productVersion()); // Perform actions based on the database type if (dbInfo.version().isPostgreSQL()) { System.out.println("This is a PostgreSQL database."); } else if (dbInfo.version() == DBVersion.MySQL_8) { System.out.println("This is MySQL version 8."); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource from which to obtain a database connection.
- **Returns:** A {@link DBProductInfo} object containing the database product name, version, and type.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs while trying to connect to the database.
- **See also:** #getDBProductInfo(Connection), DBProductInfo, DBVersion
- **Signature:** `public static DBProductInfo getDBProductInfo(final Connection conn) throws UncheckedSQLException`
- **Summary:** Retrieves the database product information from the given {@link Connection} .
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Connection connection = ...; // Obtain a database Connection DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(connection); System.out.println("Database Name: " + dbInfo.productName()); System.out.println("Database Version: " + dbInfo.productVersion()); // Example of checking for a specific database version if (dbInfo.version() == DBVersion.Oracle) { System.out.println("Connected to an Oracle database."); } } </pre>
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use for retrieving metadata. It must be an active connection.
- **Returns:** A {@link DBProductInfo} object containing the database product name, version, and a standardized {@link DBVersion} enum.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs while retrieving metadata.
- **See also:** #getDBProductInfo(javax.sql.DataSource), DatabaseMetaData
##### createHikariDataSource(...) -> javax.sql.DataSource
- **Signature:** `public static javax.sql.DataSource createHikariDataSource(final String url, final String user, final String password)`
- **Summary:** Creates a {@code HikariDataSource} with the specified database connection details.
- **Parameters:**
  - `url` (`String`) — The JDBC URL for the database connection (e.g., "jdbc:mysql://localhost:3306/mydb").
  - `user` (`String`) — The username for database authentication.
  - `password` (`String`) — The password for database authentication.
- **Returns:** A {@code javax.sql.DataSource} instance configured with HikariCP.
- **See also:** #createHikariDataSource(String, String, String, int, int), com.zaxxer.hikari.HikariDataSource
- **Signature:** `public static javax.sql.DataSource createHikariDataSource(final String url, final String user, final String password, final int minIdle, final int maxPoolSize)`
- **Summary:** Creates a {@code HikariDataSource} with specified connection details and pool size configuration.
- **Parameters:**
  - `url` (`String`) — The JDBC URL for the database connection.
  - `user` (`String`) — The username for database authentication.
  - `password` (`String`) — The password for database authentication.
  - `minIdle` (`int`) — The minimum number of idle connections that HikariCP tries to maintain in the pool.
  - `maxPoolSize` (`int`) — The maximum number of connections that can be in the pool, including both idle and in-use connections.
- **Returns:** A {@code javax.sql.DataSource} instance configured with HikariCP and custom pool settings.
- **See also:** #createHikariDataSource(String, String, String), com.zaxxer.hikari.HikariConfig
##### createC3p0DataSource(...) -> javax.sql.DataSource
- **Signature:** `@Beta public static javax.sql.DataSource createC3p0DataSource(final String url, final String user, final String password)`
- **Summary:** Creates a C3P0 {@code ComboPooledDataSource} with the specified database connection details.
- **Parameters:**
  - `url` (`String`) — The JDBC URL for the database connection.
  - `user` (`String`) — The username for database authentication.
  - `password` (`String`) — The password for database authentication.
- **Returns:** A {@code javax.sql.DataSource} instance configured with C3P0.
- **See also:** #createC3p0DataSource(String, String, String, int, int), com.mchange.v2.c3p0.ComboPooledDataSource
- **Signature:** `@Beta public static javax.sql.DataSource createC3p0DataSource(final String url, final String user, final String password, final int minPoolSize, final int maxPoolSize)`
- **Summary:** Creates a C3P0 {@code ComboPooledDataSource} with specified connection details and pool size configuration.
- **Parameters:**
  - `url` (`String`) — The JDBC URL for the database connection.
  - `user` (`String`) — The username for database authentication.
  - `password` (`String`) — The password for database authentication.
  - `minPoolSize` (`int`) — The minimum number of connections the pool will maintain.
  - `maxPoolSize` (`int`) — The maximum number of connections the pool will allow.
- **Returns:** A {@code javax.sql.DataSource} instance configured with C3P0 and custom pool settings.
- **See also:** #createC3p0DataSource(String, String, String), com.mchange.v2.c3p0.ComboPooledDataSource
##### createConnection(...) -> Connection
- **Signature:** `public static Connection createConnection(final String url, final String user, final String password) throws UncheckedSQLException`
- **Summary:** Creates a new database {@link Connection} using the specified URL, username, and password.
- **Parameters:**
  - `url` (`String`) — The JDBC URL for the database connection (e.g., "jdbc:mysql://localhost:3306/mydb").
  - `user` (`String`) — The username for database authentication.
  - `password` (`String`) — The password for database authentication.
- **Returns:** A new {@link Connection} object.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs or the driver cannot be determined from the URL.
- **See also:** #createConnection(String, String, String, String), DriverManager#getConnection(String, String, String)
- **Signature:** `public static Connection createConnection(final String driverClass, final String url, final String user, final String password) throws UncheckedSQLException`
- **Summary:** Creates a new database {@link Connection} using an explicitly specified driver class.
- **Contract:**
  - This method is useful when the JDBC driver cannot be automatically determined from the URL or when a specific driver version needs to be enforced.
- **Parameters:**
  - `driverClass` (`String`) — The fully qualified name of the JDBC driver class (e.g., "com.mysql.cj.jdbc.Driver").
  - `url` (`String`) — The JDBC URL for the database connection.
  - `user` (`String`) — The username for database authentication.
  - `password` (`String`) — The password for database authentication.
- **Returns:** A new {@link Connection} object.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs or the specified driver class is not found.
- **See also:** #createConnection(Class, String, String, String)
- **Signature:** `public static Connection createConnection(final Class<? extends Driver> driverClass, final String url, final String user, final String password) throws UncheckedSQLException`
- **Summary:** Creates a new database {@link Connection} using a type-safe {@link Driver} class.
- **Parameters:**
  - `driverClass` (`Class<? extends Driver>`) — The JDBC {@link Driver} class (e.g., {@code com.mysql.cj.jdbc.Driver.class} ).
  - `url` (`String`) — The JDBC URL for the database connection.
  - `user` (`String`) — The username for database authentication.
  - `password` (`String`) — The password for database authentication.
- **Returns:** A new {@link Connection} object.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during connection creation.
- **See also:** #createConnection(String, String, String, String), DriverManager#registerDriver(Driver)
##### getConnection(...) -> Connection
- **Signature:** `public static Connection getConnection(final javax.sql.DataSource ds) throws UncheckedSQLException`
- **Summary:** Retrieves a {@link Connection} from the specified {@link javax.sql.DataSource} .
- **Contract:**
  - If a transaction is active, it returns the connection associated with the current transaction.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} from which to obtain a connection.
- **Returns:** A {@link Connection} object.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs.
- **See also:** #releaseConnection(Connection, javax.sql.DataSource), org.springframework.jdbc.datasource.DataSourceUtils#getConnection(javax.sql.DataSource)
##### releaseConnection(...) -> void
- **Signature:** `public static void releaseConnection(final Connection conn, final javax.sql.DataSource ds)`
- **Summary:** Releases the given {@link Connection} back to the {@link javax.sql.DataSource} .
- **Contract:**
  - If no transaction is active, it closes the connection.
  - perform database work } finally { // This ensures the connection is always released, even if an error occurs.
- **Parameters:**
  - `conn` (`Connection`) — The {@link Connection} to be released. Can be {@code null} , in which case the method does nothing.
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} from which the connection was obtained.
- **See also:** #getConnection(javax.sql.DataSource), org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection(Connection, javax.sql.DataSource)
##### close(...) -> void
- **Signature:** `public static void close(final ResultSet rs) throws UncheckedSQLException`
- **Summary:** Closes the specified {@link ResultSet} .
- **Contract:**
  - However, if manual closing is necessary, this method can be used in a {@code finally} block.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. If {@code null} , the method does nothing.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #closeQuietly(ResultSet)
- **Signature:** `public static void close(final ResultSet rs, final boolean closeStatement) throws UncheckedSQLException`
- **Summary:** Closes the specified {@link ResultSet} and, optionally, its associated {@link Statement} .
- **Contract:**
  - This is useful when the {@code Statement} is created and used only for a single {@code ResultSet} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. If {@code null} , no action is taken.
  - `closeStatement` (`boolean`) — If {@code true} , the {@link Statement} that created the {@code ResultSet} will also be closed.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #close(ResultSet, boolean, boolean), #closeQuietly(ResultSet, boolean)
- **Signature:** `public static void close(final ResultSet rs, final boolean closeStatement, final boolean closeConnection) throws IllegalArgumentException, UncheckedSQLException`
- **Summary:** Closes a {@link ResultSet} , and optionally the associated {@link Statement} and {@link Connection} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
  - `closeStatement` (`boolean`) — If {@code true} , the {@link Statement} from the {@code ResultSet} is also closed.
  - `closeConnection` (`boolean`) — If {@code true} , the {@link Connection} from the {@code Statement} is also closed. This requires {@code closeStatement} to be {@code true} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code closeConnection} is {@code true} but {@code closeStatement} is {@code false} .
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #closeQuietly(ResultSet, boolean, boolean)
- **Signature:** `public static void close(final Statement stmt) throws UncheckedSQLException`
- **Summary:** Closes the specified {@link Statement} .
- **Parameters:**
  - `stmt` (`Statement`) — The {@link Statement} to close. If {@code null} , the method does nothing.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #closeQuietly(Statement)
- **Signature:** `@Deprecated public static void close(final Connection conn) throws UncheckedSQLException`
- **Summary:** Closes the specified {@link Connection} .
- **Parameters:**
  - `conn` (`Connection`) — The {@link Connection} to close. If {@code null} , the method does nothing.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #releaseConnection(Connection, javax.sql.DataSource), #closeQuietly(Connection)
- **Signature:** `public static void close(final ResultSet rs, final Statement stmt) throws UncheckedSQLException`
- **Summary:** Closes the specified {@link ResultSet} and {@link Statement} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
  - `stmt` (`Statement`) — The {@link Statement} to close. Can be {@code null} .
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #closeQuietly(ResultSet, Statement)
- **Signature:** `public static void close(final Statement stmt, final Connection conn) throws UncheckedSQLException`
- **Summary:** Closes the specified {@link Statement} and {@link Connection} .
- **Parameters:**
  - `stmt` (`Statement`) — The {@link Statement} to close. Can be {@code null} .
  - `conn` (`Connection`) — The {@link Connection} to close. Can be {@code null} .
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #closeQuietly(Statement, Connection), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static void close(final ResultSet rs, final Statement stmt, final Connection conn) throws UncheckedSQLException`
- **Summary:** Closes the specified {@link ResultSet} , {@link Statement} , and {@link Connection} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
  - `stmt` (`Statement`) — The {@link Statement} to close. Can be {@code null} .
  - `conn` (`Connection`) — The {@link Connection} to close. Can be {@code null} .
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If a database access error occurs during closing.
- **See also:** #closeQuietly(ResultSet, Statement, Connection)
##### closeQuietly(...) -> void
- **Signature:** `public static void closeQuietly(final ResultSet rs)`
- **Summary:** Unconditionally closes a {@link ResultSet} , ignoring any {@code SQLException} that occurs.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
- **See also:** #close(ResultSet)
- **Signature:** `public static void closeQuietly(final ResultSet rs, final boolean closeStatement) throws UncheckedSQLException`
- **Summary:** Unconditionally closes a {@link ResultSet} and, optionally, its associated {@link Statement} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
  - `closeStatement` (`boolean`) — If {@code true} , the {@link Statement} associated with the {@code ResultSet} will also be closed quietly.
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — If retrieving the {@code Statement} from the {@code ResultSet} fails.
- **See also:** #close(ResultSet, boolean)
- **Signature:** `public static void closeQuietly(final ResultSet rs, final boolean closeStatement, final boolean closeConnection) throws IllegalArgumentException`
- **Summary:** Unconditionally closes a {@link ResultSet} and, optionally, its associated {@link Statement} and {@link Connection} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
  - `closeStatement` (`boolean`) — If {@code true} , the associated {@link Statement} is also closed quietly.
  - `closeConnection` (`boolean`) — If {@code true} , the associated {@link Connection} is also closed quietly. Requires {@code closeStatement} to be {@code true} .
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code closeConnection} is {@code true} but {@code closeStatement} is {@code false} .
- **See also:** #close(ResultSet, boolean, boolean)
- **Signature:** `public static void closeQuietly(final Statement stmt)`
- **Summary:** Unconditionally closes a {@link Statement} , ignoring any {@code SQLException} that occurs.
- **Parameters:**
  - `stmt` (`Statement`) — The {@link Statement} to close. Can be {@code null} .
- **See also:** #close(Statement)
- **Signature:** `@Deprecated public static void closeQuietly(final Connection conn)`
- **Summary:** Unconditionally closes a {@link Connection} , ignoring any {@code SQLException} .
- **Parameters:**
  - `conn` (`Connection`) — The {@link Connection} to close. Can be {@code null} .
- **See also:** #releaseConnection(Connection, javax.sql.DataSource), #close(Connection)
- **Signature:** `public static void closeQuietly(final ResultSet rs, final Statement stmt)`
- **Summary:** Unconditionally closes a {@link ResultSet} and a {@link Statement} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
  - `stmt` (`Statement`) — The {@link Statement} to close. Can be {@code null} .
- **See also:** #close(ResultSet, Statement)
- **Signature:** `public static void closeQuietly(final Statement stmt, final Connection conn)`
- **Summary:** Unconditionally closes a {@link Statement} and a {@link Connection} .
- **Contract:**
  - This is primarily for cleanup in {@code finally} blocks when not using a {@code DataSource} .
- **Parameters:**
  - `stmt` (`Statement`) — The {@link Statement} to close. Can be {@code null} .
  - `conn` (`Connection`) — The {@link Connection} to close. Can be {@code null} .
- **See also:** #close(Statement, Connection), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static void closeQuietly(final ResultSet rs, final Statement stmt, final Connection conn)`
- **Summary:** Unconditionally closes a {@link ResultSet} , a {@link Statement} , and a {@link Connection} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to close. Can be {@code null} .
  - `stmt` (`Statement`) — The {@link Statement} to close. Can be {@code null} .
  - `conn` (`Connection`) — The {@link Connection} to close. Can be {@code null} .
- **See also:** #close(ResultSet, Statement, Connection)
##### skip(...) -> int
- **Signature:** `public static int skip(final ResultSet rs, final int rowsToSkip) throws SQLException`
- **Summary:** Skips a specified number of rows in a {@link ResultSet} .
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code ResultSet rs = statement.executeQuery("SELECT * FROM users"); // Skip the first 10 users int skippedRows = JdbcUtil.skip(rs, 10); if (skippedRows == 10) { // Now processing from the 11th user if (rs.next()) { // ...
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to skip rows in.
  - `rowsToSkip` (`int`) — The number of rows to skip.
- **Returns:** The number of rows actually skipped, which may be less than {@code rowsToSkip} if the end of the {@code ResultSet} is reached.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs or the result set type is {@code TYPE_FORWARD_ONLY} .
- **See also:** #skip(ResultSet, long)
- **Signature:** `public static int skip(final ResultSet rs, long rowsToSkip) throws SQLException`
- **Summary:** Skips a specified number of rows in a {@link ResultSet} , supporting a {@code long} count.
- **Contract:**
  - It attempts to use {@link ResultSet#absolute(int)} for scrollable result sets and falls back to manual iteration for forward-only result sets or when {@code absolute()} is not supported by the driver.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to skip rows in.
  - `rowsToSkip` (`long`) — The number of rows to skip.
- **Returns:** The number of rows actually skipped.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** ResultSet#absolute(int)
##### getColumnCount(...) -> int
- **Signature:** `public static int getColumnCount(final ResultSet rs) throws SQLException`
- **Summary:** Returns the number of columns in a {@link ResultSet} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to get the column count from.
- **Returns:** The number of columns in the result set.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** ResultSet#getMetaData(), ResultSetMetaData#getColumnCount()
##### getColumnNameList(...) -> List<String>
- **Signature:** `public static List<String> getColumnNameList(final Connection conn, final String tableName) throws SQLException`
- **Summary:** Returns an ordered list of column names for a specified table.
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use.
  - `tableName` (`String`) — The name of the table for which to retrieve column names.
- **Returns:** A {@link List} of column names in the order they are defined in the table.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs or the table does not exist.
- **See also:** #getColumnLabelList(ResultSet)
##### getColumnLabelList(...) -> List<String>
- **Signature:** `public static List<String> getColumnLabelList(final ResultSet rs) throws SQLException`
- **Summary:** Returns an ordered list of column labels from a {@link ResultSet} .
- **Contract:**
  - If a column has no explicit label, its name is returned instead.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} from which to retrieve column labels.
- **Returns:** A {@link List} of column labels in the order they appear in the {@code ResultSet} .
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #getColumnNameList(Connection, String), ResultSetMetaData#getColumnLabel(int)
##### getColumnLabel(...) -> String
- **Signature:** `public static String getColumnLabel(final ResultSetMetaData rsmd, final int columnIndex) throws SQLException`
- **Summary:** Returns the column label for a specified column index from {@link ResultSetMetaData} .
- **Contract:**
  - This method prioritizes the column label, but falls back to the column name if the label is {@code null} or empty.
  - This is useful for consistently getting a meaningful name for a column, especially when aliases are used.
- **Parameters:**
  - `rsmd` (`ResultSetMetaData`) — The {@link ResultSetMetaData} to get the label from.
  - `columnIndex` (`int`) — The 1-based index of the column.
- **Returns:** The column label if available; otherwise, the column name.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** ResultSetMetaData#getColumnLabel(int), ResultSetMetaData#getColumnName(int)
##### getColumnIndex(...) -> int
- **Signature:** `public static int getColumnIndex(final ResultSet resultSet, final String columnName) throws SQLException`
- **Summary:** Returns the 1-based index of a column in a {@link ResultSet} given its name.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // For a query: "SELECT user_id, user_name AS name FROM users" ResultSet rs = ...; int indexByName = JdbcUtil.getColumnIndex(rs, "user_id"); // Returns 1 int indexByLabel = JdbcUtil.getColumnIndex(rs, "name"); // Returns 2 int caseInsensitiveIndex = JdbcUtil.getColumnIndex(rs, "USERNAME"); // Still returns 2 if "user_name" is the original name int notFoundIndex = JdbcUtil.getColumnIndex(rs, "email"); // Returns -1 } </pre>
- **Parameters:**
  - `resultSet` (`ResultSet`) — The {@link ResultSet} to search within.
  - `columnName` (`String`) — The name or label of the column to find.
- **Returns:** The 1-based index of the column, or -1 if not found.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #getColumnIndex(ResultSetMetaData, String)
- **Signature:** `public static int getColumnIndex(final ResultSetMetaData rsmd, final String columnName) throws SQLException`
- **Summary:** Returns the 1-based index of a column from {@link ResultSetMetaData} given its name.
- **Parameters:**
  - `rsmd` (`ResultSetMetaData`) — The {@link ResultSetMetaData} to search within.
  - `columnName` (`String`) — The name or label of the column to find.
- **Returns:** The 1-based index of the column, or -1 if not found.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #getColumnIndex(ResultSet, String)
##### getColumnValue(...) -> Object
- **Signature:** `public static Object getColumnValue(final ResultSet rs, final int columnIndex) throws SQLException`
- **Summary:** Retrieves the value of a specified column in the current row of a {@link ResultSet} .
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} from which to retrieve the value.
  - `columnIndex` (`int`) — The 1-based index of the column.
- **Returns:** The column value as a standard Java object. {@link Blob} is returned as {@code byte\[\]} , {@link Clob} as {@code String} .
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #getColumnValue(ResultSet, String)
- **Signature:** `@Deprecated public static Object getColumnValue(final ResultSet rs, final String columnLabel) throws SQLException`
- **Summary:** Retrieves the value of a specified column in the current row of a {@link ResultSet} by its label.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} from which to retrieve the value.
  - `columnLabel` (`String`) — The label of the column to retrieve.
- **Returns:** The value of the specified column.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #getColumnValue(ResultSet, int), #getColumnIndex(ResultSet, String)
- **Signature:** `public static <T> T getColumnValue(final ResultSet rs, final int columnIndex, final Class<? extends T> targetClass) throws SQLException`
- **Summary:** Retrieves the value of a specified column in the current row of a {@link ResultSet} and converts it to the given target type.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} from which to retrieve the value.
  - `columnIndex` (`int`) — The 1-based index of the column.
  - `targetClass` (`Class<? extends T>`) — The {@link Class} of the desired type {@code T} .
- **Returns:** The column value, converted to the specified {@code targetClass} .
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #getColumnValue(ResultSet, String, Class)
- **Signature:** `@Deprecated public static <T> T getColumnValue(final ResultSet rs, final String columnLabel, final Class<? extends T> targetClass) throws SQLException`
- **Summary:** Retrieves the value of a specified column by its label and converts it to the given target type.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} from which to retrieve the value.
  - `columnLabel` (`String`) — The label of the column to retrieve.
  - `targetClass` (`Class<? extends T>`) — The {@link Class} of the desired type {@code T} .
- **Returns:** The column value, converted to the specified {@code targetClass} .
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
##### getAllColumnValues(...) -> List<T>
- **Signature:** `public static <T> List<T> getAllColumnValues(final ResultSet rs, final int columnIndex) throws SQLException`
- **Summary:** Retrieves all values from a single column of a {@link ResultSet} and returns them as a list.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to retrieve values from. It will be iterated to the end.
  - `columnIndex` (`int`) — The 1-based index of the column to retrieve.
- **Returns:** A {@link List} containing all values from the specified column.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **Signature:** `public static <T> List<T> getAllColumnValues(final ResultSet rs, final String columnLabel) throws SQLException`
- **Summary:** Retrieves all values from a single column of a {@link ResultSet} by its label and returns them as a list.
- **Parameters:**
  - `rs` (`ResultSet`) — The {@link ResultSet} to retrieve values from. It will be iterated to the end.
  - `columnLabel` (`String`) — The label of the column to retrieve.
- **Returns:** A {@link List} containing all values from the specified column.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
##### getColumn2FieldNameMap(...) -> ImmutableMap<String, String>
- **Signature:** `public static ImmutableMap<String, String> getColumn2FieldNameMap(final Class<?> entityClass)`
- **Summary:** Retrieves a mapping from database column names to entity field names for a given entity class.
- **Parameters:**
  - `entityClass` (`Class<?>`) — The entity class to analyze for column-to-field mappings.
- **Returns:** An {@link ImmutableMap} where keys are database column names and values are the corresponding entity field names.
- **See also:** com.landawn.abacus.annotation.Column, com.landawn.abacus.util.NamingPolicy
##### prepareQuery(...) -> PreparedQuery
- **Signature:** `public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query for execution, returning a {@link PreparedQuery} object that can be reused multiple times with different parameters( {@code 'closeAfterExecution'} flag is set to {@code false} by calling {@code #closeAfterExecution(false)} ).
- **Contract:**
  - This is more efficient than creating new prepared statements for each execution, especially when the same query is executed repeatedly with different parameters.
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
  - </p> <p> <b> Key Features: </b> </p> <ul> <li> Automatic resource management when used with try-with-resources </li> <li> Support for method chaining with fluent parameter setting API </li> <li> Integration with transaction context for transactional operations </li> <li> Type-safe result mapping to Java objects, Lists, Maps, and more </li> <li> Stream support for memory-efficient processing of large result sets </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Basic query execution with single result // If closeAfterExecution(false) is not called, // there is no need to place the query instance in a try-catch block for closure.
  - Optional<User> user = JdbcUtil.prepareQuery(dataSource, "SELECT * FROM users WHERE id = ?") .setLong(1, userId).findFirst(User.class); if (user.isPresent()) { System.out.println("Found: " + user.get().getName()); } // Query with multiple parameters returning a list List<Order> orders = JdbcUtil.prepareQuery(dataSource, "SELECT * FROM orders WHERE customer_id = ?
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to get the connection from, must not be {@code null}
  - `sql` (`String`) — The SQL query to prepare with optional {@code ?} parameter placeholders, must not be {@code null} or empty
- **Returns:** A new {@link PreparedQuery} instance ready for parameter setting and execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code ds} or {@code sql} is {@code null} or empty
  - `java.sql.SQLException` — If a database access error occurs during preparation
- **See also:** PreparedQuery, #prepareQuery(Connection, String), #executeQuery(javax.sql.DataSource, String, Object...)
- **Signature:** `public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query with support for retrieving auto-generated keys.
- **Contract:**
  - This is typically used for {@code INSERT} statements when you need to get the ID of the newly created row.
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Optional<Long> newUserId = JdbcUtil.prepareQuery(dataSource, "INSERT INTO users (first_name, last_name) VALUES (?, ?)", true).setString(1, "John") .setString(2, "Doe") .insert(); if (newUserId.isPresent()) { System.out.println("New user created with ID: " + newUserId.get()); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to get the connection from.
  - `sql` (`String`) — The SQL statement to prepare (usually an {@code INSERT} statement).
  - `autoGeneratedKeys` (`boolean`) — A boolean flag; if {@code true} , the driver will be instructed to make generated keys available.
- **Returns:** A new {@link PreparedQuery} instance configured to handle auto-generated keys.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code ds} or {@code sql} is {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs or the driver does not support auto-generated keys.
- **See also:** Statement#RETURN_GENERATED_KEYS
- **Signature:** `public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query to make auto-generated keys available from specified column indexes.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
  - String insertSql = "INSERT INTO documents (content) VALUES (?)"; Row row = JdbcUtil.prepareQuery(dataSource, insertSql, new int\[\]{1, 4}) // Assuming id is 1, created_at is 4 .setString(1, "Some content...") .insert() .orElse(null); if (row != null) { String generatedUuid = row.getString(1); Timestamp creationTime = row.getTimestamp(2); System.out.println("New document created with UUID: " + generatedUuid + " at " + creationTime); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to get the connection from.
  - `sql` (`String`) — The SQL statement to prepare.
  - `returnColumnIndexes` (`int[]`) — An array of column indexes that should be made available for retrieval.
- **Returns:** A new {@link PreparedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any of the arguments are {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** Connection#prepareStatement(String, int\[\])
- **Signature:** `public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query to make auto-generated keys available from specified column names.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
  - String query = "INSERT INTO logs (message) VALUES (?)"; Row generatedValues = JdbcUtil.prepareQuery(dataSource, query, new String\[\]{"id", "created_at"}) .setString(1, "User logged in") .insert() .orElse(null); if (generatedValues != null) { long newId = generatedValues.getLong("id"); Timestamp creationTime = generatedValues.getTimestamp("created_at"); System.out.println("New log entry created with ID: " + newId + " at " + creationTime); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to get the connection from.
  - `sql` (`String`) — The SQL statement to prepare.
  - `returnColumnNames` (`String[]`) — An array of column names that should be made available for retrieval.
- **Returns:** A new {@link PreparedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any of the arguments are {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** Connection#prepareStatement(String, String\[\])
- **Signature:** `public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query using a custom {@link PreparedStatement} creator.
- **Contract:**
  - This method provides an extension point to customize the creation of the {@code PreparedStatement} , <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to get the connection from.
  - `sql` (`String`) — The SQL statement to prepare.
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — A function that takes a {@link Connection} and a SQL string and returns a new {@link PreparedStatement} .
- **Returns:** A new {@link PreparedQuery} instance wrapping the custom-created statement.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any of the arguments are {@code null} .
  - `java.sql.SQLException` — If a database access error occurs.
- **Signature:** `public static PreparedQuery prepareQuery(final Connection conn, final String sql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query using a provided {@link Connection} .
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // If closeAfterExecution(false) is not called, // there is no need to place the query instance in a try-catch block for closure.
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use for the query. It will not be closed by this method.
  - `sql` (`String`) — The SQL query to prepare.
- **Returns:** A new {@link PreparedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code conn} or {@code sql} is {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #prepareQuery(javax.sql.DataSource, String)
- **Signature:** `public static PreparedQuery prepareQuery(final Connection conn, final String sql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query with auto-generated keys support using a provided {@link Connection} .
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // If closeAfterExecution(false) is not called, // there is no need to place query instance in a try-catch block for closure.
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use. It will not be closed by this method.
  - `sql` (`String`) — The SQL statement to prepare.
  - `autoGeneratedKeys` (`boolean`) — If {@code true} , generated keys will be available for retrieval.
- **Returns:** A new {@link PreparedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code conn} or {@code sql} is {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs.
- **Signature:** `public static PreparedQuery prepareQuery(final Connection conn, final String sql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query to retrieve auto-generated keys from specified column indexes, using a provided {@link Connection} .
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // Assumes columns 1 ('id') and 4 ('creation_ts') are auto-generated Row generated = JdbcUtil.prepareQuery(conn, "INSERT INTO events (message) VALUES (?)", new int\[\]{1, 4}) .setString(1, "System startup") .insert() .orElse(null); if (generated != null) { System.out.println("New event ID: " + generated.get(0)); System.out.println("Creation timestamp: " + generated.get(1)); } } catch (SQLException e) { // Handle exception } } </pre>
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use. It will not be closed by this method.
  - `sql` (`String`) — The SQL statement to prepare.
  - `returnColumnIndexes` (`int[]`) — An array of 1-based column indexes of generated keys to return.
- **Returns:** A new {@link PreparedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any argument is {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs.
- **Signature:** `public static PreparedQuery prepareQuery(final Connection conn, final String sql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query to retrieve auto-generated keys from specified column names, using a provided {@link Connection} .
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // Assumes columns 'id' and 'creation_ts' are auto-generated Row generated = JdbcUtil.prepareQuery(conn, "INSERT INTO events (message) VALUES (?)", new String\[\]{"id", "creation_ts"}) .setString(1, "System shutdown") .insert() .orElse(null); if (generated != null) { System.out.println("New event ID: " + generated.getLong("id")); System.out.println("Creation timestamp: " + generated.getTimestamp("creation_ts")); } } catch (SQLException e) { // Handle exception } } </pre>
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use. It will not be closed by this method.
  - `sql` (`String`) — The SQL statement to prepare.
  - `returnColumnNames` (`String[]`) — An array of column names of generated keys to return.
- **Returns:** A new {@link PreparedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any argument is {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs.
- **Signature:** `public static PreparedQuery prepareQuery(final Connection conn, final String sql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a SQL query using a custom {@link PreparedStatement} creator and a provided {@link Connection} .
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use. It will not be closed by this method.
  - `sql` (`String`) — The SQL statement to prepare.
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — A factory function to create the {@link PreparedStatement} .
- **Returns:** A new {@link PreparedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any argument is {@code null} .
  - `java.sql.SQLException` — If a database access error occurs.
##### prepareQueryForLargeResult(...) -> PreparedQuery
- **Signature:** `@Beta public static PreparedQuery prepareQueryForLargeResult(final javax.sql.DataSource ds, final String sql) throws SQLException`
- **Summary:** Prepares a SQL query optimized for processing large result sets from a {@link javax.sql.DataSource} .
- **Contract:**
  - This method configures the underlying {@link PreparedStatement} with a forward-only fetch direction and a larger fetch size to improve performance when streaming or iterating over many rows.
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to get the connection from.
  - `sql` (`String`) — The SQL query to prepare.
- **Returns:** A {@link PreparedQuery} instance optimized for large result sets.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #prepareQueryForLargeResult(Connection, String)
- **Signature:** `@Beta public static PreparedQuery prepareQueryForLargeResult(final Connection conn, final String sql) throws SQLException`
- **Summary:** Prepares a SQL query optimized for large result sets using a provided {@link Connection} .
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The database {@link Connection} to use. It will not be closed by this method.
  - `sql` (`String`) — The SQL query to prepare.
- **Returns:** A {@link PreparedQuery} instance optimized for large result sets.
- **Throws:**
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** #prepareQueryForLargeResult(javax.sql.DataSource, String)
##### prepareNamedQuery(...) -> NamedQuery
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named-parameter SQL query for execution, returning a {@link NamedQuery} object.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to get the connection from.
  - `namedSql` (`String`) — The SQL query with named parameters (e.g., {@code :paramName} ).
- **Returns:** A new {@link NamedQuery} instance.
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code ds} or {@code namedSql} is {@code null} or empty.
  - `java.sql.SQLException` — If a database access error occurs.
- **See also:** NamedQuery, #prepareNamedQuery(Connection, String)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with auto-generated keys support using the provided DataSource.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Optional<Long> newUserId = JdbcUtil.prepareNamedQuery(dataSource, "INSERT INTO users (first_name, last_name, email) VALUES (:firstName, :lastName, :email)", true) .setParameter("firstName", "John") .setParameter("lastName", "Doe") .setParameter("email", "john.doe@example.com") .insert(); if (newUserId.isPresent()) { System.out.println("New user created with ID: " + newUserId.get()); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `autoGeneratedKeys` (`boolean`) — Whether auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or named SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column indexes for auto-generated keys using the provided DataSource.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Assuming a table where a trigger generates a UUID at column 1 and a timestamp at column 4 on insert String insertSql = "INSERT INTO documents (title, content) VALUES (:title, :content)"; Row row = JdbcUtil.prepareNamedQuery(dataSource, insertSql, new int\[\]{1, 4}) .setParameter("title", "Annual Report") .setParameter("content", "Report content...") .insert() .orElse(null); if (row != null) { String generatedUuid = row.getString(1); Timestamp creationTime = row.getTimestamp(2); System.out.println("Document created with UUID: " + generatedUuid + " at " + creationTime); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `returnColumnIndexes` (`int[]`) — The column indexes for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource, named SQL string, or returnColumnIndexes is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column names for auto-generated keys using the provided DataSource.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Assuming a table with an auto-incrementing 'id' and a 'created_at' column with a default value String query = "INSERT INTO logs (message, severity) VALUES (:message, :severity)"; Row generatedValues = JdbcUtil.prepareNamedQuery(dataSource, query, new String\[\]{"id", "created_at"}) .setParameter("message", "User logged in") .setParameter("severity", "INFO") .insert() .orElse(null); if (generatedValues != null) { long newId = generatedValues.getLong("id"); Timestamp creationTime = generatedValues.getTimestamp("created_at"); System.out.println("New log entry created with ID: " + newId + " at " + creationTime); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `returnColumnNames` (`String[]`) — The column names for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource, named SQL string, or returnColumnNames is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query using a custom statement creator with the provided DataSource.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — A function to create a PreparedStatement with custom configuration
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource, named SQL string, or stmtCreator is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query using the provided Connection and named SQL string.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or named SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with auto-generated keys support using the provided Connection.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `autoGeneratedKeys` (`boolean`) — Whether auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or named SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column indexes for auto-generated keys using the provided Connection.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // Assumes columns 1 ('id') and 4 ('creation_ts') are auto-generated Row generated = JdbcUtil.prepareNamedQuery(conn, "INSERT INTO events (event_type, message) VALUES (:type, :msg)", new int\[\]{1, 4}) .setParameter("type", "SYSTEM") .setParameter("msg", "System startup") .insert() .orElse(null); if (generated != null) { System.out.println("New event ID: " + generated.get(0)); System.out.println("Creation timestamp: " + generated.get(1)); } } catch (SQLException e) { // Handle exception } } </pre>
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `returnColumnIndexes` (`int[]`) — The column indexes for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection, named SQL string, or returnColumnIndexes is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column names for auto-generated keys using the provided Connection.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { Row generatedValues = JdbcUtil.prepareNamedQuery(conn, "INSERT INTO notifications (user_id, message) VALUES (:userId, :msg)", new String\[\]{"id", "created_at"}) .setParameter("userId", 123) .setParameter("msg", "Welcome to the system") .insert() .orElse(null); if (generatedValues != null) { long newId = generatedValues.getLong("id"); Timestamp creationTime = generatedValues.getTimestamp("created_at"); System.out.println("New notification ID: " + newId + " at " + creationTime); } } catch (SQLException e) { // Handle exception } } </pre>
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `returnColumnNames` (`String[]`) — The column names for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection, named SQL string, or returnColumnNames is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query using a custom statement creator with the provided Connection.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — A function to create a PreparedStatement with custom configuration
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection, named SQL string, or stmtCreator is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query using the provided DataSource and ParsedSql object.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or named SQL is {@code null} or invalid
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with auto-generated keys support using the provided DataSource and ParsedSql object.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `autoGeneratedKeys` (`boolean`) — Whether auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or named SQL is {@code null} or invalid
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column indexes for auto-generated keys using the provided DataSource and ParsedSql object.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `returnColumnIndexes` (`int[]`) — The column indexes for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource, named SQL, or returnColumnIndexes is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column names for auto-generated keys using the provided DataSource and ParsedSql object.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `returnColumnNames` (`String[]`) — The column names for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource, named SQL, or returnColumnNames is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query using a custom statement creator with the provided DataSource and ParsedSql object.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — A function to create a PreparedStatement with custom configuration
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource, named SQL, or stmtCreator is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query using the provided Connection and ParsedSql object.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or named SQL is {@code null} or invalid
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with auto-generated keys support using the provided Connection and ParsedSql object.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `autoGeneratedKeys` (`boolean`) — Whether auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or named SQL is {@code null} or invalid
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column indexes for auto-generated keys using the provided Connection and ParsedSql object.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `returnColumnIndexes` (`int[]`) — The column indexes for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection, named SQL, or returnColumnIndexes is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query with specific column names for auto-generated keys using the provided Connection and ParsedSql object.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `returnColumnNames` (`String[]`) — The column names for which auto-generated keys should be returned
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection, named SQL, or returnColumnNames is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a named SQL query using a custom statement creator with the provided Connection and ParsedSql object.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — A function to create a PreparedStatement with custom configuration
- **Returns:** A NamedQuery object representing the prepared named SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection, named SQL, or stmtCreator is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
##### prepareNamedQueryForLargeResult(...) -> NamedQuery
- **Signature:** `@Beta public static NamedQuery prepareNamedQueryForLargeResult(final javax.sql.DataSource ds, final String namedSql) throws SQLException`
- **Summary:** Prepares a named SQL query optimized for large result sets using the provided DataSource.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
- **Returns:** A NamedQuery object configured for big result sets
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `@Beta public static NamedQuery prepareNamedQueryForLargeResult(final javax.sql.DataSource ds, final ParsedSql namedSql) throws SQLException`
- **Summary:** Prepares a named SQL query optimized for large result sets using the provided DataSource and ParsedSql object.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `namedSql` (`ParsedSql`) — The ParsedSql object containing the named SQL
- **Returns:** A NamedQuery object configured for big result sets
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `@Beta public static NamedQuery prepareNamedQueryForLargeResult(final Connection conn, final String namedSql) throws SQLException`
- **Summary:** Prepares a named SQL query optimized for large result sets using the provided Connection.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `namedSql` (`String`) — The named SQL string to prepare
- **Returns:** A NamedQuery object configured for big result sets
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
##### prepareCallableQuery(...) -> CallableQuery
- **Signature:** `public static CallableQuery prepareCallableQuery(final javax.sql.DataSource ds, final String sql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a callable SQL query (stored procedure) using the provided DataSource.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query
  - `sql` (`String`) — The SQL string for the stored procedure call
- **Returns:** A CallableQuery object representing the prepared callable SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static CallableQuery prepareCallableQuery(final javax.sql.DataSource ds, final String sql, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a callable SQL query using a custom statement creator with the provided DataSource.
- **Contract:**
  - <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.
  - Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the query, must not be {@code null}
  - `sql` (`String`) — The SQL string for the stored procedure call, must not be {@code null} or empty
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, CallableStatement, SQLException>`) — A functional interface that creates a CallableStatement with custom configuration. Receives the Connection and SQL string, and returns a configured CallableStatement. Must not be {@code null} .
- **Returns:** A CallableQuery object representing the prepared callable SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code ds} , {@code sql} , or {@code stmtCreator} is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **See also:** #prepareCallableQuery(javax.sql.DataSource, String), #getConnection(javax.sql.DataSource), #releaseConnection(Connection, javax.sql.DataSource)
- **Signature:** `public static CallableQuery prepareCallableQuery(final Connection conn, final String sql) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a callable SQL query (stored procedure) using the provided Connection.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `sql` (`String`) — The SQL string for the stored procedure call
- **Returns:** A CallableQuery object representing the prepared callable SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
- **Signature:** `public static CallableQuery prepareCallableQuery(final Connection conn, final String sql, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException`
- **Summary:** Prepares a callable SQL query using a custom statement creator with the provided Connection.
- **Contract:**
  - The caller MUST close the provided {@code Connection} to avoid resource leaks.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `sql` (`String`) — The SQL string for the stored procedure call
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, CallableStatement, SQLException>`) — A function to create a CallableStatement with custom configuration
- **Returns:** A CallableQuery object representing the prepared callable SQL query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection, SQL string, or stmtCreator is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while preparing the query
##### executeQuery(...) -> Dataset
- **Signature:** `public static Dataset executeQuery(final javax.sql.DataSource ds, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a SQL query immediately with the provided parameters and returns all results as a {@link Dataset} .
- **Contract:**
  - <p> If a transaction is active in the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transaction's Connection will be used.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to obtain a connection from, must not be {@code null}
  - `sql` (`String`) — The SQL SELECT statement to execute with optional {@code ?} parameter placeholders, must not be {@code null} or empty
  - `parameters` (`Object[]`) — Variable number of parameters to bind to the SQL statement, matching the {@code ?} placeholders in order. Can be empty if the SQL has no parameters. Supports primitive types, Strings, Dates, and other JDBC-compatible types
- **Returns:** A {@link Dataset} object containing all query results loaded into memory with row and column access methods
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code ds} or {@code sql} is {@code null} or empty
  - `java.sql.SQLException` — If a database access error occurs, the SQL is invalid, or parameter types are incompatible
- **See also:** PreparedStatement#executeQuery(), #prepareQuery(javax.sql.DataSource, String), Dataset
- **Signature:** `public static Dataset executeQuery(final Connection conn, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a SQL query using the provided Connection and SQL string with optional parameters.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the query
  - `sql` (`String`) — The SQL string to execute
  - `parameters` (`Object[]`) — Optional parameters for the SQL query
- **Returns:** A Dataset object containing the result of the query
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the query
- **See also:** PreparedStatement#executeQuery()
##### executeUpdate(...) -> int
- **Signature:** `public static int executeUpdate(final javax.sql.DataSource ds, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a SQL data modification statement (INSERT, UPDATE, DELETE) or DDL statement immediately with the provided parameters and returns the number of affected rows.
- **Contract:**
  - <p> If a transaction is active in the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transaction's Connection will be used.
  - AND stock > ?", 0.9, "Electronics", 100); // INSERT with multiple values int inserted = JdbcUtil.executeUpdate(dataSource, "INSERT INTO user_preferences (user_id, theme, language, notifications) VALUES (?, ?, ?, ?)", userId, "DARK", "en_US", true); // DELETE all records (use with caution!) int allDeleted = JdbcUtil.executeUpdate(dataSource, "DELETE FROM temp_data"); // No parameters needed // Conditional update if (needsUpdate) { int count = JdbcUtil.executeUpdate(dataSource, "UPDATE inventory SET quantity = quantity - ?
  - AND quantity >= ?", orderQuantity, productId, orderQuantity); if (count == 0) { throw new InsufficientInventoryException("Not enough stock"); } } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The {@link javax.sql.DataSource} to obtain a connection from, must not be {@code null}
  - `sql` (`String`) — The SQL INSERT, UPDATE, DELETE, or DDL statement with optional {@code ?} parameter placeholders, must not be {@code null} or empty
  - `parameters` (`Object[]`) — Variable number of parameters to bind to the SQL statement, matching the {@code ?} placeholders in order. Can be empty if the SQL has no parameters. Supports primitive types, Strings, Dates, and other JDBC-compatible types
- **Returns:** The number of rows affected by the statement. Returns 0 for DDL statements or when no rows match the WHERE clause
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code ds} or {@code sql} is {@code null} or empty
  - `java.sql.SQLException` — If a database access error occurs, the SQL is invalid, or parameter types are incompatible
- **See also:** PreparedStatement#executeUpdate(), #prepareQuery(javax.sql.DataSource, String)
- **Signature:** `public static int executeUpdate(final Connection conn, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a SQL update using the provided Connection and SQL string with optional parameters.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the update
  - `sql` (`String`) — The SQL string to execute
  - `parameters` (`Object[]`) — Optional parameters for the SQL update
- **Returns:** The number of rows affected by the update
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the update
- **See also:** PreparedStatement#executeUpdate()
##### executeBatchUpdate(...) -> int
- **Signature:** `public static int executeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a batch SQL update using the provided DataSource with default batch size.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the batch update
  - `sql` (`String`) — The SQL string to execute
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update
- **Returns:** The number of rows affected by the batch update
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeBatch()
- **Signature:** `public static int executeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a batch SQL update using the provided DataSource with specified batch size.
- **Contract:**
  - When the number of parameter sets exceeds the batch size, a transaction is automatically started to ensure atomicity.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the batch update, must not be {@code null}
  - `sql` (`String`) — The SQL string to execute, must not be {@code null} or empty
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update. Each element should be an Object array or a compatible collection representing one set of parameters.
  - `batchSize` (`int`) — The size of each batch, must be positive. Smaller batches use less memory but may be slower; larger batches are faster but use more memory.
- **Returns:** The total number of rows affected by the batch update across all batches
- **Throws:**
  - `java.lang.IllegalArgumentException` — If {@code ds} or {@code sql} is {@code null} or empty, or if {@code batchSize} is not positive
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeBatch(), #executeBatchUpdate(javax.sql.DataSource, String, List)
- **Signature:** `public static int executeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a batch SQL update using the provided Connection with default batch size.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the batch update
  - `sql` (`String`) — The SQL string to execute
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update
- **Returns:** The number of rows affected by the batch update
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeBatch()
- **Signature:** `public static int executeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a batch SQL update using the provided Connection with specified batch size.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the batch update
  - `sql` (`String`) — The SQL string to execute
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update
  - `batchSize` (`int`) — The size of each batch
- **Returns:** The number of rows affected by the batch update
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeBatch()
##### executeLargeBatchUpdate(...) -> long
- **Signature:** `public static long executeLargeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a large batch SQL update using the provided DataSource with default batch size.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the batch update
  - `sql` (`String`) — The SQL string to execute
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update
- **Returns:** The number of rows affected by the batch update as a long value
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeLargeBatch()
- **Signature:** `public static long executeLargeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a large batch SQL update using the provided DataSource with specified batch size.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the batch update
  - `sql` (`String`) — The SQL string to execute
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update
  - `batchSize` (`int`) — The size of each batch
- **Returns:** The number of rows affected by the batch update as a long value
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeLargeBatch()
- **Signature:** `public static long executeLargeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a large batch SQL update using the provided Connection with default batch size.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the batch update
  - `sql` (`String`) — The SQL string to execute
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update
- **Returns:** The number of rows affected by the batch update as a long value
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeLargeBatch()
- **Signature:** `public static long executeLargeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a large batch SQL update using the provided Connection with specified batch size.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the batch update
  - `sql` (`String`) — The SQL string to execute
  - `listOfParameters` (`List<?>`) — A list of parameter sets for the batch update
  - `batchSize` (`int`) — The size of each batch
- **Returns:** The number of rows affected by the batch update as a long value
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the batch update
- **See also:** PreparedStatement#executeLargeBatch()
##### execute(...) -> boolean
- **Signature:** `public static boolean execute(final javax.sql.DataSource ds, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a SQL statement using the provided DataSource with optional parameters.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The DataSource to use for the SQL execution
  - `sql` (`String`) — The SQL string to execute
  - `parameters` (`Object[]`) — Optional parameters for the SQL statement
- **Returns:** {@code true} if the first result is a ResultSet object; {@code false} if it is an update count or there are no results
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the DataSource or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the statement
- **See also:** PreparedStatement#execute()
- **Signature:** `public static boolean execute(final Connection conn, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Executes a SQL statement using the provided Connection with optional parameters.
- **Parameters:**
  - `conn` (`Connection`) — The Connection to use for the SQL execution
  - `sql` (`String`) — The SQL string to execute
  - `parameters` (`Object[]`) — Optional parameters for the SQL statement
- **Returns:** {@code true} if the first result is a ResultSet object; {@code false} if it is an update count or there are no results
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the Connection or SQL string is {@code null} or empty
  - `java.sql.SQLException` — If a SQL exception occurs while executing the statement
- **See also:** PreparedStatement#execute()
##### extractData(...) -> Dataset
- **Signature:** `public static Dataset extractData(final ResultSet rs) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet and returns it as a Dataset.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from
- **Returns:** A Dataset containing the extracted data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **Signature:** `public static Dataset extractData(final ResultSet rs, final int offset, final int count) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet starting from the specified offset and up to the specified count.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from
  - `offset` (`int`) — The starting position in the ResultSet (0-based)
  - `count` (`int`) — The maximum number of rows to extract
- **Returns:** A Dataset containing the extracted data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **Signature:** `public static Dataset extractData(final ResultSet rs, final RowFilter filter) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet using the specified RowFilter.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from, must not be {@code null}
  - `filter` (`RowFilter`) — The RowFilter to apply while extracting data. This is a functional interface that tests each row; only rows for which {@code filter.test(rs)} returns {@code true} will be included in the result. Must not be {@code null} .
- **Returns:** A Dataset containing the filtered data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **See also:** RowFilter, #extractData(ResultSet, RowFilter, RowExtractor)
- **Signature:** `public static Dataset extractData(final ResultSet rs, final RowExtractor rowExtractor) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet using the specified RowExtractor.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from, must not be {@code null}
  - `rowExtractor` (`RowExtractor`) — The RowExtractor to apply while extracting data. This is a functional interface that receives the current ResultSet and an output row array, allowing modification of the row data before it's added to the Dataset. Must not be {@code null} .
- **Returns:** A Dataset containing the extracted and transformed data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **See also:** RowExtractor, #extractData(ResultSet, RowFilter, RowExtractor)
- **Signature:** `public static Dataset extractData(final ResultSet rs, final RowFilter filter, final RowExtractor rowExtractor) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet using both RowFilter and RowExtractor.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from, must not be {@code null}
  - `filter` (`RowFilter`) — The RowFilter to apply for filtering rows. Only rows for which {@code filter.test(rs)} returns {@code true} will be processed by the extractor. Must not be {@code null} .
  - `rowExtractor` (`RowExtractor`) — applied to extract data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.
- **Returns:** A Dataset containing the filtered and transformed data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **See also:** RowFilter, RowExtractor, #extractData(ResultSet, RowFilter), #extractData(ResultSet, RowExtractor)
- **Signature:** `public static Dataset extractData(final ResultSet rs, final boolean closeResultSet) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet and returns it as a Dataset.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from
  - `closeResultSet` (`boolean`) — Whether to close the ResultSet after extraction
- **Returns:** A Dataset containing the extracted data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **Signature:** `public static Dataset extractData(final ResultSet rs, final int offset, final int count, final boolean closeResultSet) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet with specified offset and count.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from
  - `offset` (`int`) — The starting position in the ResultSet
  - `count` (`int`) — The number of rows to extract
  - `closeResultSet` (`boolean`) — Whether to close the ResultSet after extraction
- **Returns:** A Dataset containing the extracted data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **Signature:** `public static Dataset extractData(final ResultSet rs, final int offset, final int count, final RowFilter filter, final boolean closeResultSet) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet with offset, count, and filter.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from, must not be {@code null}
  - `offset` (`int`) — The starting position (0-based) in the ResultSet, must be non-negative
  - `count` (`int`) — The maximum number of rows to extract, must be non-negative
  - `filter` (`RowFilter`) — The RowFilter to apply while extracting data. Only rows for which {@code filter.test(rs)} returns {@code true} will be included. Must not be {@code null} .
  - `closeResultSet` (`boolean`) — Whether to close the ResultSet after extraction
- **Returns:** A Dataset containing the extracted data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **See also:** #extractData(ResultSet, int, int, RowFilter, RowExtractor, boolean)
- **Signature:** `public static Dataset extractData(final ResultSet rs, final int offset, final int count, final RowExtractor rowExtractor, final boolean closeResultSet) throws SQLException`
- **Summary:** Extracts data from the provided ResultSet with offset, count, and extractor.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from, must not be {@code null}
  - `offset` (`int`) — The starting position (0-based) in the ResultSet, must be non-negative
  - `count` (`int`) — The maximum number of rows to extract, must be non-negative
  - `rowExtractor` (`RowExtractor`) — applied to extract data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.
  - `closeResultSet` (`boolean`) — Whether to close the ResultSet after extraction
- **Returns:** A Dataset containing the extracted and transformed data
- **Throws:**
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **See also:** #extractData(ResultSet, int, int, RowFilter, RowExtractor, boolean)
- **Signature:** `public static Dataset extractData(final ResultSet rs, final int offset, final int count, final RowFilter filter, final RowExtractor rowExtractor, final boolean closeResultSet) throws IllegalArgumentException, SQLException`
- **Summary:** Extracts data from the provided ResultSet with all extraction options.
- **Parameters:**
  - `rs` (`ResultSet`) — The ResultSet to extract data from, must not be {@code null}
  - `offset` (`int`) — The starting position (0-based) in the ResultSet, must be non-negative
  - `count` (`int`) — The maximum number of rows to extract, must be non-negative
  - `filter` (`RowFilter`) — The RowFilter to apply for filtering rows. Only rows for which {@code filter.test(rs)} returns {@code true} will be processed. Must not be {@code null} .
  - `rowExtractor` (`RowExtractor`) — applied to extract data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.
  - `closeResultSet` (`boolean`) — Whether to close the ResultSet after extraction completes (or if an error occurs)
- **Returns:** A Dataset containing the filtered and transformed data
- **Throws:**
  - `java.lang.IllegalArgumentException` — If any argument is invalid (null or negative values)
  - `java.sql.SQLException` — If a SQL exception occurs while extracting data
- **See also:** RowFilter, RowExtractor, #extractData(ResultSet, RowFilter, RowExtractor)
##### stream(...) -> Stream<Object\[\]>
- **Signature:** `public static Stream<Object[]> stream(final ResultSet resultSet)`
- **Summary:** Creates a stream from the provided ResultSet.
- **Parameters:**
  - `resultSet` (`ResultSet`) — The ResultSet to create a stream from
- **Returns:** A Stream of Object arrays containing the data from the ResultSet
- **Signature:** `public static <T> Stream<T> stream(final ResultSet resultSet, final Class<? extends T> targetClass) throws IllegalArgumentException`
- **Summary:** Creates a stream from the provided ResultSet, mapping each row to the specified target class.
- **Parameters:**
  - `resultSet` (`ResultSet`) — The ResultSet to create a stream from
  - `targetClass` (`Class<? extends T>`) — The class of the result type. Column names from the ResultSet will be mapped to properties of this class
- **Returns:** A Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — If the provided arguments are invalid
- **Signature:** `public static <T> Stream<T> stream(final ResultSet resultSet, final RowMapper<? extends T> rowMapper) throws IllegalArgumentException`
- **Summary:** Creates a stream from the provided ResultSet using the specified RowMapper.
- **Parameters:**
  - `resultSet` (`ResultSet`) — the ResultSet to create a stream from
  - `rowMapper` (`RowMapper<? extends T>`) — the RowMapper to apply while extracting data. This mapper is called for each row in the ResultSet
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
- **Signature:** `public static <T> Stream<T> stream(final ResultSet resultSet, final RowFilter rowFilter, final RowMapper<? extends T> rowMapper) throws IllegalArgumentException`
- **Summary:** Creates a stream from the provided ResultSet using the specified RowFilter and RowMapper.
- **Parameters:**
  - `resultSet` (`ResultSet`) — the ResultSet to create a stream from
  - `rowFilter` (`RowFilter`) — the RowFilter to apply while filtering rows. Only rows for which this filter returns {@code true} will be included
  - `rowMapper` (`RowMapper<? extends T>`) — the RowMapper to apply while extracting data from filtered rows
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
- **Signature:** `public static <T> Stream<T> stream(final ResultSet resultSet, final BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException`
- **Summary:** Creates a stream from the provided ResultSet using the specified BiRowMapper.
- **Parameters:**
  - `resultSet` (`ResultSet`) — the ResultSet to create a stream from
  - `rowMapper` (`BiRowMapper<? extends T>`) — the BiRowMapper to apply while extracting data. This mapper receives both the ResultSet and column labels
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
- **Signature:** `public static <T> Stream<T> stream(final ResultSet resultSet, final BiRowFilter rowFilter, final BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException`
- **Summary:** Creates a stream from the provided ResultSet using the specified BiRowFilter and BiRowMapper.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code BiRowFilter hasNonNullValues = (rs, columnLabels) -> { for (String label : columnLabels) { if (rs.getObject(label) != null) return true; } return false; }; BiRowMapper<String> csvMapper = (rs, columnLabels) -> columnLabels.stream() .map(label -> rs.getString(label)) .collect(Collectors.joining(",")); JdbcUtil.stream(resultSet, hasNonNullValues, csvMapper) .onClose(Fn.closeQuietly(resultSet)) .forEach(csvRow -> System.out.println(csvRow)); } </pre>
- **Parameters:**
  - `resultSet` (`ResultSet`) — the ResultSet to create a stream from
  - `rowFilter` (`BiRowFilter`) — the BiRowFilter to apply while filtering rows. Both ResultSet and column labels are provided
  - `rowMapper` (`BiRowMapper<? extends T>`) — the BiRowMapper to apply while extracting data from filtered rows
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
- **Signature:** `public static <T> Stream<T> stream(final ResultSet resultSet, final int columnIndex) throws IllegalArgumentException`
- **Summary:** Creates a stream from the provided ResultSet using the specified column index.
- **Contract:**
  - This is useful when you only need values from a single column.
- **Parameters:**
  - `resultSet` (`ResultSet`) — the ResultSet to create a stream from
  - `columnIndex` (`int`) — the index of the column to extract data from, starting from 1
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
- **Signature:** `public static <T> Stream<T> stream(final ResultSet resultSet, final String columnName) throws IllegalArgumentException`
- **Summary:** Creates a stream from the provided ResultSet using the specified column name.
- **Contract:**
  - This is useful when you only need values from a single column identified by name.
- **Parameters:**
  - `resultSet` (`ResultSet`) — the ResultSet to create a stream from
  - `columnName` (`String`) — the name of the column to extract data from
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
##### streamAllResultSets(...) -> Stream<Dataset>
- **Signature:** `public static Stream<Dataset> streamAllResultSets(final Statement stmt)`
- **Summary:** Extracts all ResultSets from the provided Statement and returns them as a Stream of Dataset.
- **Contract:**
  - This is useful when executing stored procedures that return multiple result sets.
- **Parameters:**
  - `stmt` (`Statement`) — the Statement to extract ResultSets from
- **Returns:** a Stream of Dataset containing the extracted ResultSets
- **Signature:** `@SuppressWarnings("resource") public static <R> Stream<R> streamAllResultSets(final Statement stmt, final ResultExtractor<R> resultExtractor) throws IllegalArgumentException`
- **Summary:** Extracts all ResultSets from the provided Statement and returns them as a Stream.
- **Parameters:**
  - `stmt` (`Statement`) — the Statement to extract ResultSets from
  - `resultExtractor` (`ResultExtractor<R>`) — the ResultExtractor to apply while extracting data from each ResultSet
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
- **Signature:** `@SuppressWarnings("resource") public static <R> Stream<R> streamAllResultSets(final Statement stmt, final BiResultExtractor<R> resultExtractor) throws IllegalArgumentException`
- **Summary:** Extracts all ResultSets from the provided Statement and returns them as a Stream.
- **Parameters:**
  - `stmt` (`Statement`) — the Statement to extract ResultSets from
  - `resultExtractor` (`BiResultExtractor<R>`) — the BiResultExtractor to apply while extracting data
- **Returns:** a Stream of the extracted results
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
##### queryByPage(...) -> Stream<Dataset>
- **Signature:** `@SuppressWarnings("rawtypes") public static Stream<Dataset> queryByPage(final javax.sql.DataSource ds, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, Dataset> paramSetter)`
- **Summary:** Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .
- **Contract:**
  - The query must be ordered by at least one key/id and have a result size limitation (e.g., LIMIT pageSize).
  - ORDER BY id LIMIT 1000"; JdbcUtil.queryByPage(dataSource, query, 1000, (preparedQuery, previousPage) -> { if (previousPage == null) { preparedQuery.setLong(1, 0); } else { long lastId = previousPage.getLong(previousPage.size() - 1, "id"); preparedQuery.setLong(1, lastId); } }).forEach(page -> { System.out.println("Processing " + page.size() + " records"); // Process the page }); } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — the DataSource to get the connection from
  - `query` (`String`) — the SQL query to run for each page. Must include ORDER BY and LIMIT/FETCH clauses
  - `pageSize` (`int`) — the number of rows to fetch per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super AbstractQuery, Dataset>`) — the BiParametersSetter to set parameters for the query; the second parameter is the result set for the previous page (null for first page)
- **Returns:** a Stream of Dataset, each representing a page of results
- **Signature:** `@SuppressWarnings("rawtypes") public static <R> Stream<R> queryByPage(final javax.sql.DataSource ds, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.ResultExtractor<R> resultExtractor)`
- **Summary:** Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .
- **Contract:**
  - The query must be ordered by at least one key/id and have a result size limitation.
  - ORDER BY order_id LIMIT 500"; ResultExtractor<List<Order>> ordersExtractor = rs -> { List<Order> orders = new ArrayList<>(); while (rs.next()) { orders.add(new Order(rs.getLong("order_id"), rs.getDate("order_date"))); } return orders; }; JdbcUtil.queryByPage(dataSource, query, 500, (preparedQuery, previousOrders) -> { if (previousOrders == null) { preparedQuery.setDate(1, startDate); } else { Order lastOrder = previousOrders.get(previousOrders.size() - 1); preparedQuery.setDate(1, lastOrder.getOrderDate()); } }, ordersExtractor) .forEach(orders -> processOrderBatch(orders)); } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — the DataSource to get the connection from
  - `query` (`String`) — the SQL query to run for each page
  - `pageSize` (`int`) — the number of rows to fetch per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super AbstractQuery, R>`) — the BiParametersSetter to set parameters for the query
  - `resultExtractor` (`Jdbc.ResultExtractor<R>`) — the ResultExtractor to extract results from the ResultSet
- **Returns:** a Stream of the extracted results
- **Signature:** `@SuppressWarnings("rawtypes") public static <R> Stream<R> queryByPage(final javax.sql.DataSource ds, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.BiResultExtractor<R> resultExtractor)`
- **Summary:** Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .
- **Contract:**
  - The query must be ordered by at least one key/id and have a result size limitation.
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — the DataSource to get the connection from
  - `query` (`String`) — the SQL query to run for each page
  - `pageSize` (`int`) — the number of rows to fetch per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super AbstractQuery, R>`) — the BiParametersSetter to set parameters for the query
  - `resultExtractor` (`Jdbc.BiResultExtractor<R>`) — the BiResultExtractor to extract results from the ResultSet
- **Returns:** a Stream of the extracted results
- **Signature:** `@SuppressWarnings("rawtypes") public static Stream<Dataset> queryByPage(final Connection conn, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, Dataset> paramSetter)`
- **Summary:** Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .
- **Contract:**
  - The query must be ordered by at least one key/id and have a result size limitation.
- **Parameters:**
  - `conn` (`Connection`) — the Connection to use for queries
  - `query` (`String`) — the SQL query to run for each page
  - `pageSize` (`int`) — the number of rows to fetch per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super AbstractQuery, Dataset>`) — the BiParametersSetter to set parameters for the query
- **Returns:** a Stream of Dataset, each representing a page of results
- **Signature:** `@SuppressWarnings("rawtypes") public static <R> Stream<R> queryByPage(final Connection conn, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.ResultExtractor<R> resultExtractor)`
- **Summary:** Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .
- **Parameters:**
  - `conn` (`Connection`) — the Connection to use for queries
  - `query` (`String`) — the SQL query to run for each page
  - `pageSize` (`int`) — the number of rows to fetch per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super AbstractQuery, R>`) — the BiParametersSetter to set parameters for the query
  - `resultExtractor` (`Jdbc.ResultExtractor<R>`) — the ResultExtractor to extract results from the ResultSet
- **Returns:** a Stream of the extracted results
- **Signature:** `@SuppressWarnings("rawtypes") public static <R> Stream<R> queryByPage(final Connection conn, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.BiResultExtractor<R> resultExtractor)`
- **Summary:** Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .
- **Parameters:**
  - `conn` (`Connection`) — the Connection to use for queries
  - `query` (`String`) — the SQL query to run for each page
  - `pageSize` (`int`) — the number of rows to fetch per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super AbstractQuery, R>`) — the BiParametersSetter to set parameters for the query
  - `resultExtractor` (`Jdbc.BiResultExtractor<R>`) — the BiResultExtractor to extract results from the ResultSet
- **Returns:** a Stream of the extracted results
##### doesTableExist(...) -> boolean
- **Signature:** `public static boolean doesTableExist(final javax.sql.DataSource ds, final String tableName)`
- **Summary:** Checks if a table exists in the database.
- **Contract:**
  - Checks if a table exists in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.doesTableExist(ds, "users")) { System.out.println("Users table exists"); } else { System.out.println("Users table does not exist"); } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The data source to get the connection from
  - `tableName` (`String`) — The name of the table to check
- **Returns:** {@code true} if the table exists, {@code false} otherwise
- **Signature:** `public static boolean doesTableExist(final Connection conn, final String tableName)`
- **Summary:** Checks if a table exists in the database.
- **Contract:**
  - Checks if a table exists in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.doesTableExist(connection, "users")) { System.out.println("Users table exists"); } else { System.out.println("Users table does not exist"); } } </pre>
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use for checking table existence
  - `tableName` (`String`) — The name of the table to check
- **Returns:** {@code true} if the table exists, {@code false} otherwise
##### createTableIfNotExists(...) -> boolean
- **Signature:** `public static boolean createTableIfNotExists(final Connection conn, final String tableName, final String schema)`
- **Summary:** Creates a table if it does not already exist in the database.
- **Contract:**
  - Creates a table if it does not already exist in the database.
  - This method first checks if the table exists, and if not, executes the provided schema to create it.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use for creating the table
  - `tableName` (`String`) — The name of the table to create
  - `schema` (`String`) — The SQL schema definition (CREATE TABLE statement) for the table
- **Returns:** {@code true} if the table was created, {@code false} if the table already exists
##### dropTableIfExists(...) -> boolean
- **Signature:** `public static boolean dropTableIfExists(final Connection conn, final String tableName)`
- **Summary:** Drops the specified table if it exists in the database.
- **Contract:**
  - Drops the specified table if it exists in the database.
  - This method first checks if the table exists before attempting to drop it, preventing errors from trying to drop a non-existent table.
- **Parameters:**
  - `conn` (`Connection`) — The database connection to use for dropping the table
  - `tableName` (`String`) — The name of the table to drop
- **Returns:** {@code true} if the table was dropped, {@code false} if the table did not exist or could not be dropped
##### getDBLock(...) -> DBLock
- **Signature:** `public static DBLock getDBLock(final javax.sql.DataSource ds, final String tableName)`
- **Summary:** Returns a new instance of {@code DBLock} for implementing global locks using a database table.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock lock = JdbcUtil.getDBLock(dataSource, "distributed_locks"); if (lock.acquire("job_processor")) { try { // Perform exclusive operation } finally { lock.release("job_processor"); } } } </pre>
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — The data source to use for database connections
  - `tableName` (`String`) — The name of the table used for storing lock information
- **Returns:** A new instance of {@code DBLock} for distributed locking
##### asyncRun(...) -> ContinuableFuture<Void>
- **Signature:** `@Beta public static ContinuableFuture<Void> asyncRun(final Throwables.Runnable<Exception> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously runs the specified SQL action in a separate thread.
- **Parameters:**
  - `sqlAction` (`Throwables.Runnable<Exception>`) — The SQL action to be executed asynchronously
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the specified SQL action is {@code null}
- **Signature:** `@Beta public static Tuple2<ContinuableFuture<Void>, ContinuableFuture<Void>> asyncRun(final Throwables.Runnable<Exception> sqlAction1, final Throwables.Runnable<Exception> sqlAction2) throws IllegalArgumentException`
- **Summary:** Asynchronously runs two SQL actions in separate threads.
- **Parameters:**
  - `sqlAction1` (`Throwables.Runnable<Exception>`) — The first SQL action to be executed asynchronously
  - `sqlAction2` (`Throwables.Runnable<Exception>`) — The second SQL action to be executed asynchronously
- **Returns:** A Tuple2 containing two ContinuableFuture objects representing the results of the asynchronous computations
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any of the SQL actions are {@code null}
- **Signature:** `@Beta public static Tuple3<ContinuableFuture<Void>, ContinuableFuture<Void>, ContinuableFuture<Void>> asyncRun(final Throwables.Runnable<Exception> sqlAction1, final Throwables.Runnable<Exception> sqlAction2, final Throwables.Runnable<Exception> sqlAction3) throws IllegalArgumentException`
- **Summary:** Asynchronously runs three SQL actions in separate threads.
- **Parameters:**
  - `sqlAction1` (`Throwables.Runnable<Exception>`) — The first SQL action to be executed asynchronously
  - `sqlAction2` (`Throwables.Runnable<Exception>`) — The second SQL action to be executed asynchronously
  - `sqlAction3` (`Throwables.Runnable<Exception>`) — The third SQL action to be executed asynchronously
- **Returns:** A Tuple3 containing three ContinuableFuture objects representing the results of the asynchronous computations
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any of the SQL actions are {@code null}
- **Signature:** `@Beta public static <T> ContinuableFuture<Void> asyncRun(final T parameter, final Throwables.Consumer<? super T, Exception> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously runs the specified SQL action with the given parameter.
- **Parameters:**
  - `parameter` (`T`) — The parameter to be passed to the SQL action
  - `sqlAction` (`Throwables.Consumer<? super T, Exception>`) — The SQL action to be executed with the parameter
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the SQL action is {@code null}
- **Signature:** `@Beta public static <T, U> ContinuableFuture<Void> asyncRun(final T parameter1, final U parameter2, final Throwables.BiConsumer<? super T, ? super U, Exception> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously runs the specified SQL action with two parameters.
- **Parameters:**
  - `parameter1` (`T`) — The first parameter to be passed to the SQL action
  - `parameter2` (`U`) — The second parameter to be passed to the SQL action
  - `sqlAction` (`Throwables.BiConsumer<? super T, ? super U, Exception>`) — The SQL action to be executed with the parameters
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the SQL action is {@code null}
- **Signature:** `@Beta public static <A, B, C> ContinuableFuture<Void> asyncRun(final A parameter1, final B parameter2, final C parameter3, final Throwables.TriConsumer<? super A, ? super B, ? super C, Exception> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously runs the specified SQL action with three parameters.
- **Parameters:**
  - `parameter1` (`A`) — The first parameter to be passed to the SQL action
  - `parameter2` (`B`) — The second parameter to be passed to the SQL action
  - `parameter3` (`C`) — The third parameter to be passed to the SQL action
  - `sqlAction` (`Throwables.TriConsumer<? super A, ? super B, ? super C, Exception>`) — The SQL action to be executed with the parameters
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the SQL action is {@code null}
##### asyncCall(...) -> ContinuableFuture<R>
- **Signature:** `@Beta public static <R> ContinuableFuture<R> asyncCall(final Callable<R> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously calls the specified SQL action and returns a result.
- **Parameters:**
  - `sqlAction` (`Callable<R>`) — The SQL action that produces a result
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the SQL action is {@code null}
- **Signature:** `@Beta public static <R1, R2> Tuple2<ContinuableFuture<R1>, ContinuableFuture<R2>> asyncCall(final Callable<R1> sqlAction1, final Callable<R2> sqlAction2) throws IllegalArgumentException`
- **Summary:** Asynchronously calls two SQL actions and returns their results.
- **Parameters:**
  - `sqlAction1` (`Callable<R1>`) — The first SQL action that produces a result
  - `sqlAction2` (`Callable<R2>`) — The second SQL action that produces a result
- **Returns:** A Tuple2 containing two ContinuableFutures representing the results of the asynchronous computations
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any of the SQL actions are {@code null}
- **Signature:** `@Beta public static <R1, R2, R3> Tuple3<ContinuableFuture<R1>, ContinuableFuture<R2>, ContinuableFuture<R3>> asyncCall(final Callable<R1> sqlAction1, final Callable<R2> sqlAction2, final Callable<R3> sqlAction3) throws IllegalArgumentException`
- **Summary:** Asynchronously calls three SQL actions and returns their results.
- **Parameters:**
  - `sqlAction1` (`Callable<R1>`) — The first SQL action that produces a result
  - `sqlAction2` (`Callable<R2>`) — The second SQL action that produces a result
  - `sqlAction3` (`Callable<R3>`) — The third SQL action that produces a result
- **Returns:** A Tuple3 containing three ContinuableFutures representing the results of the asynchronous computations
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any of the SQL actions are {@code null}
- **Signature:** `@Beta public static <T, R> ContinuableFuture<R> asyncCall(final T parameter, final Throwables.Function<? super T, ? extends R, Exception> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously calls the specified SQL action with one parameter and returns a result.
- **Parameters:**
  - `parameter` (`T`) — The parameter to pass to the SQL action
  - `sqlAction` (`Throwables.Function<? super T, ? extends R, Exception>`) — The SQL action that takes a parameter and produces a result
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the sqlAction is {@code null}
- **Signature:** `@Beta public static <T, U, R> ContinuableFuture<R> asyncCall(final T parameter1, final U parameter2, final Throwables.BiFunction<? super T, ? super U, ? extends R, Exception> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously calls the specified SQL action with two parameters and returns a result.
- **Parameters:**
  - `parameter1` (`T`) — The first parameter to pass to the SQL action
  - `parameter2` (`U`) — The second parameter to pass to the SQL action
  - `sqlAction` (`Throwables.BiFunction<? super T, ? super U, ? extends R, Exception>`) — The SQL action that takes two parameters and produces a result
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the sqlAction is {@code null}
- **Signature:** `@Beta public static <A, B, C, R> ContinuableFuture<R> asyncCall(final A parameter1, final B parameter2, final C parameter3, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, Exception> sqlAction) throws IllegalArgumentException`
- **Summary:** Asynchronously calls the specified SQL action with three parameters and returns a result.
- **Parameters:**
  - `parameter1` (`A`) — The first parameter to pass to the SQL action
  - `parameter2` (`B`) — The second parameter to pass to the SQL action
  - `parameter3` (`C`) — The third parameter to pass to the SQL action
  - `sqlAction` (`Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, Exception>`) — The SQL action that takes three parameters and produces a result
- **Returns:** A ContinuableFuture representing the result of the asynchronous computation
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the sqlAction is {@code null}
##### getOutParameters(...) -> OutParamResult
- **Signature:** `public static OutParamResult getOutParameters(final CallableStatement stmt, final List<OutParam> outParams) throws IllegalArgumentException, SQLException`
- **Summary:** Retrieves the output parameters from the given CallableStatement.
- **Parameters:**
  - `stmt` (`CallableStatement`) — The CallableStatement from which to retrieve the output parameters
  - `outParams` (`List<OutParam>`) — The list of OutParam objects representing the output parameters to retrieve
- **Returns:** An OutParamResult containing the retrieved output parameter values
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the provided arguments are invalid
  - `java.sql.SQLException` — if a SQL exception occurs while retrieving the output parameters
##### getNamedParameters(...) -> List<String>
- **Signature:** `public static List<String> getNamedParameters(final String sql)`
- **Summary:** Extracts the named parameters from the given SQL string.
- **Parameters:**
  - `sql` (`String`) — the SQL string containing named parameters (e.g., :paramName)
- **Returns:** a list of named parameter names found in the SQL string (without the ':' prefix)
##### parseSql(...) -> ParsedSql
- **Signature:** `public static ParsedSql parseSql(final String sql)`
- **Summary:** Parses the given SQL string and returns a ParsedSql object.
- **Parameters:**
  - `sql` (`String`) — the SQL string to be parsed
- **Returns:** a ParsedSql object containing parsed information about the SQL string
- **See also:** ParsedSql#parse(String)
##### getInsertPropNames(...) -> Collection<String>
- **Signature:** `public static Collection<String> getInsertPropNames(final Object entity)`
- **Summary:** Returns the property names suitable for INSERT operations for the given entity.
- **Contract:**
  - This method returns all property names that should be included in an INSERT statement, excluding properties marked with annotations like @ReadOnly, @Id (for auto-generated IDs), etc.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User(); Collection<String> propNames = JdbcUtil.getInsertPropNames(user); // Returns property names that should be included in INSERT statement } </pre>
- **Parameters:**
  - `entity` (`Object`) — the entity object to analyze
- **Returns:** a collection of property names suitable for INSERT operations
- **Signature:** `@SuppressWarnings("deprecation") public static Collection<String> getInsertPropNames(final Object entity, final Set<String> excludedPropNames)`
- **Summary:** Returns the property names suitable for INSERT operations for the given entity, excluding the specified property names.
- **Parameters:**
  - `entity` (`Object`) — the entity object to analyze
  - `excludedPropNames` (`Set<String>`) — property names to exclude from the result
- **Returns:** a collection of property names suitable for INSERT operations
- **Signature:** `public static Collection<String> getInsertPropNames(final Class<?> entityClass)`
- **Summary:** Returns the property names suitable for INSERT operations for the given entity class.
- **Contract:**
  - This method analyzes the class structure to determine which properties should be included in INSERT statements.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Collection<String> propNames = JdbcUtil.getInsertPropNames(User.class); // Returns property names that should be included in INSERT statement for User entities } </pre>
- **Parameters:**
  - `entityClass` (`Class<?>`) — the entity class to analyze
- **Returns:** a collection of property names suitable for INSERT operations
- **Signature:** `@SuppressWarnings("deprecation") public static Collection<String> getInsertPropNames(final Class<?> entityClass, final Set<String> excludedPropNames)`
- **Summary:** Returns the property names suitable for INSERT operations for the given entity class, excluding the specified property names.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the entity class to analyze
  - `excludedPropNames` (`Set<String>`) — property names to exclude from the result
- **Returns:** a collection of property names suitable for INSERT operations
##### getSelectPropNames(...) -> Collection<String>
- **Signature:** `public static Collection<String> getSelectPropNames(final Class<?> entityClass)`
- **Summary:** Gets the property names suitable for SELECT operations for the given entity class.
- **Contract:**
  - This method returns all property names that should be included in a SELECT statement, excluding properties marked with @Transient or other exclusion annotations.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Collection<String> propNames = JdbcUtil.getSelectPropNames(User.class); // Returns property names that should be included in SELECT statement } </pre>
- **Parameters:**
  - `entityClass` (`Class<?>`) — the entity class to analyze
- **Returns:** a collection of property names suitable for SELECT operations
- **Signature:** `public static Collection<String> getSelectPropNames(final Class<?> entityClass, final Set<String> excludedPropNames)`
- **Summary:** Gets the property names suitable for SELECT operations for the given entity class, excluding the specified property names.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the entity class to analyze
  - `excludedPropNames` (`Set<String>`) — property names to exclude from the result
- **Returns:** a collection of property names suitable for SELECT operations
- **Signature:** `@SuppressWarnings("deprecation") public static Collection<String> getSelectPropNames(final Class<?> entityClass, final boolean includeSubEntityProperties, final Set<String> excludedPropNames)`
- **Summary:** Gets the property names suitable for SELECT operations for the given entity class, with an option to include sub-entity properties and exclude specified property names.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the entity class to analyze
  - `includeSubEntityProperties` (`boolean`) — whether to include properties of sub-entities
  - `excludedPropNames` (`Set<String>`) — property names to exclude from the result
- **Returns:** a collection of property names suitable for SELECT operations
##### getUpdatePropNames(...) -> Collection<String>
- **Signature:** `public static Collection<String> getUpdatePropNames(final Class<?> entityClass)`
- **Summary:** Gets the property names suitable for UPDATE operations for the given entity class.
- **Contract:**
  - This method returns all property names that should be included in an UPDATE statement, excluding properties marked with @ReadOnly, @NonUpdatable, @Id, etc.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the entity class to analyze
- **Returns:** a collection of property names suitable for UPDATE operations
- **Signature:** `@SuppressWarnings("deprecation") public static Collection<String> getUpdatePropNames(final Class<?> entityClass, final Set<String> excludedPropNames)`
- **Summary:** Gets the property names suitable for UPDATE operations for the given entity class, excluding the specified property names.
- **Parameters:**
  - `entityClass` (`Class<?>`) — the entity class to analyze
  - `excludedPropNames` (`Set<String>`) — property names to exclude from the result
- **Returns:** a collection of property names suitable for UPDATE operations
##### blob2String(...) -> String
- **Signature:** `public static String blob2String(final Blob blob) throws SQLException`
- **Summary:** Converts a Blob to a String using UTF-8 encoding and frees the Blob resources.
- **Parameters:**
  - `blob` (`Blob`) — the Blob object to be converted to a String
- **Returns:** the String representation of the Blob content
- **Throws:**
  - `java.sql.SQLException` — if a SQL exception occurs while accessing the Blob
- **Signature:** `public static String blob2String(final Blob blob, final Charset charset) throws SQLException`
- **Summary:** Converts a Blob to a String using the specified character encoding and frees the Blob resources.
- **Parameters:**
  - `blob` (`Blob`) — the Blob object to be converted to a String
  - `charset` (`Charset`) — the character encoding to use for the conversion
- **Returns:** the String representation of the Blob content
- **Throws:**
  - `java.sql.SQLException` — if a SQL exception occurs while accessing the Blob
##### writeBlobToFile(...) -> long
- **Signature:** `public static long writeBlobToFile(final Blob blob, final File output) throws SQLException, IOException`
- **Summary:** Writes the content of a Blob to a file and frees the Blob resources.
- **Parameters:**
  - `blob` (`Blob`) — the Blob object containing the data to be written
  - `output` (`File`) — the File object representing the output file
- **Returns:** the number of bytes written to the file
- **Throws:**
  - `java.sql.SQLException` — if a SQL exception occurs while accessing the Blob
  - `java.io.IOException` — if an I/O error occurs while writing to the file
##### clob2String(...) -> String
- **Signature:** `public static String clob2String(final Clob clob) throws SQLException`
- **Summary:** Converts a Clob to a String and frees the Clob resources.
- **Parameters:**
  - `clob` (`Clob`) — the Clob object to be converted to a String
- **Returns:** the String representation of the Clob content
- **Throws:**
  - `java.sql.SQLException` — if a SQL exception occurs while accessing the Clob
##### writeClobToFile(...) -> long
- **Signature:** `public static long writeClobToFile(final Clob clob, final File output) throws SQLException, IOException`
- **Summary:** Writes the content of a Clob to a file and frees the Clob resources.
- **Parameters:**
  - `clob` (`Clob`) — the Clob object containing the data to be written
  - `output` (`File`) — the File object representing the output file
- **Returns:** the number of characters written to the file
- **Throws:**
  - `java.sql.SQLException` — if a SQL exception occurs while accessing the Clob
  - `java.io.IOException` — if an I/O exception occurs while writing to the file
##### isNullOrDefault(...) -> boolean
- **Signature:** `public static boolean isNullOrDefault(final Object value)`
- **Summary:** Checks if the given value is {@code null} or equals the default value for its type.
- **Contract:**
  - Checks if the given value is {@code null} or equals the default value for its type.
- **Parameters:**
  - `value` (`Object`) — the value to check
- **Returns:** {@code true} if the value is {@code null} or the default value for its type, {@code false} otherwise
##### turnOffSqlLogGlobally(...) -> void
- **Signature:** `public static void turnOffSqlLogGlobally()`
- **Summary:** Globally disables SQL logging across all threads in the application.
- **Parameters:**
  - (none)
##### turnOffSqlPerfLogGlobally(...) -> void
- **Signature:** `public static void turnOffSqlPerfLogGlobally()`
- **Summary:** Globally disables SQL performance logging across all threads in the application.
- **Parameters:**
  - (none)
##### turnOffDaoMethodPerfLogGlobally(...) -> void
- **Signature:** `public static void turnOffDaoMethodPerfLogGlobally()`
- **Summary:** Globally disables DAO method performance logging across all threads in the application.
- **Parameters:**
  - (none)
##### enableSqlLog(...) -> void
- **Signature:** `public static void enableSqlLog()`
- **Summary:** Enables SQL logging for the current thread with the default maximum log length.
- **Contract:**
  - When enabled, all SQL statements executed in the current thread will be logged.
- **Parameters:**
  - (none)
- **Signature:** `public static void enableSqlLog(final int maxSqlLogLength)`
- **Summary:** Enables SQL logging for the current thread with a specified maximum log length.
- **Parameters:**
  - `maxSqlLogLength` (`int`) — the maximum length of SQL statements in logs
##### disableSqlLog(...) -> void
- **Signature:** `public static void disableSqlLog()`
- **Summary:** Disables SQL logging for the current thread.
- **Contract:**
  - The maximum SQL log length setting is preserved for when logging is re-enabled.
- **Parameters:**
  - (none)
##### isSqlLogEnabled(...) -> boolean
- **Signature:** `public static boolean isSqlLogEnabled()`
- **Summary:** Checks if SQL logging is enabled for the current thread.
- **Contract:**
  - Checks if SQL logging is enabled for the current thread.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.isSqlLogEnabled()) { System.out.println("SQL logging is active"); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if SQL logging is enabled in the current thread, {@code false} otherwise
##### getSqlExtractor(...) -> Throwables.Function<Statement, String, SQLException>
- **Signature:** `public static Throwables.Function<Statement, String, SQLException> getSqlExtractor()`
- **Summary:** Retrieves the current SQL extractor function used to extract SQL statements from Statement objects.
- **Parameters:**
  - (none)
- **Returns:** the current SQL extractor function
##### setSqlExtractor(...) -> void
- **Signature:** `public static void setSqlExtractor(final Throwables.Function<Statement, String, SQLException> sqlExtractor)`
- **Summary:** Sets a custom SQL extractor function to extract SQL statements from Statement objects.
- **Contract:**
  - This is useful when using custom Statement implementations or when the default extraction method doesn't work for your JDBC driver.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code JdbcUtil.setSqlExtractor(statement -> { if (statement instanceof MyCustomStatement) { return ((MyCustomStatement) statement).getOriginalSql(); } return statement.toString(); }); } </pre>
- **Parameters:**
  - `sqlExtractor` (`Throwables.Function<Statement, String, SQLException>`) — the SQL extractor function to set
##### getSqlLogHandler(...) -> TriConsumer<String, Long, Long>
- **Signature:** `public static TriConsumer<String, Long, Long> getSqlLogHandler()`
- **Summary:** Retrieves the current SQL log handler that processes SQL statements and their execution times.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code TriConsumer<String, Long, Long> handler = JdbcUtil.getSqlLogHandler(); if (handler != null) { // Handler is configured } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the current SQL log handler, or {@code null} if none is set
##### setSqlLogHandler(...) -> void
- **Signature:** `public static void setSqlLogHandler(final TriConsumer<String, Long, Long> sqlLogHandler)`
- **Summary:** Sets a custom SQL log handler to process SQL statements and their execution times.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code JdbcUtil.setSqlLogHandler((sql, startTime, endTime) -> { long duration = endTime - startTime; if (duration > 1000) { // Log slow queries logger.warn("Slow query ({}ms): {}", duration, sql); } // Send metrics to monitoring system metricsCollector.recordSqlExecution(sql, duration); }); } </pre>
- **Parameters:**
  - `sqlLogHandler` (`TriConsumer<String, Long, Long>`) — the handler that receives: SQL statement, start time (ms), end time (ms)
##### setMinExecutionTimeForSqlPerfLog(...) -> void
- **Signature:** `public static void setMinExecutionTimeForSqlPerfLog(final long minExecutionTimeForSqlPerfLog)`
- **Summary:** Sets the minimum execution time threshold for SQL performance logging in the current thread.
- **Parameters:**
  - `minExecutionTimeForSqlPerfLog` (`long`) — the minimum execution time in milliseconds
- **Signature:** `public static void setMinExecutionTimeForSqlPerfLog(final long minExecutionTimeForSqlPerfLog, final int maxSqlLogLength)`
- **Summary:** Sets the minimum execution time threshold for SQL performance logging in the current thread with a specified maximum SQL log length.
- **Parameters:**
  - `minExecutionTimeForSqlPerfLog` (`long`) — the minimum execution time in milliseconds (use -1 to disable)
  - `maxSqlLogLength` (`int`) — the maximum length of SQL statements in performance logs
##### getMinExecutionTimeForSqlPerfLog(...) -> long
- **Signature:** `public static long getMinExecutionTimeForSqlPerfLog()`
- **Summary:** Gets the current minimum execution time threshold for SQL performance logging in the current thread.
- **Parameters:**
  - (none)
- **Returns:** the minimum execution time in milliseconds (default is 1000ms)
##### runWithSqlLogDisabled(...) -> void
- **Signature:** `public static <E extends Exception> void runWithSqlLogDisabled(final Throwables.Runnable<E> sqlAction) throws E`
- **Summary:** Executes the specified action with SQL logging temporarily disabled.
- **Contract:**
  - Note: The SQL action should not be executed in another thread as the logging flag is thread-local.
- **Parameters:**
  - `sqlAction` (`Throwables.Runnable<E>`) — the action to execute without SQL logging
- **Throws:**
  - `E` — if the action throws an exception
##### callWithSqlLogDisabled(...) -> R
- **Signature:** `public static <R, E extends Exception> R callWithSqlLogDisabled(final Throwables.Callable<R, E> sqlAction) throws E`
- **Summary:** Executes the specified callable with SQL logging temporarily disabled and returns its result.
- **Contract:**
  - Note: The SQL action should not be executed in another thread as the logging flag is thread-local.
- **Parameters:**
  - `sqlAction` (`Throwables.Callable<R, E>`) — the callable to execute without SQL logging
- **Returns:** the result of the callable
- **Throws:**
  - `E` — if the callable throws an exception
##### isInTransaction(...) -> boolean
- **Signature:** `public static boolean isInTransaction(final javax.sql.DataSource ds)`
- **Summary:** Checks if there is an active transaction for the given DataSource in the current thread.
- **Contract:**
  - Checks if there is an active transaction for the given DataSource in the current thread.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.isInTransaction(dataSource)) { // Execute operations within the existing transaction } else { // Start a new transaction SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); // ...
- **Parameters:**
  - `ds` (`javax.sql.DataSource`) — the DataSource to check for an active transaction
- **Returns:** {@code true} if there is an active transaction, {@code false} otherwise
##### beginTransaction(...) -> SQLTransaction
- **Signature:** `public static SQLTransaction beginTransaction(final javax.sql.DataSource dataSource) throws UncheckedSQLException`
- **Summary:** Begins a new database transaction with the default isolation level for the specified DataSource.
- **Contract:**
  - <p> The transaction must be explicitly committed via {@code commit()} to persist changes, or rolled back via {@code rollback()} or {@code rollbackIfNotCommitted()} to discard changes.
  - Always use a try-finally block to ensure the transaction is properly completed even if exceptions occur.
  - </p> <p> <b> Spring Integration: </b> </p> <p> If Spring's transaction management is active, JdbcUtil will automatically participate in the Spring transaction instead of creating a new one.
  - AND balance >= ?", amount, accountId, amount); if (updatedRows == 0) { throw new InsufficientFundsException("Insufficient balance"); } JdbcUtil.executeUpdate(dataSource, "INSERT INTO transactions (account_id, amount, type) VALUES (?, ?, ?)", accountId, amount, "DEBIT"); tran.commit(); } catch (Exception e) { // Transaction automatically rolled back in finally block logger.error("Transaction failed: " + e.getMessage()); throw e; } finally { tran.rollbackIfNotCommitted(); } // Transaction shared across method calls public void processOrder(Order order) { SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); try { createOrder(order); // Shares this transaction updateInventory(order); // Shares this transaction sendNotification(order); // Shares this transaction tran.commit(); } finally { tran.rollbackIfNotCommitted(); } } private void createOrder(Order order) { // This automatically uses the transaction from processOrder() JdbcUtil.executeUpdate(dataSource, "INSERT INTO orders (id, customer_id, total) VALUES (?, ?, ?)", order.getId(), order.getCustomerId(), order.getTotal()); } } </pre>
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the {@link javax.sql.DataSource} for which to begin the transaction, must not be {@code null}
- **Returns:** a {@link SQLTransaction} object representing the new transaction that must be committed or rolled back
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs while beginning the transaction
- **See also:** #beginTransaction(javax.sql.DataSource, IsolationLevel), #beginTransaction(javax.sql.DataSource, IsolationLevel, boolean), SQLTransaction#commit(), SQLTransaction#rollback(), SQLTransaction#rollbackIfNotCommitted()
- **Signature:** `public static SQLTransaction beginTransaction(final javax.sql.DataSource dataSource, final IsolationLevel isolationLevel) throws UncheckedSQLException`
- **Summary:** Begins a new transaction with the specified isolation level for the given DataSource.
- **Contract:**
  - The transaction must be explicitly committed or rolled back.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource for which to begin the transaction
  - `isolationLevel` (`IsolationLevel`) — the isolation level for the transaction
- **Returns:** a SQLTransaction object representing the new transaction
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a SQL exception occurs while beginning the transaction
- **See also:** #beginTransaction(javax.sql.DataSource, IsolationLevel, boolean)
- **Signature:** `public static SQLTransaction beginTransaction(final javax.sql.DataSource dataSource, final IsolationLevel isolationLevel, final boolean isForUpdateOnly) throws UncheckedSQLException`
- **Summary:** Starts a global transaction which will be shared by all in-line database queries with the same DataSource in the same thread.
- **Contract:**
  - If a Spring transaction is already active with the specified DataSource, the Connection from the Spring transaction will be used.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource for which to begin the transaction
  - `isolationLevel` (`IsolationLevel`) — the isolation level for the transaction
  - `isForUpdateOnly` (`boolean`) — whether this transaction is only for update operations
- **Returns:** a SQLTransaction object representing the transaction
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a SQL exception occurs while beginning the transaction
- **See also:** JdbcUtil#getConnection(javax.sql.DataSource), JdbcUtil#releaseConnection(Connection, javax.sql.DataSource)
##### callInTransaction(...) -> T
- **Signature:** `@Beta public static <T, E extends Throwable> T callInTransaction(final javax.sql.DataSource dataSource, final Throwables.Callable<T, E> cmd) throws IllegalArgumentException, E`
- **Summary:** Executes the given callable within a transaction and returns its result.
- **Contract:**
  - If the callable completes successfully, the transaction is committed.
  - If an exception occurs, the transaction is rolled back.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource for the transaction
  - `cmd` (`Throwables.Callable<T, E>`) — the callable to execute within the transaction
- **Returns:** the result of the callable execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — if dataSource or cmd is null
  - `E` — if the callable throws an exception
- **Signature:** `@Beta public static <T, E extends Throwable> T callInTransaction(final javax.sql.DataSource dataSource, final Throwables.Function<Connection, T, E> cmd) throws E`
- **Summary:** Executes the given function within a transaction, providing the transaction's connection.
- **Contract:**
  - If the function completes successfully, the transaction is committed.
  - If an exception occurs, the transaction is rolled back.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource for the transaction
  - `cmd` (`Throwables.Function<Connection, T, E>`) — the function to execute with the transaction's connection
- **Returns:** the result of the function execution
- **Throws:**
  - `E` — if the function throws an exception
##### runInTransaction(...) -> void
- **Signature:** `@Beta public static <E extends Throwable> void runInTransaction(final javax.sql.DataSource dataSource, final Throwables.Runnable<E> cmd) throws IllegalArgumentException, E`
- **Summary:** Executes the given runnable within a transaction.
- **Contract:**
  - If the runnable completes successfully, the transaction is committed.
  - If an exception occurs, the transaction is rolled back.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource for the transaction
  - `cmd` (`Throwables.Runnable<E>`) — the runnable to execute within the transaction
- **Throws:**
  - `java.lang.IllegalArgumentException` — if dataSource or cmd is null
  - `E` — if the runnable throws an exception
- **Signature:** `@Beta public static <E extends Throwable> void runInTransaction(final javax.sql.DataSource dataSource, final Throwables.Consumer<Connection, E> cmd) throws IllegalArgumentException, E`
- **Summary:** Executes the given consumer within a transaction, providing the transaction's connection.
- **Contract:**
  - If the consumer completes successfully, the transaction is committed.
  - If an exception occurs, the transaction is rolled back.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource for the transaction
  - `cmd` (`Throwables.Consumer<Connection, E>`) — the consumer to execute with the transaction's connection
- **Throws:**
  - `java.lang.IllegalArgumentException` — if dataSource or cmd is null
  - `E` — if the consumer throws an exception
##### callNotInStartedTransaction(...) -> T
- **Signature:** `@Beta public static <T, E extends Throwable> T callNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Callable<T, E> cmd) throws IllegalArgumentException, E`
- **Summary:** Executes the given callable outside any active transaction for the specified DataSource.
- **Contract:**
  - If a transaction is active in the current thread, a new connection (not part of the transaction) will be used to execute the callable.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource to use
  - `cmd` (`Throwables.Callable<T, E>`) — the callable to execute outside any transaction
- **Returns:** the result of the callable execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — if dataSource or cmd is null
  - `E` — if the callable throws an exception
- **Signature:** `@Beta public static <T, E extends Throwable> T callNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Function<javax.sql.DataSource, T, E> cmd) throws IllegalArgumentException, E`
- **Summary:** Executes the given function outside any active transaction for the specified DataSource.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource to use
  - `cmd` (`Throwables.Function<javax.sql.DataSource, T, E>`) — the function to execute outside any transaction
- **Returns:** the result of the function execution
- **Throws:**
  - `java.lang.IllegalArgumentException` — if dataSource or cmd is null
  - `E` — if the function throws an exception
##### runNotInStartedTransaction(...) -> void
- **Signature:** `@Beta public static <E extends Throwable> void runNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Runnable<E> cmd) throws IllegalArgumentException, E`
- **Summary:** Executes the given runnable outside any active transaction for the specified DataSource.
- **Contract:**
  - If a transaction is active in the current thread, a new connection (not part of the transaction) will be used to execute the runnable.
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource to use
  - `cmd` (`Throwables.Runnable<E>`) — the runnable to execute outside any transaction
- **Throws:**
  - `java.lang.IllegalArgumentException` — if dataSource or cmd is null
  - `E` — if the runnable throws an exception
- **Signature:** `@Beta public static <E extends Throwable> void runNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Consumer<javax.sql.DataSource, E> cmd) throws IllegalArgumentException, E`
- **Summary:** Executes the given consumer outside any active transaction for the specified DataSource.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code JdbcUtil.runNotInStartedTransaction(dataSource, ds -> { // Use the DataSource for non-transactional operations try (Connection conn = ds.getConnection()) { // Perform operations that should not be part of current transaction } }); } </pre>
- **Parameters:**
  - `dataSource` (`javax.sql.DataSource`) — the DataSource to use
  - `cmd` (`Throwables.Consumer<javax.sql.DataSource, E>`) — the consumer to execute outside any transaction
- **Throws:**
  - `java.lang.IllegalArgumentException` — if dataSource or cmd is null
  - `E` — if the consumer throws an exception
##### runWithoutUsingSpringTransaction(...) -> void
- **Signature:** `public static <E extends Exception> void runWithoutUsingSpringTransaction(final Throwables.Runnable<E> sqlAction) throws E`
- **Summary:** Executes the given runnable without using Spring transaction management.
- **Contract:**
  - Note: The action should not be executed in another thread as the flag is thread-local.
- **Parameters:**
  - `sqlAction` (`Throwables.Runnable<E>`) — the runnable to execute without Spring transaction
- **Throws:**
  - `E` — if the runnable throws an exception
##### callWithoutUsingSpringTransaction(...) -> R
- **Signature:** `public static <R, E extends Exception> R callWithoutUsingSpringTransaction(final Throwables.Callable<R, E> sqlAction) throws E`
- **Summary:** Executes the given callable without using Spring transaction management and returns its result.
- **Contract:**
  - Note: The action should not be executed in another thread as the flag is thread-local.
- **Parameters:**
  - `sqlAction` (`Throwables.Callable<R, E>`) — the callable to execute without Spring transaction
- **Returns:** the result of the callable
- **Throws:**
  - `E` — if the callable throws an exception
##### setIdExtractorForDao(...) -> void
- **Signature:** `public static <T, ID, SB extends SQLBuilder, TD extends CrudDao<T, ID, SB, TD>> void setIdExtractorForDao( final Class<? extends CrudDao<T, ID, SB, TD>> daoInterface, final RowMapper<? extends ID> idExtractor) throws IllegalArgumentException`
- **Summary:** Sets the ID extractor for the specified DAO interface.
- **Contract:**
  - The extractor is used when retrieving generated keys after insert operations.
- **Parameters:**
  - `daoInterface` (`Class<? extends CrudDao<T, ID, SB, TD>>`) — the DAO interface class
  - `idExtractor` (`RowMapper<? extends ID>`) — the RowMapper used to extract the ID from ResultSet
- **Throws:**
  - `java.lang.IllegalArgumentException` — if daoInterface or idExtractor is null
- **Signature:** `public static <T, ID, SB extends SQLBuilder, TD extends CrudDao<T, ID, SB, TD>> void setIdExtractorForDao( final Class<? extends CrudDao<T, ID, SB, TD>> daoInterface, final BiRowMapper<? extends ID> idExtractor) throws IllegalArgumentException`
- **Summary:** Sets the ID extractor for the specified DAO interface using a BiRowMapper.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Custom ID extraction with column label awareness JdbcUtil.setIdExtractorForDao(UserDao.class, (rs, columnLabels) -> { if (columnLabels.contains("composite_id")) { return UserIdParser.parse(rs.getString("composite_id")); } return rs.getLong("id"); }); } </pre>
- **Parameters:**
  - `daoInterface` (`Class<? extends CrudDao<T, ID, SB, TD>>`) — the DAO interface class
  - `idExtractor` (`BiRowMapper<? extends ID>`) — the BiRowMapper used to extract the ID with column information
- **Throws:**
  - `java.lang.IllegalArgumentException` — if daoInterface or idExtractor is null
##### createDao(...) -> TD
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds)`
- **Summary:** Creates a dynamic Data Access Object (DAO) implementation for the specified interface and DataSource.
- **Contract:**
  - ORDER BY created_at DESC") List<User> findByStatus(String status); @NamedSelect("SELECT * FROM users WHERE age >= :minAge AND city = :city") Stream<User> findByAgeAndCity(@Bind("minAge") int minAge, @Bind("city") String city); } // Create and use the DAO UserDao userDao = JdbcUtil.createDao(UserDao.class, dataSource); // Use inherited CRUD operations User newUser = new User("john@example.com", "John Doe"); userDao.save(newUser); // Use custom query methods Optional<User> user = userDao.findByEmail("john@example.com"); if (user.isPresent()) { System.out.println("Found: " + user.get().getName()); } // List all active users List<User> activeUsers = userDao.findByStatus("ACTIVE"); // Stream results for large datasets try (Stream<User> stream = userDao.findByAgeAndCity(25, "New York")) { long count = stream .filter(u -> u.getEmail().endsWith("@company.com")) .count(); } // Batch operations List<User> users = Arrays.asList(user1, user2, user3); userDao.batchSave(users); // Update operations user.get().setStatus("INACTIVE"); userDao.update(user.get()); // Delete operations userDao.deleteById(userId); } </pre> <p> <b> Advanced DAO Features: </b> </p> <pre> {@code // Define a DAO with complex queries public interface OrderDao extends CrudDao<Order, Long, SQLBuilder.PSC, OrderDao> { // Aggregate queries @Select("SELECT COUNT(*) FROM orders WHERE status = ?") long countByStatus(String status); @Select("SELECT SUM(total_amount) FROM orders WHERE customer_id = ?") Optional<BigDecimal> getTotalByCustomer(Long customerId); // Complex joins (SQL defined externally in SQL mapper file) @NamedSelect("findOrdersWithCustomerDetails") List<OrderWithCustomer> findOrdersWithCustomerDetails(@Bind("startDate") Date start); // Async operations @Select("SELECT * FROM orders WHERE id = ?") CompletableFuture<Optional<Order>> findByIdAsync(Long id); } OrderDao orderDao = JdbcUtil.createDao(OrderDao.class, dataSource); // Use aggregate queries long pendingCount = orderDao.countByStatus("PENDING"); // Async operations CompletableFuture<Optional<Order>> future = orderDao.findByIdAsync(orderId); future.thenAccept(order -> { order.ifPresent(o -> System.out.println("Order: " + o.getId())); }); } </pre>
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement, must not be {@code null} . The interface should extend {@link Dao} or {@link CrudDao} and define the entity type and ID type
  - `ds` (`javax.sql.DataSource`) — the {@link javax.sql.DataSource} to use for all database operations, must not be {@code null}
- **Returns:** a dynamically generated DAO instance implementing the specified interface with full CRUD capabilities
- **See also:** Dao, CrudDao, #createDao(Class, javax.sql.DataSource, SQLMapper), #createDao(Class, javax.sql.DataSource, Executor)
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper)`
- **Summary:** Creates a DAO instance with a custom SQL mapper for query externalization.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@Deprecated @SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache daoCache)`
- **Summary:** Creates a DAO instance with a custom SQL mapper and DAO cache.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
  - `daoCache` (`Jdbc.DaoCache`) — the cache for DAO operations (should not be shared between DAOs)
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final Executor executor)`
- **Summary:** Creates a DAO instance with a custom executor for asynchronous operations.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `executor` (`Executor`) — the executor for asynchronous operations
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Executor executor)`
- **Summary:** Creates a DAO instance with a custom SQL mapper and executor.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
  - `executor` (`Executor`) — the executor for asynchronous operations
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@Deprecated @SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache daoCache, final Executor executor)`
- **Summary:** Creates a DAO instance with all customization options.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
  - `daoCache` (`Jdbc.DaoCache`) — the cache for DAO operations (should not be shared between DAOs)
  - `executor` (`Executor`) — the executor for asynchronous operations
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds)`
- **Summary:** Creates a DAO instance for a specific table name.
- **Contract:**
  - This is useful when the table name differs from the entity class name.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `targetTableName` (`String`) — the specific table name to use
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper)`
- **Summary:** Creates a DAO instance for a specific table with a custom SQL mapper.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `targetTableName` (`String`) — the specific table name to use
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@Deprecated @SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache daoCache)`
- **Summary:** Creates a DAO instance for a specific table with SQL mapper and cache.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `targetTableName` (`String`) — the specific table name to use
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
  - `daoCache` (`Jdbc.DaoCache`) — the cache for DAO operations
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final Executor executor)`
- **Summary:** Creates a DAO instance for a specific table with a custom executor.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `targetTableName` (`String`) — the specific table name to use
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `executor` (`Executor`) — the executor for asynchronous operations
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Executor executor)`
- **Summary:** Creates a DAO instance for a specific table with SQL mapper and executor.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `targetTableName` (`String`) — the specific table name to use
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
  - `executor` (`Executor`) — the executor for asynchronous operations
- **Returns:** a DAO instance implementing the specified interface
- **Signature:** `@Deprecated @SuppressWarnings("rawtypes") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache cache, final Executor executor) throws IllegalArgumentException`
- **Summary:** Creates a DAO instance with all customization options including table name.
- **Parameters:**
  - `daoInterface` (`Class<TD>`) — the DAO interface class to implement
  - `targetTableName` (`String`) — the specific table name to use
  - `ds` (`javax.sql.DataSource`) — the DataSource to use for database operations
  - `sqlMapper` (`SQLMapper`) — the SQL mapper for externalizing queries
  - `cache` (`Jdbc.DaoCache`) — the cache for DAO operations (should not be shared between DAOs)
  - `executor` (`Executor`) — the executor for asynchronous operations
- **Returns:** a DAO instance implementing the specified interface
- **Throws:**
  - `java.lang.IllegalArgumentException` — if required parameters are invalid
##### startDaoCacheOnCurrentThread(...) -> Jdbc.DaoCache
- **Signature:** `public static Jdbc.DaoCache startDaoCacheOnCurrentThread()`
- **Summary:** Enables DAO query result caching for the current thread.
- **Contract:**
  - Must be paired with {@link #closeDaoCacheOnCurrentThread()} to prevent memory leaks.
- **Parameters:**
  - (none)
- **Returns:** the created DaoCache for the current thread
- **See also:** Jdbc.DaoCache#createByMap(), #closeDaoCacheOnCurrentThread()
- **Signature:** `public static Jdbc.DaoCache startDaoCacheOnCurrentThread(final Jdbc.DaoCache localThreadCache)`
- **Summary:** Enables the specified DAO cache for the current thread.
- **Contract:**
  - Must be paired with {@link #closeDaoCacheOnCurrentThread()} to prevent memory leaks.
- **Parameters:**
  - `localThreadCache` (`Jdbc.DaoCache`) — the cache to use for the current thread
- **Returns:** the specified localThreadCache
- **See also:** Jdbc.DaoCache#createByMap(), Jdbc.DaoCache#createByMap(Map), #closeDaoCacheOnCurrentThread()
##### closeDaoCacheOnCurrentThread(...) -> void
- **Signature:** `public static void closeDaoCacheOnCurrentThread()`
- **Summary:** Closes and removes the DAO cache for the current thread.
- **Contract:**
  - This method should always be called in a finally block after starting a thread-local cache to prevent memory leaks.
- **Parameters:**
  - (none)
- **See also:** #startDaoCacheOnCurrentThread(), #startDaoCacheOnCurrentThread(Jdbc.DaoCache)

#### Public Instance Methods
- (none)

### Class JdbcUtils (com.landawn.abacus.jdbc.JdbcUtils)
A comprehensive, enterprise-grade utility class providing advanced database import/export operations, data migration capabilities, and high-performance batch processing for seamless data movement between databases, CSV files, and in-memory datasets.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### importData(...) -> int
- **Signature:** `public static int importData(final Dataset dataset, final javax.sql.DataSource sourceDataSource, final String insertSql) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table using the provided DataSource and insert SQL statement.
- **Contract:**
  - The column order in the SQL statement must be consistent with the column order in the Dataset.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the Dataset
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static int importData(final Dataset dataset, final Connection conn, final String insertSql) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table using the provided Connection and insert SQL statement.
- **Contract:**
  - The column order in the SQL statement must be consistent with the column order in the Dataset.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the Dataset
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Connection conn, final String insertSql) throws SQLException`
- **Summary:** Imports selected columns from a Dataset to a database table using the provided Connection and insert SQL statement.
- **Contract:**
  - Only the specified columns will be imported, and their order in the SQL must match the Dataset column order.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be selected for import
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the selected columns
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis) throws SQLException`
- **Summary:** Imports selected columns from a Dataset to a database table with configurable batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be selected for import
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the selected columns
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static <E extends Exception> int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Throwables.Predicate<? super Object[], E> filter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis) throws SQLException, E`
- **Summary:** Imports filtered data from a Dataset to a database table with configurable batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be selected for import
  - `filter` (`Throwables.Predicate<? super Object[], E>`) — a predicate to filter the rows; only rows returning {@code true} will be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the selected columns
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — if the filter throws an exception
- **Signature:** `@SuppressWarnings("rawtypes") public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final Map<String, ? extends Type> columnTypeMap) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table with custom column type mapping.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the Dataset
  - `columnTypeMap` (`Map<String, ? extends Type>`) — a map specifying the types of the columns for type conversion
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("rawtypes") public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table with custom column type mapping and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the Dataset
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `columnTypeMap` (`Map<String, ? extends Type>`) — a map specifying the types of the columns for type conversion
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("rawtypes") public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws SQLException, E`
- **Summary:** Imports filtered data from a Dataset to a database table with custom column type mapping and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `filter` (`Throwables.Predicate<? super Object[], E>`) — a predicate to filter the rows; only rows returning {@code true} will be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders; column order must match the Dataset
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `columnTypeMap` (`Map<String, ? extends Type>`) — a map specifying the types of the columns for type conversion
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — if the filter throws an exception
- **Signature:** `public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table with a custom statement setter.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>`) — a BiConsumer to set the parameters of the PreparedStatement for each row
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table with a custom statement setter and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>`) — a BiConsumer to set the parameters of the PreparedStatement for each row
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException, E`
- **Summary:** Imports filtered data from a Dataset to a database table with a custom statement setter and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `filter` (`Throwables.Predicate<? super Object[], E>`) — a predicate to filter the rows; only rows returning {@code true} will be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>`) — a BiConsumer to set the parameters of the PreparedStatement for each row
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — if the filter throws an exception
- **Signature:** `public static int importData(final Dataset dataset, final PreparedStatement stmt) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table using the provided PreparedStatement.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final PreparedStatement stmt) throws SQLException`
- **Summary:** Imports selected columns from a Dataset to a database table using the provided PreparedStatement.
- **Contract:**
  - Only the specified columns will be imported, and their order must match the PreparedStatement parameters.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be selected for import
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis) throws SQLException`
- **Summary:** Imports selected columns from a Dataset to a database table using the provided PreparedStatement with batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be selected for import
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static <E extends Exception> int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Throwables.Predicate<? super Object[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis) throws SQLException, E`
- **Summary:** Imports filtered data from selected columns of a Dataset to a database table using the provided PreparedStatement.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be selected for import
  - `filter` (`Throwables.Predicate<? super Object[], E>`) — a predicate to filter the rows; only rows returning {@code true} will be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — if the filter throws an exception
- **Signature:** `@SuppressWarnings("rawtypes") public static int importData(final Dataset dataset, final PreparedStatement stmt, final Map<String, ? extends Type> columnTypeMap) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table using the provided PreparedStatement with custom column type mapping.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `columnTypeMap` (`Map<String, ? extends Type>`) — a map specifying the types of the columns for type conversion
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("rawtypes") public static int importData(final Dataset dataset, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table using the provided PreparedStatement with custom column type mapping and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `columnTypeMap` (`Map<String, ? extends Type>`) — a map specifying the types of the columns for type conversion
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings({ "rawtypes", "null" }) public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws IllegalArgumentException, SQLException, E`
- **Summary:** Imports filtered data from a Dataset to a database table using the provided PreparedStatement with custom column type mapping and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `filter` (`Throwables.Predicate<? super Object[], E>`) — a predicate to filter the rows; only rows returning {@code true} will be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `columnTypeMap` (`Map<String, ? extends Type>`) — a map specifying the types of the columns for type conversion
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.lang.IllegalArgumentException` — if batchSize is not greater than 0 or batchIntervalInMillis is negative
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — if the filter throws an exception
- **Signature:** `public static int importData(final Dataset dataset, final PreparedStatement stmt, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table using the provided PreparedStatement with a custom statement setter.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>`) — a BiConsumer to set the parameters of the PreparedStatement for each row
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static int importData(final Dataset dataset, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException`
- **Summary:** Imports data from a Dataset to a database table using the provided PreparedStatement with a custom statement setter and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>`) — a BiConsumer to set the parameters of the PreparedStatement for each row
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws IllegalArgumentException, SQLException, E`
- **Summary:** Imports filtered data from a Dataset to a database table using the provided PreparedStatement with a custom statement setter and batch processing.
- **Parameters:**
  - `dataset` (`Dataset`) — the Dataset containing the data to be imported
  - `filter` (`Throwables.Predicate<? super Object[], E>`) — a predicate to filter the rows; only rows returning {@code true} will be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>`) — a BiConsumer to set the parameters of the PreparedStatement for each row
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.lang.IllegalArgumentException` — if batchSize is not greater than 0 or batchIntervalInMillis is negative
  - `java.sql.SQLException` — if a database access error occurs
  - `E` — if the filter throws an exception
- **Signature:** `public static <E extends Exception> long importData(final File file, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E`
- **Summary:** Imports data from a file to a database table using the provided DataSource and a line parser function.
- **Parameters:**
  - `file` (`File`) — the file containing the data to be imported
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections
  - `insertSql` (`String`) — the SQL insert statement with placeholders
  - `func` (`Throwables.Function<? super String, Object[], E>`) — a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
  - `E` — if the function throws an exception
- **Signature:** `public static <E extends Exception> long importData(final File file, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E`
- **Summary:** Imports data from a file to a database table using the provided Connection with batch processing and a line parser function.
- **Contract:**
  - This method provides control over batch size and interval for optimal performance when importing large files.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code File csvFile = new File("large_users.csv"); String insertSql = "INSERT INTO users (name, age, email) VALUES (?, ?, ?)"; Function<String, Object\[\]> parser = line -> { String\[\] parts = line.split(","); if (parts.length < 3) return null; // Skip invalid lines return new Object\[\] { parts\[0\], Integer.parseInt(parts\[1\]), parts\[2\] }; }; long rowsImported = JdbcUtils.importData(csvFile, connection, insertSql, 1000, 100, parser); } </pre>
- **Parameters:**
  - `file` (`File`) — the file containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `func` (`Throwables.Function<? super String, Object[], E>`) — a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
  - `E` — if the function throws an exception
- **Signature:** `public static <E extends Exception> long importData(final File file, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E`
- **Summary:** Imports data from a file to a database table using the provided PreparedStatement with batch processing and a line parser function.
- **Parameters:**
  - `file` (`File`) — the file containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `func` (`Throwables.Function<? super String, Object[], E>`) — a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
  - `E` — if the function throws an exception
- **Signature:** `public static <E extends Exception> long importData(final Reader reader, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.Function<? super String, Object[], E> line2Parameters) throws SQLException, IOException, E`
- **Summary:** Imports data from a Reader to a database table using the provided DataSource and a line parser function.
- **Parameters:**
  - `reader` (`Reader`) — the Reader containing the data to be imported
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections
  - `insertSql` (`String`) — the SQL insert statement with placeholders
  - `line2Parameters` (`Throwables.Function<? super String, Object[], E>`) — a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
  - `E` — if the function throws an exception
- **Signature:** `public static <E extends Exception> long importData(final Reader reader, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E`
- **Summary:** Imports data from a Reader to a database table using the provided Connection with batch processing and a line parser function.
- **Contract:**
  - This method provides control over batch size and interval for optimal performance when importing large data streams.
- **Parameters:**
  - `reader` (`Reader`) — the Reader containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database
  - `insertSql` (`String`) — the SQL insert statement with placeholders
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `func` (`Throwables.Function<? super String, Object[], E>`) — a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
  - `E` — if the function throws an exception
- **Signature:** `public static <E extends Exception> long importData(final Reader reader, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> line2Parameters) throws IllegalArgumentException, SQLException, IOException, E`
- **Summary:** Imports data from a Reader to a database table using the provided PreparedStatement with batch processing and a line parser function.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Reader reader = new InputStreamReader(inputStream); PreparedStatement stmt = connection.prepareStatement("INSERT INTO logs (level, message, timestamp) VALUES (?, ?, ?)"); Function<String, Object\[\]> parser = line -> { // Parse log format: \[LEVEL\] timestamp - message Pattern pattern = Pattern.compile("\\\\\[(\\\\w+)\\\\\] (\\\\d+) - (.+)"); Matcher matcher = pattern.matcher(line); if (!matcher.matches()) return null; return new Object\[\] { matcher.group(1), matcher.group(3), new Timestamp(Long.parseLong(matcher.group(2))) }; }; long rowsImported = JdbcUtils.importData(reader, stmt, 1000, 0, parser); } </pre>
- **Parameters:**
  - `reader` (`Reader`) — the Reader containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import
  - `batchSize` (`int`) — the number of rows to be inserted in each batch
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch execution
  - `line2Parameters` (`Throwables.Function<? super String, Object[], E>`) — a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line
- **Returns:** the number of rows successfully imported
- **Throws:**
  - `java.lang.IllegalArgumentException` — if {@code batchSize <= 0} or {@code batchIntervalInMillis < 0}
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
  - `E` — if the function throws an exception
- **Signature:** `public static <T> long importData(final Iterator<? extends T> iter, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException> stmtSetter) throws SQLException`
- **Summary:** Imports data from an Iterator to the database using the specified DataSource and SQL insert statement.
- **Parameters:**
  - `iter` (`Iterator<? extends T>`) — the Iterator containing the data to be imported
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections from
  - `insertSql` (`String`) — the SQL insert statement with parameter placeholders (?)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException>`) — a BiConsumer to map iterator elements to PreparedStatement parameters
- **Returns:** the total number of rows successfully inserted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static <T> long importData(final Iterator<? extends T> iter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException> stmtSetter) throws SQLException`
- **Summary:** Imports data from an Iterator to the database using the provided Connection with configurable batch processing.
- **Parameters:**
  - `iter` (`Iterator<? extends T>`) — the Iterator containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database (will not be closed by this method)
  - `insertSql` (`String`) — the SQL insert statement with parameter placeholders (?)
  - `batchSize` (`int`) — the number of rows to accumulate before executing a batch insert
  - `batchIntervalInMillis` (`long`) — the pause duration in milliseconds between batch executions
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException>`) — a BiConsumer to map iterator elements to PreparedStatement parameters
- **Returns:** the total number of rows successfully inserted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static <T> long importData(final Iterator<? extends T> iter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException> stmtSetter) throws SQLException`
- **Summary:** Imports data from an Iterator to the database using the provided PreparedStatement with configurable batch processing.
- **Contract:**
  - <p> This method is useful when you need to reuse a PreparedStatement or have specific statement configuration requirements.
  - </p> <p> Performance tips: </p> <ul> <li> Larger batch sizes generally improve performance but consume more memory </li> <li> Batch intervals can help prevent database overload during massive imports </li> <li> Consider the database's maximum packet size when setting batch size </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import with transaction control and prepared statement reuse Connection conn = dataSource.getConnection(); conn.setAutoCommit(false); PreparedStatement stmt = conn.prepareStatement( "INSERT INTO orders (order_id, customer_id, total, status) VALUES (?, ?, ?, ?)"); try { // Import pending orders Iterator<Order> pendingOrders = getPendingOrders(); long pending = JdbcUtils.importData(pendingOrders, stmt, 1000, 0, (query, order) -> { query.setLong(1, order.getId()); query.setLong(2, order.getCustomerId()); query.setBigDecimal(3, order.getTotal()); query.setString(4, "PENDING"); }); // Reuse statement for completed orders Iterator<Order> completedOrders = getCompletedOrders(); long completed = JdbcUtils.importData(completedOrders, stmt, 1000, 0, (query, order) -> { query.setLong(1, order.getId()); query.setLong(2, order.getCustomerId()); query.setBigDecimal(3, order.getTotal()); query.setString(4, "COMPLETED"); }); conn.commit(); System.out.println("Imported " + pending + " pending and " + completed + " completed orders"); } catch (Exception e) { conn.rollback(); throw e; } finally { stmt.close(); conn.close(); } } </pre>
- **Parameters:**
  - `iter` (`Iterator<? extends T>`) — the Iterator containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import (will not be closed)
  - `batchSize` (`int`) — the number of rows to accumulate before executing a batch insert (must be greater than 0)
  - `batchIntervalInMillis` (`long`) — the pause duration in milliseconds between batch executions (0 for no pause)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException>`) — a BiConsumer to map iterator elements to PreparedStatement parameters
- **Returns:** the total number of rows successfully inserted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### importCSV(...) -> long
- **Signature:** `public static long importCSV(final File file, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException`
- **Summary:** Imports data from a CSV file to the database using the specified DataSource.
- **Parameters:**
  - `file` (`File`) — the CSV file containing the data to be imported
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections from
  - `insertSql` (`String`) — the SQL insert statement (column order must match CSV column order)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading the file
- **Signature:** `public static long importCSV(final File file, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException`
- **Summary:** Imports data from a CSV file to the database using the provided Connection with configurable batch processing.
- **Parameters:**
  - `file` (`File`) — the CSV file containing the data to be imported
  - `conn` (`Connection`) — the Connection to the database (will not be closed by this method)
  - `insertSql` (`String`) — the SQL insert statement (column order must match CSV column order)
  - `batchSize` (`int`) — the number of rows to accumulate before executing a batch insert
  - `batchIntervalInMillis` (`long`) — the pause duration in milliseconds between batch executions
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading the file
- **Signature:** `public static long importCSV(final File file, final PreparedStatement stmt, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException`
- **Summary:** Imports data from a CSV file to the database using the provided PreparedStatement with default batch settings.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import with custom prepared statement configuration File csvFile = new File("transactions.csv"); PreparedStatement stmt = conn.prepareStatement( "INSERT INTO transactions (account_id, amount, type, date) VALUES (?, ?, ?, ?)", Statement.RETURN_GENERATED_KEYS); long rowsImported = JdbcUtils.importCSV(csvFile, stmt, (query, row) -> { query.setLong(1, Long.parseLong(row\[0\])); query.setBigDecimal(2, new BigDecimal(row\[1\])); query.setString(3, row\[2\]); query.setDate(4, Date.valueOf(row\[3\])); }); // Can retrieve generated keys if needed ResultSet generatedKeys = stmt.getGeneratedKeys(); } </pre>
- **Parameters:**
  - `file` (`File`) — the CSV file containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import (will not be closed)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading the file
- **Signature:** `public static long importCSV(final File file, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException`
- **Summary:** Imports data from a CSV file to the database using the provided PreparedStatement with configurable batch processing.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import large dataset with progress tracking File csvFile = new File("large_dataset.csv"); PreparedStatement stmt = conn.prepareStatement( "INSERT INTO records (id, data, timestamp) VALUES (?, ?, ?)"); AtomicLong processedRows = new AtomicLong(0); long totalRows = JdbcUtils.importCSV(csvFile, stmt, 5000, 100, (query, row) -> { query.setLong(1, Long.parseLong(row\[0\])); query.setString(2, row\[1\]); query.setTimestamp(3, Timestamp.valueOf(row\[2\])); long processed = processedRows.incrementAndGet(); if (processed % 10000 == 0) { System.out.println("Processed " + processed + " rows..."); } }); System.out.println("Import completed.
- **Parameters:**
  - `file` (`File`) — the CSV file containing the data to be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import (will not be closed)
  - `batchSize` (`int`) — the number of rows to accumulate before executing a batch insert
  - `batchIntervalInMillis` (`long`) — the pause duration in milliseconds between batch executions
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading the file
- **Signature:** `public static <E extends Exception> long importCSV(final File file, final Throwables.Predicate<? super String[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException, E`
- **Summary:** Imports data from a CSV file to the database with row filtering capability.
- **Parameters:**
  - `file` (`File`) — the CSV file containing the data to be imported
  - `filter` (`Throwables.Predicate<? super String[], E>`) — a predicate to filter rows; only rows returning {@code true} will be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import (will not be closed)
  - `batchSize` (`int`) — the number of rows to accumulate before executing a batch insert
  - `batchIntervalInMillis` (`long`) — the pause duration in milliseconds between batch executions
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported (after filtering)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading the file
  - `E` — if the filter throws an exception
- **Signature:** `public static long importCSV(final Reader reader, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException`
- **Summary:** Imports data from a CSV Reader to the database using the specified DataSource.
- **Contract:**
  - This method is useful when the CSV data comes from a source other than a file.
- **Parameters:**
  - `reader` (`Reader`) — the Reader to read the CSV data from
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections from
  - `insertSql` (`String`) — the SQL insert statement (column order must match CSV column order)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading from the reader
- **Signature:** `public static long importCSV(final Reader reader, final PreparedStatement stmt, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException`
- **Summary:** Imports data from a CSV Reader to the database using the provided PreparedStatement with default batch settings.
- **Contract:**
  - The Reader will be wrapped in a BufferedReader for optimal performance if not already buffered.
- **Parameters:**
  - `reader` (`Reader`) — the Reader to read the CSV data from
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import (will not be closed)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading from the reader
- **Signature:** `public static long importCSV(final Reader reader, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException`
- **Summary:** Imports data from a CSV Reader to the database using the provided PreparedStatement with configurable batch processing.
- **Parameters:**
  - `reader` (`Reader`) — the Reader to read the CSV data from
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import (will not be closed)
  - `batchSize` (`int`) — the number of rows to accumulate before executing a batch insert
  - `batchIntervalInMillis` (`long`) — the pause duration in milliseconds between batch executions
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading from the reader
- **Signature:** `public static <E extends Exception> long importCSV(final Reader reader, final Throwables.Predicate<? super String[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws IllegalArgumentException, SQLException, IOException, E`
- **Summary:** Imports data from a CSV Reader to the database with row filtering capability and configurable batch processing.
- **Contract:**
  - <p> This method combines all import features: </p> <ul> <li> Custom data source (Reader) </li> <li> Row filtering before import </li> <li> Configurable batch processing </li> <li> Custom value mapping </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import CSV data with complex filtering and validation Reader reader = new FileReader("user_data.csv"); PreparedStatement stmt = conn.prepareStatement( "INSERT INTO users (id, email, age, country) VALUES (?, ?, ?, ?)"); // Complex filter: valid email, age >= 18, allowed countries Set<String> allowedCountries = Set.of("US", "CA", "UK", "AU"); Predicate<String\[\]> complexFilter = row -> { // Validate email format (simple check) if (!row\[1\].contains("@")) return false; // Check age >= 18 try { if (Integer.parseInt(row\[2\]) < 18) return false; } catch (NumberFormatException e) { return false; } // Check allowed countries return allowedCountries.contains(row\[3\]); }; long rowsImported = JdbcUtils.importCSV(reader, complexFilter, stmt, 2000, 0, (query, row) -> { query.setLong(1, Long.parseLong(row\[0\])); query.setString(2, row\[1\].toLowerCase()); // normalize email query.setInt(3, Integer.parseInt(row\[2\])); query.setString(4, row\[3\]); }); System.out.println("Imported " + rowsImported + " valid users"); } </pre>
- **Parameters:**
  - `reader` (`Reader`) — the Reader to read the CSV data from
  - `filter` (`Throwables.Predicate<? super String[], E>`) — a predicate to filter rows; only rows returning {@code true} will be imported
  - `stmt` (`PreparedStatement`) — the PreparedStatement to be used for the import (will not be closed)
  - `batchSize` (`int`) — the number of rows to accumulate before executing a batch insert (must be greater than 0)
  - `batchIntervalInMillis` (`long`) — the pause duration in milliseconds between batch executions (must be >= 0)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>`) — a BiConsumer to set PreparedStatement parameters from CSV row values
- **Returns:** the total number of rows successfully imported (after filtering)
- **Throws:**
  - `java.lang.IllegalArgumentException` — if batchSize is not positive or batchIntervalInMillis is negative
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while reading from the reader
  - `E` — if the filter throws an exception
##### exportCSV(...) -> long
- **Signature:** `public static long exportCSV(final javax.sql.DataSource sourceDataSource, final String querySql, final File output) throws SQLException, IOException`
- **Summary:** Exports data from the database to a CSV file using the specified DataSource and SQL query.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections from
  - `querySql` (`String`) — the SQL query to execute for retrieving data
  - `output` (`File`) — the File to write the CSV data to (will be created if doesn't exist)
- **Returns:** the total number of rows exported to the CSV file
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing to the file
- **Signature:** `public static long exportCSV(final Connection conn, final String querySql, final File output) throws SQLException, IOException`
- **Summary:** Exports data from the database to a CSV file using the provided Connection and SQL query.
- **Parameters:**
  - `conn` (`Connection`) — the Connection to the database (will not be closed by this method)
  - `querySql` (`String`) — the SQL query to execute for retrieving data
  - `output` (`File`) — the File to write the CSV data to (will be created if doesn't exist)
- **Returns:** the total number of rows exported to the CSV file
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing to the file
- **Signature:** `public static long exportCSV(final Connection conn, final String querySql, final Collection<String> selectColumnNames, final File output) throws SQLException, IOException`
- **Summary:** Exports selected columns from the database to a CSV file using the provided Connection and SQL query.
- **Contract:**
  - This method allows you to specify which columns from the query result should be included in the CSV.
  - This is useful when you want to exclude sensitive or unnecessary columns from the export.
- **Parameters:**
  - `conn` (`Connection`) — the Connection to the database (will not be closed by this method)
  - `querySql` (`String`) — the SQL query to execute for retrieving data
  - `selectColumnNames` (`Collection<String>`) — collection of column names to include in export (null for all columns)
  - `output` (`File`) — the File to write the CSV data to (will be created if doesn't exist)
- **Returns:** the total number of rows exported to the CSV file
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing to the file
- **Signature:** `public static long exportCSV(final PreparedStatement stmt, final File out) throws SQLException, IOException`
- **Summary:** Exports data from the database to a CSV file using the provided PreparedStatement.
- **Contract:**
  - <p> This method is useful when you need to set parameters on the statement before execution or when you want to reuse a prepared statement for multiple exports.
- **Parameters:**
  - `stmt` (`PreparedStatement`) — the PreparedStatement to execute (will not be closed by this method)
  - `out` (`File`) — the File to write the CSV data to (will be created if doesn't exist)
- **Returns:** the total number of rows exported to the CSV file
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing to the file
- **Signature:** `public static long exportCSV(final PreparedStatement stmt, final Collection<String> selectColumnNames, final File output) throws SQLException, IOException`
- **Summary:** Exports selected columns from the database to a CSV file using the provided PreparedStatement.
- **Parameters:**
  - `stmt` (`PreparedStatement`) — the PreparedStatement to execute (will not be closed by this method)
  - `selectColumnNames` (`Collection<String>`) — collection of column names to include in export (null for all columns)
  - `output` (`File`) — the File to write the CSV data to (will be created if doesn't exist)
- **Returns:** the total number of rows exported to the CSV file
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing to the file
- **Signature:** `public static long exportCSV(final ResultSet rs, final File output) throws SQLException, IOException`
- **Summary:** Exports data from a ResultSet to a CSV file.
- **Contract:**
  - <p> This is the lowest-level export method, useful when you already have a ResultSet from a complex operation or need maximum control over the export process.
- **Parameters:**
  - `rs` (`ResultSet`) — the ResultSet containing the data to export (will not be closed by this method)
  - `output` (`File`) — the File to write the CSV data to (will be created if doesn't exist)
- **Returns:** the total number of rows exported to the CSV file
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing to the file
- **Signature:** `public static long exportCSV(final ResultSet rs, final Collection<String> selectColumnNames, final File output) throws SQLException, IOException`
- **Summary:** Exports selected columns from a ResultSet to a CSV file.
- **Contract:**
  - <p> Column names are case-sensitive and must match exactly with the column labels in the ResultSet.
  - If a specified column is not found in the ResultSet, an IllegalArgumentException will be thrown.
- **Parameters:**
  - `rs` (`ResultSet`) — the ResultSet containing the data to export (will not be closed by this method)
  - `selectColumnNames` (`Collection<String>`) — collection of column names to include in export (null for all columns)
  - `output` (`File`) — the File to write the CSV data to (will be created if doesn't exist)
- **Returns:** the total number of rows exported to the CSV file
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing to the file
- **Signature:** `public static long exportCSV(final javax.sql.DataSource sourceDataSource, final String querySql, final Writer output) throws SQLException, IOException`
- **Summary:** Exports data from the database to a CSV Writer using the specified DataSource and SQL query.
- **Contract:**
  - This method is useful when you need to write CSV data to a custom destination.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the DataSource to obtain database connections from
  - `querySql` (`String`) — the SQL query to execute for retrieving data
  - `output` (`Writer`) — the Writer to write the CSV data to (will not be closed by this method)
- **Returns:** the total number of rows exported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing
- **Signature:** `public static long exportCSV(final Connection conn, final String querySql, final Writer output) throws SQLException, IOException`
- **Summary:** Exports data from the database to a CSV Writer using the provided Connection and SQL query.
- **Contract:**
  - The Writer should be flushed after this method returns to ensure all data is written.
- **Parameters:**
  - `conn` (`Connection`) — the Connection to the database (will not be closed by this method)
  - `querySql` (`String`) — the SQL query to execute for retrieving data
  - `output` (`Writer`) — the Writer to write the CSV data to (will not be closed by this method)
- **Returns:** the total number of rows exported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs while writing
- **Signature:** `public static long exportCSV(final ResultSet rs, final Writer output) throws SQLException, IOException`
- **Summary:** Exports data from a ResultSet to a CSV Writer.
- **Parameters:**
  - `rs` (`ResultSet`) — the ResultSet containing the data to be exported
  - `output` (`Writer`) — the Writer to write the CSV data to
- **Returns:** the number of rows exported
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
- **Signature:** `public static long exportCSV(final ResultSet rs, final Collection<String> selectColumnNames, final Writer output) throws IllegalArgumentException, SQLException, IOException`
- **Summary:** Exports data from a ResultSet to a CSV file with column selection.
- **Parameters:**
  - `rs` (`ResultSet`) — the ResultSet containing the data to be exported
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be selected for export; if {@code null} , all columns are exported
  - `output` (`Writer`) — the Writer to write the CSV data to
- **Returns:** the number of rows exported
- **Throws:**
  - `java.lang.IllegalArgumentException` — if any specified column name is not found in the ResultSet
  - `java.sql.SQLException` — if a database access error occurs
  - `java.io.IOException` — if an I/O error occurs
##### copy(...) -> long
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String tableName) throws SQLException`
- **Summary:** Copies all data from a table in the source data source to a table with the same name in the target data source.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `tableName` (`String`) — the name of the table to copy
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the table doesn't exist
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName) throws SQLException`
- **Summary:** Copies all data from a table in the source data source to a table in the target data source.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `sourceTableName` (`String`) — the name of the table in the source data source
  - `targetTableName` (`String`) — the name of the table in the target data source
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or either table doesn't exist
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName, final int batchSize) throws SQLException`
- **Summary:** Copies all data from a table in the source data source to a table in the target data source with a specified batch size for performance tuning.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `sourceTableName` (`String`) — the name of the table in the source data source
  - `targetTableName` (`String`) — the name of the table in the target data source
  - `batchSize` (`int`) — the number of rows to copy in each batch (must be greater than 0)
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames) throws SQLException`
- **Summary:** Copies specified columns from a table in the source data source to a table in the target data source.
- **Contract:**
  - <p> This method is useful when you need to copy only a subset of columns or when the target table has a different structure than the source table.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `sourceTableName` (`String`) — the name of the table in the source data source
  - `targetTableName` (`String`) — the name of the table in the target data source
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to copy
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or any specified column doesn't exist
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames, final int batchSize) throws SQLException`
- **Summary:** Copies specified columns from a table in the source data source to a table in the target data source with a custom batch size for performance tuning.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `sourceTableName` (`String`) — the name of the table in the source data source
  - `targetTableName` (`String`) — the name of the table in the target data source
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to copy
  - `batchSize` (`int`) — the number of rows to copy in each batch (must be greater than 0)
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final javax.sql.DataSource targetDataSource, final String insertSql) throws SQLException`
- **Summary:** Copies data from a source data source to a target data source using custom SQL queries.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `selectSql` (`String`) — the SQL query to select data from the source data source
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `insertSql` (`String`) — the SQL query to insert data into the target data source (must have matching parameter placeholders)
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or SQL statements are invalid
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final int fetchSize, final javax.sql.DataSource targetDataSource, final String insertSql, final int batchSize) throws SQLException`
- **Summary:** Copies data from a source data source to a target data source using custom SQL queries with specified fetch and batch sizes for performance optimization.
- **Contract:**
  - For optimal performance, fetch size should be larger than batch size.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `selectSql` (`String`) — the SQL query to select data from the source data source
  - `fetchSize` (`int`) — the number of rows to fetch at a time (should be larger than batchSize)
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `insertSql` (`String`) — the SQL query to insert data into the target data source
  - `batchSize` (`int`) — the number of rows to copy in each batch (must be greater than 0)
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final javax.sql.DataSource targetDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException`
- **Summary:** Copies data from a source data source to a target data source using custom SQL queries and a custom statement setter for parameter mapping.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `selectSql` (`String`) — the SQL query to select data from the source data source
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `insertSql` (`String`) — the SQL query to insert data into the target data source
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>`) — a bi-consumer to set parameters on the prepared statement from the result set
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final int fetchSize, final javax.sql.DataSource targetDataSource, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException`
- **Summary:** Copies data from a source data source to a target data source with full control over all aspects of the copy operation including SQL queries, performance settings, and parameter mapping.
- **Parameters:**
  - `sourceDataSource` (`javax.sql.DataSource`) — the data source from which to copy data
  - `selectSql` (`String`) — the SQL query to select data from the source data source
  - `fetchSize` (`int`) — the number of rows to fetch at a time (should be larger than batchSize)
  - `targetDataSource` (`javax.sql.DataSource`) — the data source to which to copy data
  - `insertSql` (`String`) — the SQL query to insert data into the target data source
  - `batchSize` (`int`) — the number of rows to copy in each batch (must be greater than 0)
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch (0 for no delay)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>`) — a bi-consumer to set parameters on the prepared statement
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final Connection targetConn, final String tableName) throws SQLException`
- **Summary:** Copies all data from a table with the same name between two database connections.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `tableName` (`String`) — the name of the table to copy data from and to
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName) throws SQLException`
- **Summary:** Copies all data from a source table to a target table using the specified connections.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `sourceTableName` (`String`) — the name of the source table to copy data from
  - `targetTableName` (`String`) — the name of the target table to copy data to
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName, final int batchSize) throws SQLException`
- **Summary:** Copies all data from a source table to a target table using the specified connections with a custom batch size for performance tuning.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `sourceTableName` (`String`) — the name of the source table to copy data from
  - `targetTableName` (`String`) — the name of the target table to copy data to
  - `batchSize` (`int`) — the number of rows to copy in each batch (must be greater than 0)
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames) throws SQLException`
- **Summary:** Copies specified columns from a source table to a target table using the provided connections.
- **Contract:**
  - <p> This method is useful when copying a subset of columns or when the target table has a different structure than the source table.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `sourceTableName` (`String`) — the name of the source table to copy data from
  - `targetTableName` (`String`) — the name of the target table to copy data to
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be copied
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or any specified column doesn't exist
- **Signature:** `public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames, final int batchSize) throws SQLException`
- **Summary:** Copies specified columns from a source table to a target table using the provided connections with a custom batch size for performance optimization.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `sourceTableName` (`String`) — the name of the source table to copy data from
  - `targetTableName` (`String`) — the name of the target table to copy data to
  - `selectColumnNames` (`Collection<String>`) — the collection of column names to be copied
  - `batchSize` (`int`) — the number of rows to be copied in each batch (must be greater than 0)
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final String selectSql, final Connection targetConn, final String insertSql) throws SQLException`
- **Summary:** Copies data between databases using custom SQL queries and existing connections.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `selectSql` (`String`) — the SQL query to select data from the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `insertSql` (`String`) — the SQL query to insert data into the target database
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final String selectSql, final int fetchSize, final Connection targetConn, final String insertSql, final int batchSize) throws SQLException`
- **Summary:** Copies data between databases using custom SQL queries with specified fetch and batch sizes.
- **Contract:**
  - For optimal performance, fetch size should be larger than batch size.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `selectSql` (`String`) — the SQL query to select data from the source database
  - `fetchSize` (`int`) — the number of rows to fetch at a time from the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `insertSql` (`String`) — the SQL query to insert data into the target database
  - `batchSize` (`int`) — the number of rows to be copied in each batch (must be greater than 0)
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final String selectSql, final Connection targetConn, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException`
- **Summary:** Copies data between databases using custom SQL queries and a custom statement setter.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `selectSql` (`String`) — the SQL query to select data from the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `insertSql` (`String`) — the SQL query to insert data into the target database
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>`) — the custom statement setter to set the parameters of the prepared statement
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final Connection sourceConn, final String selectSql, final int fetchSize, final Connection targetConn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException`
- **Summary:** Copies data between databases with full control over all aspects of the operation.
- **Parameters:**
  - `sourceConn` (`Connection`) — the connection to the source database
  - `selectSql` (`String`) — the SQL query to select data from the source database
  - `fetchSize` (`int`) — the number of rows to fetch at a time from the source database
  - `targetConn` (`Connection`) — the connection to the target database
  - `insertSql` (`String`) — the SQL query to insert data into the target database
  - `batchSize` (`int`) — the number of rows to be copied in each batch (must be greater than 0)
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch (0 for no delay)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>`) — the custom statement setter to set the parameters of the prepared statement
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public static long copy(final PreparedStatement selectStmt, final PreparedStatement insertStmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException`
- **Summary:** Copies data from a source PreparedStatement to a target PreparedStatement with full control over batch processing and parameter mapping.
- **Contract:**
  - <p> This low-level method provides direct control over prepared statements and is useful when you need to reuse statements or have complex statement preparation requirements.
- **Parameters:**
  - `selectStmt` (`PreparedStatement`) — the PreparedStatement used to select data from the source
  - `insertStmt` (`PreparedStatement`) — the PreparedStatement used to insert data into the target
  - `batchSize` (`int`) — the number of rows to process in each batch (must be greater than 0)
  - `batchIntervalInMillis` (`long`) — the interval in milliseconds between each batch (0 for no delay)
  - `stmtSetter` (`Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>`) — a BiConsumer that sets the parameters for the PreparedStatement from the ResultSet
- **Returns:** the number of rows copied
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### createParamSetter(...) -> Throwables.BiConsumer<PreparedQuery, ResultSet, SQLException>
- **Signature:** `@Beta @SequentialOnly @Stateful public static Throwables.BiConsumer<PreparedQuery, ResultSet, SQLException> createParamSetter(final ColumnGetter<?> columnGetterForAll)`
- **Summary:** Creates a parameter setter for a PreparedQuery using the provided ColumnGetter.
- **Contract:**
  - This is particularly useful when you need custom value extraction logic across all columns.
  - It should not be reused across different ResultSets with different column counts or used in parallel operations.
- **Parameters:**
  - `columnGetterForAll` (`ColumnGetter<?>`) — the ColumnGetter to use for extracting values from all columns
- **Returns:** a stateful BiConsumer that sets parameters on a PreparedQuery based on ResultSet values
- **See also:** #copy(Connection, String, Connection, String, Throwables.BiConsumer)

#### Public Instance Methods
- (none)

### Class JoinInfo (com.landawn.abacus.jdbc.JoinInfo)
Manages join relationships between entities in JDBC operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### getEntityJoinInfo(...) -> Map<String, JoinInfo>
- **Signature:** `public static Map<String, JoinInfo> getEntityJoinInfo(final Class<?> daoClass, final Class<?> entityClass, final String tableName)`
- **Summary:** Retrieves all join information for the specified entity class.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get all join info for Employee entity Map<String, JoinInfo> joinInfoMap = JoinInfo.getEntityJoinInfo( EmployeeDao.class, Employee.class, "employees" ); // Iterate through all join properties for (Map.Entry<String, JoinInfo> entry : joinInfoMap.entrySet()) { String propName = entry.getKey(); JoinInfo joinInfo = entry.getValue(); System.out.println("Join property: " + propName); if (joinInfo.isManyToManyJoin()) { System.out.println(" - Many-to-many relationship"); } else { System.out.println(" - One-to-many relationship"); } } } </pre>
- **Parameters:**
  - `daoClass` (`Class<?>`) — the DAO class associated with the entity, must not be {@code null}
  - `entityClass` (`Class<?>`) — the entity class to inspect for join properties, must not be {@code null}
  - `tableName` (`String`) — the database table name for the entity, must not be {@code null}
- **Returns:** an unmodifiable map of property names to JoinInfo objects, never {@code null} , empty if no join properties exist
- **See also:** JoinedBy, DaoConfig
##### getPropJoinInfo(...) -> JoinInfo
- **Signature:** `public static JoinInfo getPropJoinInfo(final Class<?> daoClass, final Class<?> entityClass, final String tableName, final String joinEntityPropName)`
- **Summary:** Retrieves join information for a specific property in an entity.
- **Parameters:**
  - `daoClass` (`Class<?>`) — the DAO class associated with the entity, must not be {@code null}
  - `entityClass` (`Class<?>`) — the entity class containing the join property, must not be {@code null}
  - `tableName` (`String`) — the database table name for the entity, must not be {@code null}
  - `joinEntityPropName` (`String`) — the name of the property with the {@code @JoinedBy} annotation, must not be {@code null}
- **Returns:** the JoinInfo for the specified property, never {@code null}
- **See also:** JoinedBy, #getEntityJoinInfo(Class, Class, String)
##### getJoinEntityPropNamesByType(...) -> List<String>
- **Signature:** `public static List<String> getJoinEntityPropNamesByType(final Class<?> daoClass, final Class<?> entityClass, final String tableName, final Class<?> joinPropEntityClass)`
- **Summary:** Retrieves all property names in an entity that join to a specific entity type.
- **Contract:**
  - <p> This is useful when you need to discover all relationships between two entity types, especially when there might be multiple join properties pointing to the same entity class.
  - use joinInfo } // Check if entity has any joins to a specific type if (!projectJoinProps.isEmpty()) { System.out.println("Employee has " + projectJoinProps.size() + " relationship(s) with Project"); } } </pre>
- **Parameters:**
  - `daoClass` (`Class<?>`) — the DAO class associated with the entity, must not be {@code null}
  - `entityClass` (`Class<?>`) — the entity class to search for join properties, must not be {@code null}
  - `tableName` (`String`) — the database table name for the entity, must not be {@code null}
  - `joinPropEntityClass` (`Class<?>`) — the class of the joined entity to search for, must not be {@code null}
- **Returns:** an unmodifiable list of property names that join to the specified entity class, never {@code null} , empty if none found
- **See also:** JoinedBy, #getEntityJoinInfo(Class, Class, String)

#### Public Instance Methods
##### getSelectSQLBuilderAndParamSetter(...) -> Tuple2<Function<Collection<String>, String>, Jdbc.BiParametersSetter<PreparedStatement, Object>>
- **Signature:** `public Tuple2<Function<Collection<String>, String>, Jdbc.BiParametersSetter<PreparedStatement, Object>> getSelectSQLBuilderAndParamSetter( final Class<? extends SQLBuilder> sbc)`
- **Summary:** Retrieves the SQL builder and parameter setter for single entity select operations.
- **Parameters:**
  - `sbc` (`Class<? extends SQLBuilder>`) — the SQL builder class type (PSC, PAC, or PLC)
- **Returns:** a tuple containing a function to build SQL and a parameter setter for prepared statements
- **See also:** SQLBuilder.PSC, SQLBuilder.PAC, SQLBuilder.PLC
##### getBatchSelectSQLBuilderAndParamSetter(...) -> Tuple2<BiFunction<Collection<String>, Integer, String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>>
- **Signature:** `public Tuple2<BiFunction<Collection<String>, Integer, String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>> getBatchSelectSQLBuilderAndParamSetter( //NOSONAR final Class<? extends SQLBuilder> sbc)`
- **Summary:** Retrieves the SQL builder and parameter setter for batch select operations.
- **Parameters:**
  - `sbc` (`Class<? extends SQLBuilder>`) — the SQL builder class type (PSC, PAC, or PLC)
- **Returns:** a tuple containing a function to build SQL and a parameter setter for batch operations
- **See also:** SQLBuilder.PSC, SQLBuilder.PAC, SQLBuilder.PLC
##### getDeleteSqlAndParamSetter(...) -> Tuple3<String, String, Jdbc.BiParametersSetter<PreparedStatement, Object>>
- **Signature:** `public Tuple3<String, String, Jdbc.BiParametersSetter<PreparedStatement, Object>> getDeleteSqlAndParamSetter(final Class<? extends SQLBuilder> sbc)`
- **Summary:** Retrieves the SQL and parameter setter for delete operations.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code JoinInfo joinInfo = JoinInfo.getPropJoinInfo(EmployeeDao.class, Employee.class, "employees", "projects"); Tuple3<String, String, Jdbc.BiParametersSetter<PreparedStatement, Object>> deleteTuple = joinInfo.getDeleteSqlAndParamSetter(PSC.class); String deleteSql = deleteTuple._1; // Main delete SQL String middleTableDeleteSql = deleteTuple._2; // Join table delete SQL (if many-to-many) Jdbc.BiParametersSetter<PreparedStatement, Object> paramSetter = deleteTuple._3; } </pre>
- **Parameters:**
  - `sbc` (`Class<? extends SQLBuilder>`) — the SQL builder class type (PSC, PAC, or PLC)
- **Returns:** a tuple containing the delete SQL, optional middle table delete SQL (null if not many-to-many), and parameter setter
- **See also:** SQLBuilder.PSC, SQLBuilder.PAC, SQLBuilder.PLC
##### getBatchDeleteSQLBuilderAndParamSetter(...) -> Tuple3<IntFunction<String>, IntFunction<String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>>
- **Signature:** `public Tuple3<IntFunction<String>, IntFunction<String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>> getBatchDeleteSQLBuilderAndParamSetter( //NOSONAR final Class<? extends SQLBuilder> sbc)`
- **Summary:** Retrieves the SQL builder and parameter setter for batch delete operations.
- **Parameters:**
  - `sbc` (`Class<? extends SQLBuilder>`) — the SQL builder class type (PSC, PAC, or PLC)
- **Returns:** a tuple containing SQL builders for delete operations (main and optional middle table) and a parameter setter
- **See also:** SQLBuilder.PSC, SQLBuilder.PAC, SQLBuilder.PLC
##### setJoinPropEntities(...) -> void
- **Signature:** `public void setJoinPropEntities(final Collection<?> entities, final Collection<?> joinPropEntities)`
- **Summary:** Sets join property entities for a collection of source entities.
- **Contract:**
  - If the join property is declared as a {@code List} and the grouped value is already a {@code List} , the list is assigned directly; otherwise a new collection of the declared type is created and populated.
- **Parameters:**
  - `entities` (`Collection<?>`) — the source entities to populate with joined entities
  - `joinPropEntities` (`Collection<?>`) — the joined entities to be set on the source entities
- **See also:** #setJoinPropEntities(Collection, Map)
- **Signature:** `public void setJoinPropEntities(final Collection<?> entities, final Map<Object, List<Object>> groupedPropEntities)`
- **Summary:** Sets join property entities for a collection of source entities using pre-grouped entities.
- **Parameters:**
  - `entities` (`Collection<?>`) — the source entities to populate with joined entities
  - `groupedPropEntities` (`Map<Object, List<Object>>`) — a map of grouped entities keyed by their join keys
##### isManyToManyJoin(...) -> boolean
- **Signature:** `public boolean isManyToManyJoin()`
- **Summary:** Checks if this join relationship is a many-to-many join.
- **Contract:**
  - Checks if this join relationship is a many-to-many join.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code JoinInfo joinInfo = JoinInfo.getPropJoinInfo(EmployeeDao.class, Employee.class, "employees", "projects"); if (joinInfo.isManyToManyJoin()) { // Handle many-to-many relationship with join table System.out.println("This is a many-to-many relationship"); } else { // Handle one-to-many or one-to-one relationship System.out.println("This is a direct relationship"); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if this is a many-to-many join, {@code false} otherwise

### Class NamedQuery (com.landawn.abacus.jdbc.NamedQuery)
A JDBC wrapper class that provides named parameter support for SQL queries, similar to Spring's NamedParameterJdbcTemplate.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### setNull(...) -> NamedQuery
- **Signature:** `public NamedQuery setNull(final String parameterName, final int sqlType) throws SQLException`
- **Summary:** Sets the specified named parameter to SQL NULL.
- **Contract:**
  - If the parameter appears multiple times in the query, all occurrences will be set to NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set to NULL (without the ':' prefix)
  - `sqlType` (`int`) — the SQL type code defined in {@link java.sql.Types}
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
- **Signature:** `public NamedQuery setNull(final String parameterName, final int sqlType, final String typeName) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to SQL NULL with a specified SQL type and type name.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set to NULL (without the ':' prefix)
  - `sqlType` (`int`) — the SQL type code defined in {@link java.sql.Types}
  - `typeName` (`String`) — the SQL type name (for SQL user-defined or REF types)
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** java.sql.Types
##### setBoolean(...) -> NamedQuery
- **Signature:** `public NamedQuery setBoolean(final String parameterName, final boolean x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a boolean value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`boolean`) — the boolean value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setBoolean(final String parameterName, final Boolean x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Boolean value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Boolean`) — the Boolean value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setByte(...) -> NamedQuery
- **Signature:** `public NamedQuery setByte(final String parameterName, final byte x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a byte value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`byte`) — the byte value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setByte(final String parameterName, final Byte x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Byte value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Byte`) — the Byte value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setShort(...) -> NamedQuery
- **Signature:** `public NamedQuery setShort(final String parameterName, final short x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a short value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`short`) — the short value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setShort(final String parameterName, final Short x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Short value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Short`) — the Short value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setInt(...) -> NamedQuery
- **Signature:** `public NamedQuery setInt(final String parameterName, final int x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to an int value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`int`) — the int value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setInt(final String parameterName, final Integer x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to an Integer value.
- **Contract:**
  - <p> This method handles {@code null} values by setting the parameter to SQL NULL if the provided value is {@code null} .
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Integer`) — the Integer value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated public NamedQuery setInt(final String parameterName, final char x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a char value by converting it to an int.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`char`) — the char value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setString(String, char)
- **Signature:** `@Deprecated public NamedQuery setInt(final String parameterName, final Character x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Character value by converting it to an int.
- **Contract:**
  - <p> This method handles {@code null} values by setting the parameter to SQL NULL if the provided value is {@code null} .
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Character`) — the Character value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setString(String, Character)
##### setLong(...) -> NamedQuery
- **Signature:** `public NamedQuery setLong(final String parameterName, final long x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a long value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`long`) — the long value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setLong(final String parameterName, final Long x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Long value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Long`) — the Long value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setLong(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a BigInteger value by converting it to a long.
- **Contract:**
  - If the BigInteger value is too large to fit in a long, an ArithmeticException will be thrown.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setFloat(...) -> NamedQuery
- **Signature:** `public NamedQuery setFloat(final String parameterName, final float x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a float value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`float`) — the float value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setFloat(final String parameterName, final Float x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Float value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Float`) — the Float value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setDouble(...) -> NamedQuery
- **Signature:** `public NamedQuery setDouble(final String parameterName, final double x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a double value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`double`) — the double value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setDouble(final String parameterName, final Double x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Double value.
- **Contract:**
  - If the value is {@code null} , the parameter will be set to SQL NULL.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Double`) — the Double value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setBigDecimal(...) -> NamedQuery
- **Signature:** `public NamedQuery setBigDecimal(final String parameterName, final BigDecimal x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a BigDecimal value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`BigDecimal`) — the BigDecimal value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setBigDecimal(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a BigInteger value by converting it to BigDecimal.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setBigIntegerAsString(...) -> NamedQuery
- **Signature:** `@Beta public NamedQuery setBigIntegerAsString(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a BigInteger value by converting it to String.
- **Contract:**
  - This is useful when the numeric value exceeds the range of standard numeric types.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setString(String, BigInteger), #setBigDecimal(String, BigInteger), #setLong(String, BigInteger)
##### setString(...) -> NamedQuery
- **Signature:** `public NamedQuery setString(final String parameterName, final String x) throws SQLException`
- **Summary:** Sets the specified named parameter to a String value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`String`) — the String value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setString(final String parameterName, final CharSequence x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a CharSequence value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`CharSequence`) — the CharSequence value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setString(final String parameterName, final char x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a single character value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`char`) — the char value to set
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setString(final String parameterName, final Character x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a Character value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Character`) — the Character value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setString(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a BigInteger value as a String.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`BigInteger`) — the BigInteger value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setNString(...) -> NamedQuery
- **Signature:** `public NamedQuery setNString(final String parameterName, final String x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a national character string value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`String`) — the String value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setNString(final String parameterName, final CharSequence x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a national character string value from a CharSequence.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`CharSequence`) — the CharSequence value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setDate(...) -> NamedQuery
- **Signature:** `public NamedQuery setDate(final String parameterName, final java.sql.Date x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Date value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.sql.Date`) — the java.sql.Date value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setDate(final String parameterName, final java.util.Date x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a java.util.Date value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.util.Date`) — the java.util.Date value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setDate(final String parameterName, final LocalDate x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a LocalDate value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`LocalDate`) — the LocalDate value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setTime(...) -> NamedQuery
- **Signature:** `public NamedQuery setTime(final String parameterName, final java.sql.Time x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Time value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.sql.Time`) — the java.sql.Time value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setTime(final String parameterName, final java.util.Date x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a time value using a java.util.Date.
- **Contract:**
  - If the provided Date is already a java.sql.Time instance, it is used directly without conversion.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.util.Date`) — the java.util.Date value containing the time to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setTime(final String parameterName, final LocalTime x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a time value using a LocalTime.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`LocalTime`) — the LocalTime value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setTimestamp(...) -> NamedQuery
- **Signature:** `public NamedQuery setTimestamp(final String parameterName, final java.sql.Timestamp x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Timestamp value.
- **Contract:**
  - Timestamps are typically used for recording when events occur in the database.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.sql.Timestamp`) — the java.sql.Timestamp value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setTimestamp(final String parameterName, final java.util.Date x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a timestamp value using a java.util.Date.
- **Contract:**
  - If the provided Date is already a java.sql.Timestamp instance, it is used directly without conversion.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.util.Date`) — the java.util.Date value to convert and set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setTimestamp(final String parameterName, final LocalDateTime x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a timestamp value using a LocalDateTime.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`LocalDateTime`) — the LocalDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setTimestamp(final String parameterName, final ZonedDateTime x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a timestamp value using a ZonedDateTime.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`ZonedDateTime`) — the ZonedDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setTimestamp(final String parameterName, final OffsetDateTime x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a timestamp value using an OffsetDateTime.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`OffsetDateTime`) — the OffsetDateTime value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setTimestamp(final String parameterName, final Instant x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a timestamp value using an Instant.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Instant`) — the Instant value to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setBytes(...) -> NamedQuery
- **Signature:** `public NamedQuery setBytes(final String parameterName, final byte[] x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a byte array value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`byte[]`) — the byte array to set, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setAsciiStream(...) -> NamedQuery
- **Signature:** `public NamedQuery setAsciiStream(final String parameterName, final InputStream x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to an ASCII stream value.
- **Contract:**
  - The stream should contain only ASCII characters.
  - Note that the stream will be read when the query is executed, not when this method is called.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`InputStream`) — the InputStream containing ASCII data, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setAsciiStream(String, InputStream, long)
- **Signature:** `public NamedQuery setAsciiStream(final String parameterName, final InputStream x, final long length) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to an ASCII stream value with a specified length.
- **Contract:**
  - <p> This method is used to set very large ASCII values when the length is known.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`InputStream`) — the InputStream containing ASCII data, or {@code null} to set SQL NULL
  - `length` (`long`) — the number of bytes in the stream
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setAsciiStream(String, InputStream)
##### setBinaryStream(...) -> NamedQuery
- **Signature:** `public NamedQuery setBinaryStream(final String parameterName, final InputStream x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a binary stream value.
- **Contract:**
  - The stream will be read when the query is executed, not when this method is called.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`InputStream`) — the InputStream containing binary data, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setBinaryStream(String, InputStream, long)
- **Signature:** `public NamedQuery setBinaryStream(final String parameterName, final InputStream x, final long length) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a binary stream value with a specified length.
- **Contract:**
  - <p> This method is used to set very large binary values when the length is known.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`InputStream`) — the InputStream containing binary data, or {@code null} to set SQL NULL
  - `length` (`long`) — the number of bytes in the stream
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setBinaryStream(String, InputStream)
##### setCharacterStream(...) -> NamedQuery
- **Signature:** `public NamedQuery setCharacterStream(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a character stream value.
- **Contract:**
  - The Reader should contain Unicode character data.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Reader`) — the Reader containing character data, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setCharacterStream(String, Reader, long)
- **Signature:** `public NamedQuery setCharacterStream(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a character stream value with a specified length.
- **Contract:**
  - <p> This method is used to set very large character values when the length is known.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Reader`) — the Reader containing character data, or {@code null} to set SQL NULL
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setCharacterStream(String, Reader)
##### setNCharacterStream(...) -> NamedQuery
- **Signature:** `public NamedQuery setNCharacterStream(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a national character stream value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Reader`) — the Reader containing national character data, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setNCharacterStream(String, Reader, long)
- **Signature:** `public NamedQuery setNCharacterStream(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a national character stream value with a specified length.
- **Contract:**
  - <p> This method is used to set very large NCHAR, NVARCHAR, or NCLOB values when the length is known.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`Reader`) — the Reader containing national character data, or {@code null} to set SQL NULL
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #setNCharacterStream(String, Reader)
##### setBlob(...) -> NamedQuery
- **Signature:** `public NamedQuery setBlob(final String parameterName, final java.sql.Blob x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Blob value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.sql.Blob`) — the java.sql.Blob object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setBlob(final String parameterName, final InputStream x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a BLOB value using an InputStream.
- **Contract:**
  - This is convenient when you have binary data in a stream format.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`InputStream`) — the InputStream containing the BLOB data, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setBlob(final String parameterName, final InputStream x, final long length) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a BLOB value using an InputStream with a specified length.
- **Contract:**
  - This is more efficient when the size is known and ensures exactly the specified amount of data is read.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`InputStream`) — the InputStream containing the BLOB data, or {@code null} to set SQL NULL
  - `length` (`long`) — the number of bytes to read from the stream
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
##### setClob(...) -> NamedQuery
- **Signature:** `public NamedQuery setClob(final String parameterName, final java.sql.Clob x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets the specified named parameter to a java.sql.Clob value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter to be set (without the ':' prefix)
  - `x` (`java.sql.Clob`) — the java.sql.Clob object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the SQL query
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `public NamedQuery setClob(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets a CLOB (Character Large Object) parameter using a Reader for the specified parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Reader`) — the Reader object containing the CLOB data, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
- **Signature:** `public NamedQuery setClob(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException`
- **Summary:** Sets a CLOB (Character Large Object) parameter using a Reader with a specified length for the parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Reader`) — the Reader object containing the CLOB data
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs, this method is called on a closed PreparedStatement, or the length is less than zero
##### setNClob(...) -> NamedQuery
- **Signature:** `public NamedQuery setNClob(final String parameterName, final java.sql.NClob x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an NCLOB (National Character Large Object) parameter for the specified parameter name.
- **Contract:**
  - <p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`java.sql.NClob`) — the NClob object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
- **Signature:** `public NamedQuery setNClob(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an NCLOB (National Character Large Object) parameter using a Reader for the specified parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Reader`) — the Reader object containing the NCLOB data, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
- **Signature:** `public NamedQuery setNClob(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an NCLOB (National Character Large Object) parameter using a Reader with a specified length.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Reader`) — the Reader object containing the NCLOB data
  - `length` (`long`) — the number of characters in the stream
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs, this method is called on a closed PreparedStatement, or the length is less than zero
##### setURL(...) -> NamedQuery
- **Signature:** `public NamedQuery setURL(final String parameterName, final URL x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets a URL parameter for the specified parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`URL`) — the URL object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
##### setSQLXML(...) -> NamedQuery
- **Signature:** `public NamedQuery setSQLXML(final String parameterName, final java.sql.SQLXML x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an SQL XML parameter for the specified parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`java.sql.SQLXML`) — the SQLXML object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
##### setRowId(...) -> NamedQuery
- **Signature:** `public NamedQuery setRowId(final String parameterName, final java.sql.RowId x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets a RowId parameter for the specified parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`java.sql.RowId`) — the RowId object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
##### setRef(...) -> NamedQuery
- **Signature:** `public NamedQuery setRef(final String parameterName, final java.sql.Ref x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets a Ref (SQL REF) parameter for the specified parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`java.sql.Ref`) — the Ref object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
##### setArray(...) -> NamedQuery
- **Signature:** `public NamedQuery setArray(final String parameterName, final java.sql.Array x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Array parameter for the specified parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`java.sql.Array`) — the Array object, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
##### setObject(...) -> NamedQuery
- **Signature:** `public NamedQuery setObject(final String parameterName, final Object x) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Object parameter for the specified parameter name, using the default SQL type mapping.
- **Contract:**
  - Common mappings include: <ul> <li> String \\u2192 VARCHAR/CHAR </li> <li> Integer/Long \\u2192 INTEGER/BIGINT </li> <li> BigDecimal \\u2192 NUMERIC/DECIMAL </li> <li> Date/Timestamp \\u2192 DATE/TIMESTAMP </li> <li> Boolean \\u2192 BOOLEAN/BIT </li> <li> byte\[\] \\u2192 BINARY/VARBINARY </li> </ul> <p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Object`) — the object containing the parameter value, or {@code null} to set SQL NULL
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs, this method is called on a closed PreparedStatement, or the given object cannot be converted to a SQL type
- **Signature:** `public NamedQuery setObject(final String parameterName, final Object x, final int sqlType) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Object parameter with a specified SQL type for the parameter name.
- **Contract:**
  - <p> This method allows explicit control over the SQL type used when setting the parameter value.
  - Use this when the default type mapping is not sufficient or when you need to ensure a specific SQL type.
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Object`) — the object containing the parameter value, or {@code null} to set SQL NULL
  - `sqlType` (`int`) — the SQL type (from java.sql.Types) to be used
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type
- **See also:** java.sql.Types
- **Signature:** `public NamedQuery setObject(final String parameterName, final Object x, final int sqlType, final int scaleOrLength) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Object parameter with a specified SQL type and scale/length for the parameter name.
- **Contract:**
  - <p> This method provides the most control over parameter setting, allowing specification of both SQL type and additional type-specific information: <ul> <li> For numeric types (DECIMAL, NUMERIC): scaleOrLength represents the number of digits after the decimal point </li> <li> For character types (CHAR, VARCHAR): scaleOrLength represents the length of the string </li> <li> For binary types (BINARY, VARBINARY): scaleOrLength represents the length in bytes </li> </ul> <p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Object`) — the object containing the parameter value
  - `sqlType` (`int`) — the SQL type (from java.sql.Types) to be used
  - `scaleOrLength` (`int`) — for numeric types, the number of digits after the decimal point; for character/binary types, the length
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type
- **See also:** java.sql.Types
- **Signature:** `public NamedQuery setObject(final String parameterName, final Object x, final SQLType sqlType) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Object parameter with a specified SQLType for the parameter name.
- **Contract:**
  - If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Object`) — the object containing the parameter value, or {@code null} to set SQL NULL
  - `sqlType` (`SQLType`) — the SQLType to be used
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type
- **Signature:** `public NamedQuery setObject(final String parameterName, final Object x, final SQLType sqlType, final int scaleOrLength) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Object parameter with a specified SQLType and scale/length for the parameter name.
- **Contract:**
  - <p> This method provides the most control when using JDBC 4.2 SQLType, allowing specification of both SQL type and additional type-specific information.
  - <p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`Object`) — the object containing the parameter value
  - `sqlType` (`SQLType`) — the SQLType to be used
  - `scaleOrLength` (`int`) — for numeric types, the number of digits after the decimal point; for character/binary types, the length
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type
- **Signature:** `public <T> NamedQuery setObject(final String parameterName, final T x, final Type<T> type) throws IllegalArgumentException, SQLException`
- **Summary:** Sets an Object parameter using a custom Type handler for the parameter name.
- **Contract:**
  - This is particularly useful for complex type mappings or when working with custom data types.
  - <p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value.
- **Parameters:**
  - `parameterName` (`String`) — the name of the parameter (without the ':' prefix)
  - `x` (`T`) — the object containing the parameter value
  - `type` (`Type<T>`) — the Type handler to use for setting the parameter
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
##### setParameters(...) -> NamedQuery
- **Signature:** `public NamedQuery setParameters(final Map<String, ?> parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets multiple parameters from a Map containing parameter names and their values.
- **Parameters:**
  - `parameters` (`Map<String, ?>`) — a map containing parameter names (without ':' prefix) as keys and their values
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if the parameters map is null
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("rawtypes") public NamedQuery setParameters(final Object parameters) throws IllegalArgumentException, SQLException`
- **Summary:** Sets parameters from various types of objects including beans, maps, collections, arrays, or single values.
- **Contract:**
  - <p> This flexible method accepts different parameter sources: <ul> <li> <b> Bean/Entity objects </b> : Properties matching parameter names will be used </li> <li> <b> Map </b> : Entries with keys matching parameter names will be used </li> <li> <b> Collection/Array </b> : Elements will be assigned to parameters in positional order </li> <li> <b> EntityId </b> : Values with keys matching parameter names will be used </li> <li> <b> Single value </b> : Used only if the query has exactly one parameter </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Using a bean User user = new User("John", 30, "john@example.com"); query.setParameters(user); // Using a Map Map<String, Object> params = Map.of("name", "John", "age", 30); query.setParameters(params); // Using an array (parameters set by position) query.setParameters(new Object\[\] {"John", 30, "john@example.com"}); // Using a single value (for queries with one parameter) query.setParameters("John"); } </pre>
- **Parameters:**
  - `parameters` (`Object`) — an object containing the parameters (bean, map, collection, array, or single value)
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parameters is {@code null} or of an unsupported type
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** JdbcUtil#getNamedParameters(String)
- **Signature:** `public NamedQuery setParameters(final Object entity, final Collection<String> parameterNames) throws IllegalArgumentException, SQLException`
- **Summary:** Sets specific parameters from an entity object using only the specified parameter names.
- **Parameters:**
  - `entity` (`Object`) — the entity object containing the parameter values
  - `parameterNames` (`Collection<String>`) — a collection of parameter names to be set from the entity
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if entity or parameterNames is {@code null} , if entity is not a bean class, if a property is not found in the entity, or if a parameter name is not found in the query
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Beans#getPropNameList(Class), Beans#getPropNames(Class, Collection), JdbcUtil#getNamedParameters(String)
- **Signature:** `public <T> NamedQuery setParameters(final T parameters, final Jdbc.TriParametersSetter<? super NamedQuery, ? super T> parametersSetter) throws IllegalArgumentException, SQLException`
- **Summary:** Sets parameters using a custom parameter setter function.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code UserSearchCriteria criteria = new UserSearchCriteria(); criteria.setMinAge(25); criteria.setMaxAge(35); criteria.setActive(true); query.setParameters(criteria, (sql, q, c) -> { q.setInt("min_age", c.getMinAge()); q.setInt("max_age", c.getMaxAge()); if (c.isActive() != null) { q.setBoolean("is_active", c.isActive()); } }); } </pre>
- **Parameters:**
  - `parameters` (`T`) — the parameters object to pass to the setter
  - `parametersSetter` (`Jdbc.TriParametersSetter<? super NamedQuery, ? super T>`) — a function that sets parameters on the query
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if parametersSetter is null
  - `java.sql.SQLException` — if a database access error occurs
##### addBatchParameters(...) -> NamedQuery
- **Signature:** `@Override public NamedQuery addBatchParameters(final Collection<?> batchParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Adds a collection of parameter sets for batch execution.
- **Contract:**
  - Each element in the collection should be a parameter object compatible with {@link #setParameters(Object)} , such as: <ul> <li> Bean objects with properties matching parameter names </li> <li> Maps with keys matching parameter names </li> <li> Arrays or Collections for positional parameters </li> </ul> <p> After adding batch parameters, call {@code executeBatch()} to execute the batch.
- **Parameters:**
  - `batchParameters` (`Collection<?>`) — a collection of parameter objects for batch processing
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if batchParameters is {@code null} or contains invalid parameter objects
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
- **See also:** #setParameters(Object), #addBatch()
- **Signature:** `@Beta @Override @SuppressWarnings("rawtypes") public NamedQuery addBatchParameters(final Iterator<?> batchParameters) throws IllegalArgumentException, SQLException`
- **Summary:** Adds a batch of parameters from an iterator for batch execution.
- **Contract:**
  - Each element provided by the iterator should be a parameter object compatible with {@link #setParameters(Object)} , such as: <ul> <li> Bean objects with properties matching parameter names </li> <li> Maps with keys matching parameter names </li> <li> Arrays or Collections for positional parameters </li> </ul> <p> After adding batch parameters, call {@code executeBatch()} to execute the batch.
- **Parameters:**
  - `batchParameters` (`Iterator<?>`) — an iterator providing parameter objects for batch processing
- **Returns:** this NamedQuery instance for method chaining
- **Throws:**
  - `java.lang.IllegalArgumentException` — if batchParameters is {@code null} or contains invalid parameter objects
  - `java.sql.SQLException` — if a database access error occurs or this method is called on a closed PreparedStatement
- **See also:** #setParameters(Object), #addBatchParameters(Collection), #addBatch()

### Enum OP (com.landawn.abacus.jdbc.OP)
Enum representing various database operations that can be performed through AbstractQuery.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Enum OnDeleteAction (com.landawn.abacus.jdbc.OnDeleteAction)
Represents foreign key constraint actions that can be performed when a referenced row is deleted.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
##### get(...) -> OnDeleteAction
- **Signature:** `@Deprecated public static OnDeleteAction get(final String name)`
- **Summary:** Returns the {@code OnDeleteAction} enum constant that corresponds to the given string name.
- **Parameters:**
  - `name` (`String`) — the string representation of the delete action (case-insensitive). Expected values are "noAction", "setNull", or "cascade". Cannot be null.
- **Returns:** the corresponding {@code OnDeleteAction} enum constant.

#### Public Instance Methods
##### value(...) -> int
- **Signature:** `@Deprecated public int value()`
- **Summary:** Returns the raw integer value associated with this {@code OnDeleteAction} .
- **Contract:**
  - <p> The integer values are: </p> <ul> <li> {@link #NO_ACTION} : 0 </li> <li> {@link #SET_NULL} : 1 </li> <li> {@link #CASCADE} : 2 </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Example: Storing the action value OnDeleteAction action = OnDeleteAction.CASCADE; int actionValue = action.value(); System.out.println("Action code: " + actionValue); // Prints: Action code: 2 // Example: Using value for conditional logic if (action.value() == 0) { System.out.println("No cascading delete will occur"); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the integer value representing this delete action (0 for NO_ACTION, 1 for SET_NULL, 2 for CASCADE).

### Class PreparedQuery (com.landawn.abacus.jdbc.PreparedQuery)
A wrapper class for {@link PreparedStatement} that provides a fluent API for executing parameterized SQL queries.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Enum Propagation (com.landawn.abacus.jdbc.Propagation)
Enumeration that represents transaction propagation behaviors.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Class SQLTransaction (com.landawn.abacus.jdbc.SQLTransaction)
Represents a SQL transaction that manages database transaction lifecycle and connection state.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### id(...) -> String
- **Signature:** `@Override public String id()`
- **Summary:** Returns the unique identifier of this transaction.
- **Parameters:**
  - (none)
- **Returns:** the unique transaction identifier, never {@code null}
##### connection(...) -> Connection
- **Signature:** `public Connection connection()`
- **Summary:** Returns the JDBC connection associated with this transaction.
- **Contract:**
  - This connection should not be closed manually as it will be managed by the transaction.
- **Parameters:**
  - (none)
- **Returns:** the JDBC connection used by this transaction
##### isolationLevel(...) -> IsolationLevel
- **Signature:** `@Override public IsolationLevel isolationLevel()`
- **Summary:** Returns the isolation level of this transaction.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran = JdbcUtil.beginTransaction(dataSource, IsolationLevel.SERIALIZABLE); IsolationLevel level = tran.isolationLevel(); if (level == IsolationLevel.SERIALIZABLE) { // Handle high isolation scenario } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the transaction isolation level, never {@code null}
- **See also:** IsolationLevel
##### status(...) -> Transaction.Status
- **Signature:** `@Override public Transaction.Status status()`
- **Summary:** Returns the current status of this transaction.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); Transaction.Status status = tran.status(); if (status == Transaction.Status.ACTIVE) { // Transaction is still active and can be committed or rolled back } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the current transaction status, never {@code null}
- **See also:** Transaction.Status
##### isActive(...) -> boolean
- **Signature:** `@Override public boolean isActive()`
- **Summary:** Checks if this transaction is currently active.
- **Contract:**
  - Checks if this transaction is currently active.
  - A transaction is active if it has not been committed, rolled back, or marked for rollback.
  - <p> This is a convenience method equivalent to checking if the status equals {@link Status#ACTIVE} .
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); if (tran.isActive()) { // Safe to perform operations within this transaction performDatabaseOperations(); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if the transaction is active, {@code false} otherwise
##### commit(...) -> void
- **Signature:** `@Override public void commit() throws UncheckedSQLException`
- **Summary:** Commits the current transaction, making all changes permanent.
- **Contract:**
  - After a successful commit, the transaction is no longer active and the connection will be automatically reset and closed (if applicable).
  - <p> If the transaction is marked for rollback only, it will be rolled back instead of committed.
- **Parameters:**
  - (none)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if an SQL error occurs during the commit
##### rollback(...) -> void
- **Signature:** `@Deprecated @Override public void rollback() throws UncheckedSQLException`
- **Summary:** Rolls back the current transaction, undoing all changes made within the transaction scope.
- **Contract:**
  - After a successful rollback, the transaction is no longer active and the connection will be automatically reset and closed (if applicable).
- **Parameters:**
  - (none)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if an SQL error occurs during the rollback
##### rollbackIfNotCommitted(...) -> void
- **Signature:** `@Override public void rollbackIfNotCommitted() throws UncheckedSQLException`
- **Summary:** Rolls back the transaction if it has not been committed successfully.
- **Contract:**
  - Rolls back the transaction if it has not been committed successfully.
  - This method is safe to call multiple times and will only perform a rollback if the transaction is still active or in a failed commit state.
  - It will do nothing if the transaction has already been committed.
- **Parameters:**
  - (none)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if an SQL error occurs during the rollback
##### runNotInMe(...) -> void
- **Signature:** `public <E extends Throwable> void runNotInMe(final Throwables.Runnable<E> cmd) throws E`
- **Summary:** Executes the specified {@code Runnable} outside of this transaction context.
- **Contract:**
  - <p> This is useful when you need to perform operations that should not be part of the current transaction, such as logging or audit operations that should not be rolled back with the main transaction.
- **Parameters:**
  - `cmd` (`Throwables.Runnable<E>`) — the {@code Runnable} to be executed outside of this transaction, must not be {@code null}
- **Throws:**
  - `E` — if the {@code Runnable} throws an exception
##### callNotInMe(...) -> R
- **Signature:** `public <R, E extends Throwable> R callNotInMe(final Throwables.Callable<R, E> cmd) throws E`
- **Summary:** Executes the specified {@code Callable} outside of this transaction context.
- **Contract:**
  - <p> This is useful when you need to perform operations that should not be part of the current transaction and return a result, such as querying data that should not be affected by uncommitted changes.
- **Parameters:**
  - `cmd` (`Throwables.Callable<R, E>`) — the {@code Callable} to be executed outside of this transaction, must not be {@code null}
- **Returns:** the result returned by the {@code Callable}
- **Throws:**
  - `E` — if the {@code Callable} throws an exception
##### close(...) -> void
- **Signature:** `@Override public void close()`
- **Summary:** Closes this transaction by calling {@link #rollbackIfNotCommitted()} .
- **Parameters:**
  - (none)
- **See also:** #rollbackIfNotCommitted()
##### hashCode(...) -> int
- **Signature:** `@Override public int hashCode()`
- **Summary:** Returns the hash code value for this transaction.
- **Parameters:**
  - (none)
- **Returns:** the hash code value for this transaction
##### equals(...) -> boolean
- **Signature:** `@Override public boolean equals(final Object obj)`
- **Summary:** Indicates whether some other object is "equal to" this transaction.
- **Contract:**
  - Two transactions are considered equal if they have the same timed ID.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran1 = JdbcUtil.beginTransaction(dataSource); SQLTransaction tran2 = tran1; if (tran1.equals(tran2)) { // Same transaction instance } } </pre>
- **Parameters:**
  - `obj` (`Object`) — the reference object with which to compare
- **Returns:** {@code true} if this transaction is equal to the obj argument; {@code false} otherwise
##### toString(...) -> String
- **Signature:** `@Override public String toString()`
- **Summary:** Returns a string representation of this transaction.
- **Parameters:**
  - (none)
- **Returns:** a string representation of this transaction

### Interface Transaction (com.landawn.abacus.jdbc.Transaction)
Represents a database transaction that provides methods for managing transactional operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### id(...) -> String
- **Signature:** `String id()`
- **Summary:** Returns the unique identifier of this transaction.
- **Contract:**
  - The identifier is typically generated when the transaction is created and remains constant throughout the transaction's lifecycle.
- **Parameters:**
  - (none)
- **Returns:** the unique identifier of the transaction, never {@code null}
##### isolationLevel(...) -> IsolationLevel
- **Signature:** `IsolationLevel isolationLevel()`
- **Summary:** Returns the isolation level of this transaction.
- **Contract:**
  - <p> Common isolation levels include: </p> <ul> <li> READ_UNCOMMITTED - Allows dirty reads </li> <li> READ_COMMITTED - Prevents dirty reads </li> <li> REPEATABLE_READ - Prevents dirty and non-repeatable reads </li> <li> SERIALIZABLE - Prevents all phenomena </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code IsolationLevel level = transaction.isolationLevel(); if (level == IsolationLevel.SERIALIZABLE) { // Handle high isolation scenario } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the isolation level of the transaction, never {@code null}
##### status(...) -> Status
- **Signature:** `Status status()`
- **Summary:** Returns the current status of this transaction.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Status status = transaction.status(); if (status == Status.ACTIVE) { // Transaction is still active and can be committed or rolled back } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the current status of the transaction, never {@code null}
- **See also:** Status
##### isActive(...) -> boolean
- **Signature:** `boolean isActive()`
- **Summary:** Checks if this transaction is currently active.
- **Contract:**
  - Checks if this transaction is currently active.
  - A transaction is considered active if it has been started but not yet committed or rolled back.
  - <p> This is a convenience method equivalent to checking if the status equals {@link Status#ACTIVE} .
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code if (transaction.isActive()) { // Safe to perform operations within this transaction performDatabaseOperations(); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if the transaction is active, {@code false} otherwise
##### commit(...) -> void
- **Signature:** `void commit() throws UncheckedSQLException`
- **Summary:** Commits the current transaction, making all changes permanent.
- **Contract:**
  - <p> If the commit fails, the transaction status will be set to {@link Status#FAILED_COMMIT} and an exception will be thrown.
- **Parameters:**
  - (none)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if an SQL error occurs during the commit, or if the transaction is not in an active state
##### rollback(...) -> void
- **Signature:** `void rollback() throws UncheckedSQLException`
- **Summary:** Rolls back the current transaction, undoing all changes made within the transaction scope.
- **Contract:**
  - <p> If the rollback fails, the transaction status will be set to {@link Status#FAILED_ROLLBACK} and an exception will be thrown.
- **Parameters:**
  - (none)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if an SQL error occurs during the rollback, or if the transaction is not in an active state
##### rollbackIfNotCommitted(...) -> void
- **Signature:** `void rollbackIfNotCommitted() throws UncheckedSQLException`
- **Summary:** Rolls back the transaction if it has not been committed successfully.
- **Contract:**
  - Rolls back the transaction if it has not been committed successfully.
  - This method is safe to call multiple times and will only perform a rollback if the transaction is still active or in a failed commit state.
- **Parameters:**
  - (none)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if an SQL error occurs during the rollback attempt

### Enum Status (com.landawn.abacus.jdbc.Transaction.Status)
Enumeration representing the various states a transaction can be in during its lifecycle.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Enum Action (com.landawn.abacus.jdbc.Transaction.Action)
Enumeration representing the possible actions that can be performed on a transaction.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Class cs (com.landawn.abacus.jdbc.cs)
Constants container class providing standardized parameter and field names used throughout the Abacus JDBC framework.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

## com.landawn.abacus.jdbc.annotation
### Annotation Bind (com.landawn.abacus.jdbc.annotation.Bind)
Binds a method parameter to a named parameter in SQL queries.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `String value() default ""`
- **Summary:** Specifies the parameter name to be used in the SQL query.
- **Contract:**
  - If not specified (empty string), the parameter name will be used.
- **Parameters:**
  - (none)
- **Returns:** the parameter name, or empty string if using the actual parameter name

### Annotation BindList (com.landawn.abacus.jdbc.annotation.BindList)
Binds a collection or array parameter to a SQL query, automatically expanding it into the appropriate number of parameter placeholders.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `String value() default ""`
- **Summary:** Specifies the parameter name to be used in the SQL query.
- **Contract:**
  - If not specified (empty string), the parameter name will be used.
  - The string passed to {@code value} must exactly match the template variable used in the {@code @Query} SQL (for example, {@code @BindList("ids")} must correspond to {@code ...
  - <p> The parameter should be referenced in the SQL using curly braces: {@code {paramName}} </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Explicit name @Query("SELECT * FROM users WHERE id IN ({userIds})") List<User> find(@BindList("userIds") List<Long> ids); // Using parameter name (when value is not specified) @Query("SELECT * FROM users WHERE id IN ({ids})") List<User> find(@BindList List<Long> ids); } </pre>
- **Parameters:**
  - (none)
- **Returns:** the parameter name, or empty string if using the actual parameter name
##### prefixForNonEmpty(...) -> String
- **Signature:** `@Beta String prefixForNonEmpty() default ""`
- **Summary:** Specifies a prefix to add before the parameter placeholder when the collection is non-empty.
- **Contract:**
  - Specifies a prefix to add before the parameter placeholder when the collection is non-empty.
- **Parameters:**
  - (none)
- **Returns:** the prefix to add when collection is non-empty
##### suffixForNonEmpty(...) -> String
- **Signature:** `@Beta String suffixForNonEmpty() default ""`
- **Summary:** Specifies a suffix to add after the parameter placeholder when the collection is non-empty.
- **Contract:**
  - Specifies a suffix to add after the parameter placeholder when the collection is non-empty.
- **Parameters:**
  - (none)
- **Returns:** the suffix to add when collection is non-empty

### Annotation Cache (com.landawn.abacus.jdbc.annotation.Cache)
Enables caching at the DAO level for database query results.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### capacity(...) -> int
- **Signature:** `int capacity() default JdbcUtil.DEFAULT_BATCH_SIZE`
- **Summary:** Specifies the maximum number of entries the cache can hold.
- **Contract:**
  - When the cache reaches this capacity, the least recently used entries will be evicted to make room for new entries.
- **Parameters:**
  - (none)
- **Returns:** the maximum number of cache entries
##### evictDelay(...) -> long
- **Signature:** `long evictDelay() default JdbcUtil.DEFAULT_CACHE_EVICT_DELAY`
- **Summary:** Specifies the time delay (in milliseconds) after which cached entries will be evicted.
- **Parameters:**
  - (none)
- **Returns:** the eviction delay in milliseconds
##### impl(...) -> Class<? extends DaoCache>
- **Signature:** `Class<? extends DaoCache> impl() default Jdbc.DefaultDaoCache.class`
- **Summary:** Specifies the implementation class for the DAO cache.
- **Contract:**
  - The implementation must extend {@link DaoCache} and have a public constructor that accepts two parameters: {@code (int capacity, long evictDelay)} .
- **Parameters:**
  - (none)
- **Returns:** the cache implementation class

### Annotation CacheResult (com.landawn.abacus.jdbc.annotation.CacheResult)
Enables method-level result caching for DAO query methods.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### disabled(...) -> boolean
- **Signature:** `boolean disabled() default false`
- **Summary:** Disables caching when set to {@code true} .
- **Contract:**
  - Disables caching when set to {@code true} .
- **Parameters:**
  - (none)
- **Returns:** {@code true} to disable caching, {@code false} to enable
##### liveTime(...) -> long
- **Signature:** `long liveTime() default JdbcUtil.DEFAULT_CACHE_LIVE_TIME`
- **Summary:** Specifies the maximum time (in milliseconds) a cached entry can live.
- **Parameters:**
  - (none)
- **Returns:** the maximum cache entry lifetime in milliseconds
##### maxIdleTime(...) -> long
- **Signature:** `long maxIdleTime() default JdbcUtil.DEFAULT_CACHE_MAX_IDLE_TIME`
- **Summary:** Specifies the maximum idle time (in milliseconds) for a cached entry.
- **Contract:**
  - If an entry is not accessed within this time, it expires and is removed.
  - This is useful for frequently accessed data that should expire if unused.
  - <p> The entry expires when either {@code liveTime} or {@code maxIdleTime} is exceeded, whichever comes first.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Expire if not accessed for 10 minutes @CacheResult(liveTime = 3600000, maxIdleTime = 600000) @Query("SELECT * FROM user_sessions WHERE token = :token") UserSession getSession(@Bind("token") String token); } </pre>
- **Parameters:**
  - (none)
- **Returns:** the maximum idle time in milliseconds
##### minSize(...) -> int
- **Signature:** `int minSize() default 0`
- **Summary:** Specifies the minimum size requirement for caching collection results.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Only cache if result has at least 10 items @CacheResult(minSize = 10) @Query("SELECT * FROM products WHERE category = :category") List<Product> findByCategory(@Bind("category") String category); } </pre>
- **Parameters:**
  - (none)
- **Returns:** the minimum collection size to cache, 0 means no minimum
##### maxSize(...) -> int
- **Signature:** `int maxSize() default Integer.MAX_VALUE`
- **Summary:** Specifies the maximum size limit for caching collection results.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Don't cache if result has more than 1000 items @CacheResult(maxSize = 1000) @Query("SELECT * FROM orders WHERE date >= :startDate") List<Order> findOrdersSince(@Bind("startDate") Date date); } </pre>
- **Parameters:**
  - (none)
- **Returns:** the maximum collection size to cache
##### transfer(...) -> String
- **Signature:** `String transfer() default "none"`
- **Summary:** Specifies the serialization strategy for cache storage and retrieval.
- **Contract:**
  - This determines how objects are copied when stored in or retrieved from cache.
- **Parameters:**
  - (none)
- **Returns:** the serialization strategy name
- **See also:** <a href="https://github.com/EsotericSoftware/kryo">,Kryo Serialization,</a>
##### filter(...) -> String\[\]
- **Signature:** `String[] filter() default { "query", "queryFor", "list", "get", "batchGet", "find", "findFirst", "findOnlyOne", "exist", "notExist", "count" }`
- **Summary:** Specifies filter patterns for methods when the annotation is applied at the class level.
- **Contract:**
  - Specifies filter patterns for methods when the annotation is applied at the class level.
  - </p> <p> This filter is ignored when the annotation is applied at the method level.
- **Parameters:**
  - (none)
- **Returns:** array of method name patterns to cache

### Annotation DaoConfig (com.landawn.abacus.jdbc.annotation.DaoConfig)
Provides DAO-level configuration options that affect query generation and execution behavior.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### addLimitForSingleQuery(...) -> boolean
- **Signature:** `boolean addLimitForSingleQuery() default false`
- **Summary:** Controls whether to automatically add LIMIT clause to single-result query methods.
- **Contract:**
  - When {@code true} , methods that return a single result will have {@code LIMIT 1} (or equivalent) added to their SQL queries for better performance.
  - <p> Single query methods include: </p> <ul> <li> {@code queryForSingleXxx()} methods </li> <li> {@code queryForUniqueResult()} </li> <li> {@code findFirst()} </li> <li> {@code findOnlyOne()} </li> <li> {@code exists()} </li> <li> {@code count()} (when not using COUNT in SQL) </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code @DaoConfig(addLimitForSingleQuery = true) public interface ProductDao extends CrudDao<Product, Long> { @Query("SELECT * FROM products WHERE code = :code") Product findByCode(@Bind("code") String code); // Executed as: SELECT * FROM products WHERE code = ?
- **Parameters:**
  - (none)
- **Returns:** {@code true} to auto-add LIMIT clause, {@code false} otherwise
##### callGenerateIdForInsertIfIdNotSet(...) -> boolean
- **Signature:** `boolean callGenerateIdForInsertIfIdNotSet() default false`
- **Summary:** Controls whether to automatically call {@code generateId()} for entity inserts when the ID field is not set or has a default value.
- **Contract:**
  - Controls whether to automatically call {@code generateId()} for entity inserts when the ID field is not set or has a default value.
  - The ID is considered "not set" when it's null or has the default value for its type (0 for numeric types, null for objects).
- **Parameters:**
  - (none)
- **Returns:** {@code true} to auto-generate IDs for insert operations
##### callGenerateIdForInsertWithSqlIfIdNotSet(...) -> boolean
- **Signature:** `boolean callGenerateIdForInsertWithSqlIfIdNotSet() default false`
- **Summary:** Controls whether to automatically call {@code generateId()} for SQL-based entity inserts when the ID field is not set or has a default value.
- **Contract:**
  - Controls whether to automatically call {@code generateId()} for SQL-based entity inserts when the ID field is not set or has a default value.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code @DaoConfig(callGenerateIdForInsertWithSqlIfIdNotSet = true) public interface OrderDao extends CrudDao<Order, Long> { default void insertWithAudit(Order order) { String sql = "INSERT INTO orders (id, customer_id, total, created_by) " + "VALUES (:id, :customerId, :total, CURRENT_USER())"; insert(sql, order); // generateId() called if order.id not set } } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} to auto-generate IDs for SQL-based insert operations
##### allowJoiningByNullOrDefaultValue(...) -> boolean
- **Signature:** `boolean allowJoiningByNullOrDefaultValue() default false`
- **Summary:** Controls whether joins can be performed using null or default values in join conditions.
- **Contract:**
  - When false (default), joins with null values are skipped for safety.
  - When true, allows joins even when the joining column contains null.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code @DaoConfig(allowJoiningByNullOrDefaultValue = true) public interface CustomerDao extends CrudDao<Customer, Long> { // Allows join even if preferred_contact_id is null @Query("SELECT c.*, p.* FROM customers c " + "LEFT JOIN contacts p ON c.preferred_contact_id = p.id") @MergedById List<Customer> findAllWithPreferredContacts(); } } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} to allow joins with null/default values
##### fetchColumnByEntityClassForDatasetQuery(...) -> boolean
- **Signature:** `boolean fetchColumnByEntityClassForDatasetQuery() default true`
- **Summary:** Controls whether Dataset queries should fetch only columns that match entity class properties.
- **Contract:**
  - Controls whether Dataset queries should fetch only columns that match entity class properties.
  - When true (default), Dataset queries will only include columns that correspond to properties in the target entity class, similar to {@link FetchColumnByEntityClass} .
- **Parameters:**
  - (none)
- **Returns:** {@code true} to fetch only entity columns in Dataset queries

### Annotation FetchColumnByEntityClass (com.landawn.abacus.jdbc.annotation.FetchColumnByEntityClass)
Controls whether query results should be fetched based on the entity class properties when the return type is a Dataset or similar structure.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> boolean
- **Signature:** `boolean value() default true`
- **Summary:** Specifies whether to fetch only columns that match entity class properties.
- **Contract:**
  - <p> When {@code true} (default): </p> <ul> <li> Only columns with matching properties in the entity class are fetched </li> <li> Provides better performance by reducing data transfer </li> <li> Results in cleaner Dataset with only relevant columns </li> </ul> <p> When {@code false} : </p> <ul> <li> All columns from the query result are fetched </li> <li> Useful when you need additional calculated or joined columns </li> <li> May include columns that don't map to entity properties </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Entity class public class User { private Long id; private String name; private String email; // Getters and setters } // DAO method @Query("SELECT id, name, email, COUNT(*) as login_count FROM users GROUP BY id, name, email") @FetchColumnByEntityClass(false) // Need to fetch login_count Dataset getUserLoginStats(); } </pre>
- **Parameters:**
  - (none)
- **Returns:** {@code true} to fetch only entity columns, {@code false} to fetch all columns

### Annotation Handler (com.landawn.abacus.jdbc.annotation.Handler)
Defines an interceptor handler for DAO methods or entire DAO interfaces.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### qualifier(...) -> String
- **Signature:** `String qualifier() default ""`
- **Summary:** Specifies a qualifier to distinguish between multiple handlers of the same type.
- **Contract:**
  - This is useful when you need different configurations of the same handler class.
- **Parameters:**
  - (none)
- **Returns:** the qualifier string, or empty string if not specified
##### type(...) -> Class<? extends Jdbc.Handler<? extends Dao>>
- **Signature:** `@SuppressWarnings("rawtypes") Class<? extends Jdbc.Handler<? extends Dao>> type() default EmptyHandler.class`
- **Summary:** Specifies the handler implementation class.
- **Contract:**
  - The class must extend {@link Jdbc.Handler} with the appropriate DAO type parameter.
  - <p> The handler lifecycle methods are called in this order: </p> <ol> <li> {@code beforeInvoke()} - Before the actual method invocation </li> <li> Actual DAO method execution </li> <li> {@code afterInvoke()} - After successful completion (with result) </li> <li> {@code onError()} - If an exception occurs (instead of afterInvoke) </li> </ol> <p> Example handler implementation: </p> <pre> {@code public class SecurityHandler extends Jdbc.Handler<BaseDao> { @Override public void beforeInvoke(BaseDao dao, Method method, Object\[\] args) { // Check user permissions if (!hasPermission(method)) { throw new SecurityException("Access denied"); } } @Override public Object afterInvoke(Object result, BaseDao dao, Method method, Object\[\] args) { // Can modify or filter results return filterSensitiveData(result); } } } </pre>
- **Parameters:**
  - (none)
- **Returns:** the handler class, defaults to {@link EmptyHandler} (no-op)
##### filter(...) -> String\[\]
- **Signature:** `String[] filter() default { ".*" }`
- **Summary:** Specifies filter patterns for methods when the annotation is applied at the class level.
- **Contract:**
  - Specifies filter patterns for methods when the annotation is applied at the class level.
  - </p> <p> This filter is ignored when the annotation is applied at the method level.
- **Parameters:**
  - (none)
- **Returns:** array of filter patterns, default matches all methods
##### isForInvokeFromOutsideOfDaoOnly(...) -> boolean
- **Signature:** `boolean isForInvokeFromOutsideOfDaoOnly() default false`
- **Summary:** Specifies whether this handler should only be applied to external invocations of the DAO.
- **Contract:**
  - Specifies whether this handler should only be applied to external invocations of the DAO.
  - When {@code true} , the handler will not be triggered for internal method calls within the DAO.
  - <p> This is useful for handlers that should only apply when the DAO is called from outside code, not when DAO methods call each other internally.
- **Parameters:**
  - (none)
- **Returns:** {@code true} if handler only applies to external calls, {@code false} otherwise

### Annotation HandlerList (com.landawn.abacus.jdbc.annotation.HandlerList)
Container annotation for multiple {@link Handler} annotations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> Handler\[\]
- **Signature:** `Handler[] value()`
- **Summary:** Returns the array of {@link Handler} annotations contained in this list.
- **Contract:**
  - <p> When multiple handlers are applied to a DAO or method, they form a chain of interceptors, with each handler having the opportunity to: </p> <ul> <li> Modify input parameters before invocation </li> <li> Prevent the actual method execution </li> <li> Transform or filter the results </li> <li> Handle exceptions in custom ways </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Accessing HandlerList programmatically via reflection HandlerList handlers = MyDao.class.getAnnotation(HandlerList.class); if (handlers != null) { for (Handler handler : handlers.value()) { System.out.println("Handler type: " + handler.type()); System.out.println("Filter: " + Arrays.toString(handler.filter())); } } // Multiple handlers are automatically wrapped in HandlerList @Handler(type = LoggingHandler.class) @Handler(type = SecurityHandler.class) @Handler(type = CacheHandler.class) public interface UserDao extends CrudDao<User, Long> { // The compiler wraps these in a HandlerList annotation } } </pre>
- **Parameters:**
  - (none)
- **Returns:** array of Handler annotations

### Annotation MappedByKey (com.landawn.abacus.jdbc.annotation.MappedByKey)
Transforms query results into a Map structure where each result row is keyed by a specified field.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `@Deprecated String value() default ""`
- **Summary:** Legacy attribute for specifying the key field name.
- **Parameters:**
  - (none)
- **Returns:** the field name to use as map key, or empty string if using {@link #keyName()} instead
##### keyName(...) -> String
- **Signature:** `String keyName() default ""`
- **Summary:** Specifies the name of the field to use as the map key.
- **Contract:**
  - This field must exist in the query result set.
  - The field can be: </p> <ul> <li> A database column name </li> <li> An entity property name (if using entity mapping) </li> <li> An alias defined in the SQL query </li> </ul> <p> Examples: </p> <pre> {@code // Using database column name @Query("SELECT user_id, user_name, email FROM users") @MappedByKey(keyName = "user_id") Map<Long, Map<String, Object>> getUsers(); // Using entity property name @Query("SELECT * FROM products WHERE category = :category") @MappedByKey(keyName = "productCode") // Maps to product_code column Map<String, Product> getProductsByCategory(@Bind("category") String category); // Using SQL alias @Query("SELECT id, name, price * 0.9 as discounted_price FROM products") @MappedByKey(keyName = "discounted_price") Map<BigDecimal, Product> getProductsByDiscountPrice(); } </pre>
- **Parameters:**
  - (none)
- **Returns:** the field name to use as map key, or empty string if using the deprecated {@link #value()} instead
##### mapClass(...) -> Class<? extends Map>
- **Signature:** `@SuppressWarnings("rawtypes") Class<? extends Map> mapClass() default HashMap.class`
- **Summary:** Specifies the Map implementation class to use for the result.
- **Contract:**
  - The class must have a no-argument constructor.
- **Parameters:**
  - (none)
- **Returns:** the Map implementation class, defaults to HashMap

### Annotation MergedById (com.landawn.abacus.jdbc.annotation.MergedById)
Merges multiple result rows into single entities based on ID fields.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `@Deprecated String value() default ""`
- **Summary:** Specifies the ID field(s) to use for merging rows.
- **Contract:**
  - </p> <p> The automatic ID detection works for: </p> <ul> <li> Single ID fields annotated with {@code @Id} </li> <li> Composite keys using {@code @Id} on multiple fields </li> <li> Standard naming conventions (e.g., "id" field name) </li> </ul> <p> Example with composite key (legacy usage): </p> <pre> {@code // Old way (deprecated) - manually specify composite key @Query("SELECT * FROM order_items WHERE order_date = :date") @MergedById("orderId, productId") List<OrderItem> findByDate(@Bind("date") Date date); // New way (recommended) - let framework detect ID fields @Query("SELECT * FROM order_items WHERE order_date = :date") @MergedById List<OrderItem> findByDate(@Bind("date") Date date); // OrderItem class should have @Id annotations on orderId and productId fields } </pre>
- **Parameters:**
  - (none)
- **Returns:** comma-separated list of ID field names, or empty string if using automatic detection

### Annotation NonDBOperation (com.landawn.abacus.jdbc.annotation.NonDBOperation)
Marks methods in DAO interfaces that should not be treated as database operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Annotation OnDelete (com.landawn.abacus.jdbc.annotation.OnDelete)
Specifies cascading delete behavior for entity relationships.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### action(...) -> OnDeleteAction
- **Signature:** `@Deprecated OnDeleteAction action() default OnDeleteAction.NO_ACTION`
- **Summary:** Specifies the action to take when a referenced entity is deleted.
- **Contract:**
  - Specifies the action to take when a referenced entity is deleted.
  - <p> <strong> Note: </strong> This functionality should be implemented at the database level using foreign key constraints rather than in the application layer.
- **Parameters:**
  - (none)
- **Returns:** the delete action, defaults to {@link OnDeleteAction#NO_ACTION}

### Annotation OutParameter (com.landawn.abacus.jdbc.annotation.OutParameter)
Declares an output parameter for stored procedure calls.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### name(...) -> String
- **Signature:** `String name() default ""`
- **Summary:** Specifies the name of the output parameter.
- **Contract:**
  - <p> Either {@code name} or {@code position} must be specified, but not both.
  - </p> <p> The parameter name should match the name used in the stored procedure call syntax.
- **Parameters:**
  - (none)
- **Returns:** the parameter name, or empty string if using {@link #position()}
- **See also:** CallableStatement#registerOutParameter(String, int)
##### position(...) -> int
- **Signature:** `int position() default -1`
- **Summary:** Specifies the position of the output parameter.
- **Contract:**
  - Either {@code name} or {@code position} must be specified, but not both.
- **Parameters:**
  - (none)
- **Returns:** the parameter position (1-based), or -1 if using {@link #name()}
- **See also:** CallableStatement#registerOutParameter(int, int)
##### sqlType(...) -> int
- **Signature:** `int sqlType()`
- **Summary:** Specifies the SQL type of the output parameter.
- **Contract:**
  - This must be one of the constants defined in {@link java.sql.Types} .
  - <p> Common SQL types include: </p> <ul> <li> {@link Types#VARCHAR} - String values </li> <li> {@link Types#INTEGER} - Integer values </li> <li> {@link Types#DECIMAL} or {@link Types#NUMERIC} - Decimal numbers </li> <li> {@link Types#DATE} , {@link Types#TIME} , {@link Types#TIMESTAMP} - Date/time values </li> <li> {@link Types#BOOLEAN} - Boolean values </li> <li> {@link Types#CLOB} - Character large objects </li> <li> {@link Types#BLOB} - Binary large objects </li> </ul> <p> The SQL type must match the actual type of the output parameter in the stored procedure.
- **Parameters:**
  - (none)
- **Returns:** the SQL type constant from {@link java.sql.Types}
- **See also:** Types

### Annotation OutParameterList (com.landawn.abacus.jdbc.annotation.OutParameterList)
Container annotation for multiple {@link OutParameter} annotations on a single method.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> OutParameter\[\]
- **Signature:** `OutParameter[] value()`
- **Summary:** The array of {@link OutParameter} annotations contained in this list.
- **Contract:**
  - <p> This array is automatically populated when using multiple {@link OutParameter} annotations on a method due to the {@link java.lang.annotation.Repeatable} mechanism.
- **Parameters:**
  - (none)
- **Returns:** array of OutParameter annotations defining the output parameters

### Annotation PerfLog (com.landawn.abacus.jdbc.annotation.PerfLog)
Enables performance logging for SQL operations and DAO methods.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### minExecutionTimeForSql(...) -> long
- **Signature:** `long minExecutionTimeForSql() default JdbcUtil.DEFAULT_MIN_EXECUTION_TIME_FOR_SQL_PERF_LOG`
- **Summary:** Specifies the minimum execution time threshold (in milliseconds) for logging SQL performance.
- **Parameters:**
  - (none)
- **Returns:** the minimum execution time in milliseconds for SQL logging
##### maxSqlLogLength(...) -> int
- **Signature:** `int maxSqlLogLength() default JdbcUtil.DEFAULT_MAX_SQL_LOG_LENGTH`
- **Summary:** Specifies the maximum length of SQL statements in performance logs.
- **Contract:**
  - <p> This is useful for maintaining readable logs when dealing with complex queries or queries with large parameter lists.
- **Parameters:**
  - (none)
- **Returns:** the maximum number of characters to include from SQL statements in logs
##### minExecutionTimeForOperation(...) -> long
- **Signature:** `long minExecutionTimeForOperation() default JdbcUtil.DEFAULT_MIN_EXECUTION_TIME_FOR_DAO_METHOD_PERF_LOG`
- **Summary:** Specifies the minimum execution time threshold (in milliseconds) for logging DAO method performance.
- **Parameters:**
  - (none)
- **Returns:** the minimum execution time in milliseconds for DAO operation logging
##### filter(...) -> String\[\]
- **Signature:** `String[] filter() default { ".*" }`
- **Summary:** Specifies filter patterns for methods when the annotation is applied at the class level.
- **Contract:**
  - Specifies filter patterns for methods when the annotation is applied at the class level.
  - </p> <p> This filter is ignored when the annotation is applied at the method level.
- **Parameters:**
  - (none)
- **Returns:** array of filter patterns (default matches all methods)

### Annotation PrefixFieldMapping (com.landawn.abacus.jdbc.annotation.PrefixFieldMapping)
Maps database column prefixes to object field paths for result set mapping.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `String value() default ""`
- **Summary:** Specifies the mapping between column prefixes and object field paths.
- **Contract:**
  - <p> Format: {@code "prefix1=fieldPath1, prefix2=fieldPath2, ..."} </p> <p> Rules: </p> <ul> <li> Prefixes should match the column aliases used in the SQL query </li> <li> Field paths can be simple field names or nested paths (e.g., "address.city") </li> <li> The prefix must be separated from the column name by a dot (e.g., {@code d.id} ); underscores are not supported </li> <li> The prefix is removed from the column name before mapping to the field </li> <li> Columns without matching prefixes are mapped normally </li> </ul> <p> Example mappings: </p> <pre> {@code // Simple prefix mapping @PrefixFieldMapping("addr=address") // addr.street -> address.street // addr.city -> address.city // Multiple prefix mappings @PrefixFieldMapping("u=user, o=order, p=payment") // u.name -> user.name // o.id -> order.id // p.amount -> payment.amount // Nested field mapping @PrefixFieldMapping("bill=billing.address, ship=shipping.address") // bill.street -> billing.address.street // ship.street -> shipping.address.street } </pre>
- **Parameters:**
  - (none)
- **Returns:** the prefix-to-field mapping string, or empty string if using default mapping

### Annotation Query (com.landawn.abacus.jdbc.annotation.Query)
Defines a generic SQL query operation for a DAO method.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String\[\]
- **Signature:** `String[] value() default {}`
- **Summary:** Specifies inline SQL statement lines to execute.
- **Contract:**
  - <p> The SQL can include: </p> <ul> <li> Named parameters using {@code :paramName} syntax for value binding </li> <li> Template variables using {@code {variableName}} syntax when {@link #fragmentContainsNamedParameters()} is {@code true} </li> <li> Standard SQL features like JOINs, subqueries, CTEs (Common Table Expressions), window functions, etc.
  - </li> <li> Database-specific SQL extensions and functions </li> </ul> <p> Named parameter examples: </p> <pre> {@code // Simple parameter binding @Query("SELECT * FROM users WHERE age > :minAge") List<User> findByAge(@Bind("minAge") int minAge); // Multiple parameters @Query("SELECT * FROM users WHERE age BETWEEN :minAge AND :maxAge") List<User> findByAgeRange(@Bind("minAge") int min, @Bind("maxAge") int max); // Nested property access @Query("SELECT * FROM orders WHERE user_id = :user.id AND status = :status") List<Order> findOrders(@Bind("user") User user, @Bind("status") String status); // IN clause with collection @Query("SELECT * FROM users WHERE id IN (:ids)") List<User> findByIds(@Bind("ids") List<Long> ids); } </pre> <p> Complex SQL examples: </p> <pre> {@code // JOIN with aggregation @Query("SELECT u.*, COUNT(o.id) as order_count " + "FROM users u LEFT JOIN orders o ON u.id = o.user_id " + "WHERE u.created_date > :startDate " + "GROUP BY u.id HAVING COUNT(o.id) > :minOrders") List<UserStats> findUserStats(@Bind("startDate") Date startDate, @Bind("minOrders") int minOrders); // Common Table Expression (CTE) @Query("WITH recent_orders AS ( " + " SELECT user_id, COUNT(*) as order_count " + " FROM orders WHERE order_date > :since " + " GROUP BY user_id " + ") " + "SELECT u.*, ro.order_count " + "FROM users u JOIN recent_orders ro ON u.id = ro.user_id") List<UserOrderSummary> findActiveUserSummary(@Bind("since") Date since); // Window function @Query("SELECT *, ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank " + "FROM employees WHERE department = :dept") List<Employee> rankEmployeesByDepartment(@Bind("dept") String department); } </pre> <p> Note: Either {@code value} or {@link #id()} should be specified, but not both.
  - If neither is specified, the framework may attempt to derive the SQL based on the method name and entity mapping.
- **Parameters:**
  - (none)
- **Returns:** inline SQL statement lines; empty by default when using {@link #id()}
##### id(...) -> String\[\]
- **Signature:** `String[] id() default {}`
- **Summary:** Specifies SQL statement identifier lines defined in an external SQL mapper.
- **Contract:**
  - Each id entry must be a valid Java identifier as per {@link RegExUtil#JAVA_IDENTIFIER_MATCHER} .
  - // </sql> } </pre> <p> Note: Either {@link #value()} or {@code id} should be specified, but not both.
- **Parameters:**
  - (none)
- **Returns:** SQL statement id lines from the SQL mapper; empty by default when using {@link #value()}
- **See also:** RegExUtil#JAVA_IDENTIFIER_MATCHER
##### op(...) -> OP
- **Signature:** `OP op() default OP.DEFAULT`
- **Summary:** Specifies the operation type for this query.
- **Contract:**
  - <p> The operation type influences: </p> <ul> <li> Result set processing strategy </li> <li> Return type handling and conversion </li> <li> Performance optimizations applied by the framework </li> <li> Expected behavior for edge cases (e.g., empty results) </li> </ul> <p> Common operation types: </p> <ul> <li> {@link OP#DEFAULT} - Framework determines operation based on SQL and return type (recommended for most cases) </li> <li> {@link OP#list} - Returns all results as a List </li> <li> {@link OP#stream} - Returns results as a Stream for lazy processing </li> <li> {@link OP#findFirst} - Returns the first result wrapped in Optional </li> <li> {@link OP#findOnlyOne} - Returns exactly one result, throws exception if zero or multiple found </li> <li> {@link OP#exists} - Returns boolean indicating if any results exist </li> <li> {@link OP#queryForSingle} - Returns a single scalar value </li> <li> {@link OP#queryForUnique} - Returns a unique single value or null </li> <li> {@link OP#update} - Executes UPDATE/INSERT/DELETE and returns row count </li> <li> {@link OP#largeUpdate} - For updates affecting potentially > Integer.MAX_VALUE rows </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Existence check @Query(value = "SELECT 1 FROM users WHERE email = :email", op = OP.exists) boolean emailExists(@Bind("email") String email); // Single scalar value @Query(value = "SELECT COUNT(*) FROM users WHERE active = true", op = OP.queryForSingle) long countActiveUsers(); // First result from ordered query @Query(value = "SELECT * FROM users ORDER BY created_date DESC", op = OP.findFirst) Optional<User> findLatestUser(); // Exactly one result (throws if not exactly one) @Query(value = "SELECT * FROM users WHERE id = :id", op = OP.findOnlyOne) User getUserById(@Bind("id") Long id); // Stream for large result sets @Query(value = "SELECT * FROM large_table", op = OP.stream, fetchSize = 1000) Stream<Record> streamAllRecords(); // Explicit update operation @Query(value = "DELETE FROM audit_logs WHERE created_date < :cutoff", op = OP.update) int purgeOldLogs(@Bind("cutoff") Date cutoff); } </pre> <p> When to specify explicitly: </p> <ul> <li> For existence checks: use {@code OP.exists} for performance </li> <li> For scalar aggregates: use {@code OP.queryForSingle} </li> <li> When you need strict validation: use {@code OP.findOnlyOne} </li> <li> For large result sets: use {@code OP.stream} with appropriate fetch size </li> </ul> <p> Note: In most cases, {@link OP#DEFAULT} is sufficient as the framework intelligently determines the appropriate operation based on the SQL statement type and method return type.
- **Parameters:**
  - (none)
- **Returns:** the operation type, defaults to {@link OP#DEFAULT}
- **See also:** OP
##### isProcedure(...) -> boolean
- **Signature:** `boolean isProcedure() default false`
- **Summary:** Indicates whether the SQL statement is a stored procedure call.
- **Contract:**
  - When {@code true} , the framework treats the SQL as a callable statement and handles input/output parameters accordingly.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Stored procedure call with output parameter @Query(value = "{call calculate_bonus(?, ?, ?)}", isProcedure = true) @OutParameter(position = 3, sqlType = Types.DECIMAL) BigDecimal calculateBonus(@Bind("employeeId") long employeeId, @Bind("performanceScore") int score); } </pre> <p> When to use: </p> <ul> <li> Calling stored procedures or functions in the database </li> <li> When the SQL syntax follows the callable statement format (e.g., {@code {call procedure_name(?, ?)}} ) </li> <li> When using output parameters that need to be registered and retrieved </li> </ul>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if the SQL is a stored procedure call; {@code false} (default) otherwise
- **See also:** OutParameter, OutParameterList
##### isBatch(...) -> boolean
- **Signature:** `boolean isBatch() default false`
- **Summary:** Indicates whether this query should be executed as a batch operation.
- **Contract:**
  - Indicates whether this query should be executed as a batch operation.
  - When {@code true} , the method should accept collection-type parameters and execute the query multiple times with different parameter sets in a single batch for better performance.
  - <p> Batch operations significantly improve performance when executing the same SQL statement multiple times with different parameters by: </p> <ul> <li> Reducing network round trips to the database </li> <li> Allowing the database to optimize execution plans </li> <li> Minimizing parsing and compilation overhead </li> <li> Enabling better resource utilization </li> </ul> <p> When to use batch operations: </p> <ul> <li> Inserting multiple records (most common use case) </li> <li> Updating multiple records with different values </li> <li> Deleting multiple records based on different criteria </li> <li> Any scenario where the same SQL runs many times with different parameters </li> </ul> <p> Basic batch insert examples: </p> <pre> {@code // Batch insert with entity list @Query(value = "INSERT INTO users (name, email, status) " + "VALUES (:name, :email, :status)", isBatch = true) int\[\] batchInsertUsers(List<User> users); // Returns array of affected row counts // Batch insert with parallel parameter lists @Query(value = "INSERT INTO products (code, name, price) " + "VALUES (:code, :name, :price)", isBatch = true, batchSize = 500) int\[\] batchInsertProducts(@Bind("code") List<String> codes, @Bind("name") List<String> names, @Bind("price") List<BigDecimal> prices); } </pre> <p> Batch update examples: </p> <pre> {@code // Batch update with entity list @Query(value = "UPDATE users SET status = :status WHERE id = :id", isBatch = true) int\[\] batchUpdateStatus(List<User> users); // Batch update with parallel lists @Query(value = "UPDATE inventory SET quantity = :quantity WHERE product_id = :productId", isBatch = true) int\[\] batchUpdateInventory(@Bind("productId") List<Long> productIds, @Bind("quantity") List<Integer> quantities); } </pre> <p> Batch delete example: </p> <pre> {@code @Query(value = "DELETE FROM temp_records WHERE id = :id", isBatch = true) int\[\] batchDelete(@Bind("id") List<Long> ids); } </pre> <p> Advanced batch examples: </p> <pre> {@code // Large batch with custom batch size @Query(value = "INSERT INTO event_log (timestamp, event_type, data) " + "VALUES (:timestamp, :eventType, :data)", isBatch = true, batchSize = 1000) int\[\] batchLogEvents(List<EventLog> events); // Processes 1000 records per database round trip // Batch with timeout for large operations @Query(value = "INSERT INTO historical_data (date, metric, value) " + "VALUES (:date, :metric, :value)", isBatch = true, batchSize = 5000, queryTimeout = 300) int\[\] importHistoricalData(@Bind("date") List<Date> dates, @Bind("metric") List<String> metrics, @Bind("value") List<Double> values); // Complex batch operation with multiple fields @Query(value = "INSERT INTO orders (user_id, product_id, quantity, price, order_date) " + "VALUES (:userId, :productId, :quantity, :price, :orderDate)", isBatch = true) int\[\] batchCreateOrders(List<Order> orders); } </pre> <p> Return type requirements: </p> <ul> <li> {@code int\[\]} - Array of affected row counts (one per batch item) - most common </li> <li> {@code void} - No return value needed </li> <li> {@code int} - Total affected rows across all batches </li> </ul> <p> Parameter requirements: </p> <ul> <li> At least one parameter must be a {@code Collection} or {@code List} </li> <li> All collection parameters must have the same size </li> <li> Framework iterates through collections in parallel, creating one batch item per index </li> <li> Single (non-collection) parameters are used for all batch items </li> </ul> <p> Parameter combination example: </p> <pre> {@code // Mix of collection and single parameters @Query(value = "INSERT INTO user_actions (user_id, action, category, timestamp) " + "VALUES (:userId, :action, :category, :timestamp)", isBatch = true) int\[\] logUserActions(@Bind("userId") List<Long> userIds, // varies per batch item @Bind("action") List<String> actions, // varies per batch item @Bind("category") String category, // same for all items @Bind("timestamp") Date timestamp); // same for all items } </pre> <p> Performance considerations: </p> <ul> <li> Use {@link #batchSize()} to control how many items are sent per database round trip </li> <li> Larger batch sizes reduce round trips but increase memory usage </li> <li> Optimal batch size depends on network latency, row size, and database configuration </li> <li> Consider database transaction log size and timeout limits </li> <li> Batch operations are typically 10-100× faster than individual operations </li> </ul> <p> Error handling: </p> <ul> <li> If any batch item fails, the entire batch typically fails (depends on database/driver) </li> <li> Some drivers support {@code Statement.EXECUTE_FAILED} in the result array </li> <li> Consider wrapping batch operations in transactions for atomicity </li> <li> Validate data before batching to minimize mid-batch failures </li> </ul> <p> Best practices: </p> <ul> <li> Use batch operations for bulk data loading and imports </li> <li> Set appropriate {@link #batchSize()} based on your data and environment </li> <li> Use {@link #queryTimeout()} for long-running batch operations </li> <li> Monitor memory usage with large batches </li> <li> Consider using transactions to ensure all-or-nothing semantics </li> <li> Validate collection parameters have matching sizes </li> </ul>
- **Parameters:**
  - (none)
- **Returns:** {@code true} for batch operations; {@code false} (default) for single operations
- **See also:** #batchSize()
##### isSingleParameter(...) -> boolean
- **Signature:** `boolean isSingleParameter() default false`
- **Summary:** Indicates whether a single method parameter that is a collection or array should be treated as a single value rather than being expanded for batch operations or IN clauses.
- **Contract:**
  - Indicates whether a single method parameter that is a collection or array should be treated as a single value rather than being expanded for batch operations or IN clauses.
  - <p> Default behavior ( {@code isSingleParameter = false} ): </p> <ul> <li> Collections/arrays in IN clauses are expanded: {@code WHERE id IN (:ids)} with {@code List<Long> ids} </li> <li> For batch operations, collections represent multiple rows to process </li> </ul> <p> When {@code isSingleParameter = true} : </p> <ul> <li> The collection/array is passed as a single value to the database </li> <li> Useful for database-native array types (e.g., PostgreSQL arrays) </li> <li> Useful for JSON array columns </li> <li> Useful for blob/clob data that happens to be an array </li> </ul> <p> Common use cases: </p> <pre> {@code // PostgreSQL array containment operator @Query(value = "SELECT * FROM products WHERE tags @> :tags", isSingleParameter = true) List<Product> findByTags(@Bind("tags") String\[\] tags); // PostgreSQL array equality @Query(value = "SELECT * FROM events WHERE participants = :participants", isSingleParameter = true) List<Event> findByExactParticipants(@Bind("participants") Long\[\] participants); // JSON array column @Query(value = "INSERT INTO configs (name, options) VALUES (:name, :options::jsonb)", isSingleParameter = true) int insertConfig(@Bind("name") String name, @Bind("options") String\[\] options); // Array intersection @Query(value = "SELECT * FROM items WHERE categories && :categories", isSingleParameter = true) List<Item> findByCategoryOverlap(@Bind("categories") String\[\] categories); } </pre> <p> Contrast with default behavior: </p> <pre> {@code // Default: collection is expanded for IN clause @Query(value = "SELECT * FROM users WHERE id IN (:ids)") List<User> findByIds(@Bind("ids") List<Long> ids); // Becomes: SELECT * FROM users WHERE id IN (?, ?, ?, ...) // With isSingleParameter: collection passed as single array value @Query(value = "SELECT * FROM users WHERE id = ANY(:ids)", isSingleParameter = true) List<User> findByIdsArray(@Bind("ids") Long\[\] ids); // PostgreSQL: id = ANY($1) where $1 is an array parameter } </pre> <p> Important notes: </p> <ul> <li> Only applicable when the method has a single collection/array parameter or when specifically needed for one parameter </li> <li> Database must support the native array or collection type being used </li> <li> Not commonly needed for standard SQL; primarily for database-specific features </li> </ul>
- **Parameters:**
  - (none)
- **Returns:** {@code true} if collection/array parameters should be treated as single values; {@code false} (default) for standard expansion behavior
##### fragmentContainsNamedParameters(...) -> boolean
- **Signature:** `@Beta boolean fragmentContainsNamedParameters() default false`
- **Summary:** Indicates whether the SQL statement contains template variables defined by the {@link SqlFragment} or {@link SqlFragmentList} annotations that will be replaced with query fragments containing named parameters.
- **Parameters:**
  - (none)
- **Returns:** {@code true} if template variables defined by {@link SqlFragment} or {@link SqlFragmentList} will be replaced with query fragments containing named parameters; {@code false} otherwise
- **See also:** SqlFragment, SqlFragmentList
##### autoSetSysTimeParam(...) -> boolean
- **Signature:** `@Beta boolean autoSetSysTimeParam() default false`
- **Summary:** Enables automatic timestamp parameter injection for the query.
- **Contract:**
  - When {@code true} , named parameters {@code :sysTime} or {@code :now} are automatically set to the current system timestamp and named parameters {@code :sysDate} are automatically set to the current system date, without requiring it to be passed as a method parameter.
  - </p> <p> Basic examples: </p> <pre> {@code // Finding currently active records @Query(value = "SELECT * FROM promotions " + "WHERE start_date <= :sysTime AND end_date >= :sysDate", autoSetSysTimeParam = true) List<Promotion> findActivePromotions(); // :sysTime and :sysDate are automatically set to current timestamp and date // Audit logging @Query(value = "INSERT INTO audit_log (action, user_id, timestamp) " + "VALUES (:action, :userId, :sysTime)", autoSetSysTimeParam = true) int logAction(@Bind("action") String action, @Bind("userId") Long userId); // Updating with timestamp @Query(value = "UPDATE users SET last_login = :sysTime WHERE id = :id", autoSetSysTimeParam = true) int updateLastLogin(@Bind("id") Long id); } </pre> <p> Advanced examples: </p> <pre> {@code // Complex time-based filtering @Query(value = "SELECT e.* FROM events e " + "WHERE e.start_time <= :sysTime " + " AND e.end_time >= :sysTime " + " AND e.category = :category", autoSetSysTimeParam = true) List<Event> findCurrentEvents(@Bind("category") String category); // Combining with other parameters @Query(value = "SELECT * FROM subscriptions " + "WHERE user_id = :userId " + " AND start_date <= :sysTime " + " AND (end_date IS NULL OR end_date >= :sysTime)", autoSetSysTimeParam = true) List<Subscription> findActiveSubscriptions(@Bind("userId") Long userId); // Data archival based on current time @Query(value = "INSERT INTO archive_logs " + "SELECT *, :sysTime as archived_at FROM logs " + "WHERE created_date < :cutoffDate", autoSetSysTimeParam = true) int archiveOldLogs(@Bind("cutoffDate") Date cutoffDate); // Scheduled task execution tracking @Query(value = "UPDATE scheduled_tasks " + "SET last_run = :sysTime, next_run = :sysTime + INTERVAL :intervalMinutes MINUTE " + "WHERE task_id = :taskId", autoSetSysTimeParam = true) int updateTaskExecution(@Bind("taskId") String taskId, @Bind("intervalMinutes") int interval); } </pre> <p> Multiple timestamp usage: </p> <pre> {@code // Using :sysTime multiple times in the same query @Query(value = "INSERT INTO user_sessions (user_id, created_at, last_activity) " + "VALUES (:userId, :sysTime, :sysTime)", autoSetSysTimeParam = true) int createSession(@Bind("userId") Long userId); // Combining automatic and manual timestamps @Query(value = "SELECT * FROM bookings " + "WHERE booking_date >= :startDate " + " AND booking_date <= :sysDate", autoSetSysTimeParam = true) List<Booking> findBookingsSince(@Bind("startDate") Date startDate); } </pre> <p> Important considerations: </p> <ul> <li> The {@code :sysTime} parameter is set once when the query is executed, ensuring consistency across the query </li> <li> The timestamp is obtained from the application server's system time, not the database server </li> <li> For database server time, use SQL functions like {@code CURRENT_TIMESTAMP} or {@code NOW()} instead </li> <li> The timestamp format and precision depend on the database column type and JDBC driver </li> <li> Cannot manually override the {@code :sysTime} parameter when this is enabled </li> </ul> <p> When not to use this feature: </p> <ul> <li> When you need explicit control over the timestamp value </li> <li> When you need database server time instead of application time </li> <li> When the timestamp should be passed in from external sources </li> <li> When you need different timestamps for different parts of a complex operation </li> </ul>
- **Parameters:**
  - (none)
- **Returns:** {@code true} to automatically inject current timestamp/date as {@code :sysTime/sysDate} parameter; {@code false} (default) for no automatic timestamp injection
##### queryTimeout(...) -> int
- **Signature:** `int queryTimeout() default -1`
- **Summary:** Specifies the query timeout in seconds.
- **Contract:**
  - If the query execution exceeds this timeout, it will be cancelled and a timeout exception will be thrown.
  - <p> Setting an appropriate timeout is important for: </p> <ul> <li> Preventing resource exhaustion from long-running queries </li> <li> Meeting Service Level Agreement (SLA) requirements </li> <li> Detecting and failing fast on inefficient queries </li> <li> Protecting the application from database performance issues </li> <li> Preventing connection pool starvation </li> </ul> <p> Timeout guidelines (in seconds): </p> <ul> <li> {@code -1} (default) - Uses the default timeout configured in the connection or DataSource </li> <li> {@code 0} - No timeout (wait indefinitely - not recommended) </li> <li> {@code 1-5} - For simple, well-indexed queries that should be very fast </li> <li> {@code 10-30} - For complex queries with joins or aggregations </li> <li> {@code 60+} - For batch operations, data migrations, or reporting queries </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Quick lookup that should complete fast @Query(value = "SELECT * FROM users WHERE id = :id", queryTimeout = 2) User getUserById(@Bind("id") Long id); // Complex reporting query @Query(value = "SELECT ...
- **Parameters:**
  - (none)
- **Returns:** the timeout in seconds, or {@code -1} to use the default configured timeout
##### fetchSize(...) -> int
- **Signature:** `int fetchSize() default -1`
- **Summary:** Specifies the JDBC fetch size for the query.
- **Contract:**
  - <p> The fetch size is a hint to the JDBC driver about the number of rows that should be fetched from the database when more rows are needed.
  - Higher values significantly improve performance for large result sets </li> <li> <strong> SQL Server: </strong> Adaptive fetch size based on packet size </li> </ul> <p> Important notes: </p> <ul> <li> Fetch size is a hint; drivers may ignore or adjust it </li> <li> Very large fetch sizes can cause OutOfMemoryError if rows are large </li> <li> Optimal fetch size depends on network latency, row size, and available memory </li> <li> For {@code Stream} return types, fetch size enables {@code true} lazy loading </li> <li> Profile and test with realistic data to find optimal values </li> <li> Consider using different fetch sizes for different environments (dev vs.
- **Parameters:**
  - (none)
- **Returns:** the fetch size hint for the JDBC driver, or {@code -1} to use the driver's default
##### batchSize(...) -> int
- **Signature:** `int batchSize() default JdbcUtil.DEFAULT_BATCH_SIZE`
- **Summary:** Specifies the number of items to process in each database round trip for batch operations.
- **Contract:**
  - Only applicable when {@link #isBatch()} is {@code true} .
  - batchSize = 100 - Total database round trips: 10,000 / 100 = 100 trips - Each trip processes 100 INSERT statements - Memory per trip: ~100 × row size - More round trips but less memory per trip </pre> <p> Factors to consider when choosing batch size: </p> <ul> <li> <strong> Row size: </strong> Larger rows require smaller batch sizes to avoid memory issues </li> <li> <strong> Network latency: </strong> High latency benefits from larger batches </li> <li> <strong> Database limits: </strong> Some databases have maximum transaction sizes or statement counts </li> <li> <strong> Available memory: </strong> Limited memory requires smaller batches </li> <li> <strong> Concurrent operations: </strong> Consider memory usage across all concurrent operations </li> <li> <strong> Error handling: </strong> Smaller batches may be easier to retry on partial failures </li> </ul> <p> Database-specific considerations: </p> <ul> <li> <strong> PostgreSQL: </strong> Can handle very large batches efficiently; consider 1000-5000 </li> <li> <strong> MySQL: </strong> May have max_allowed_packet limit; typically 500-2000 </li> <li> <strong> Oracle: </strong> Efficient with batches of 100-1000 </li> <li> <strong> SQL Server: </strong> Generally efficient with 500-1000 </li> </ul> <p> Memory usage estimation: </p> <pre> Approximate memory per batch = batchSize × averageRowSize × 2 (×2 accounts for driver buffering and object overhead) Example calculations: - Small rows (100 bytes) =5000 \\u2192 ~1MB per batch - Medium rows (1KB) =1000 \\u2192 ~2MB per batch - Large rows (10KB) =100 \\u2192 ~2MB per batch - Very large rows (100KB) =10 \\u2192 ~2MB per batch </pre> <p> Best practices: </p> <ul> <li> Start with the default and measure performance </li> <li> Profile with realistic data volumes and row sizes </li> <li> Monitor memory usage under load </li> <li> Consider different values for different environments (dev vs.
  - prod) </li> <li> Document the rationale for non-default batch sizes </li> <li> Test with edge cases (very small and very large datasets) </li> </ul> <p> Common anti-patterns to avoid: </p> <ul> <li> Using batch size of 1 (defeats the purpose of batching) </li> <li> Using extremely large batch sizes without memory testing </li> <li> Ignoring database-specific limitations </li> <li> Not adjusting batch size when row size changes significantly </li> </ul>
- **Parameters:**
  - (none)
- **Returns:** the number of items to process per batch, defaults to {@link JdbcUtil#DEFAULT_BATCH_SIZE}
- **See also:** #isBatch(), JdbcUtil#DEFAULT_BATCH_SIZE

### Annotation RefreshCache (com.landawn.abacus.jdbc.annotation.RefreshCache)
Controls cache refresh behavior for DAO methods that modify data.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### disabled(...) -> boolean
- **Signature:** `boolean disabled() default false`
- **Summary:** Specifies whether cache refresh is disabled for the annotated element.
- **Parameters:**
  - (none)
- **Returns:** {@code true} to disable cache refresh, {@code false} to enable it (default)
##### filter(...) -> String\[\]
- **Signature:** `String[] filter() default { "update", "delete", "deleteById", "insert", "save", "add", "remove", "upsert", "batchUpdate", "batchDelete", "batchDeleteByIds", "batchInsert", "batchSave", "batchAdd", "batchRemove", "batchUpsert", "execute" }`
- **Summary:** Specifies filter patterns for methods when the annotation is applied at the class level.
- **Contract:**
  - Specifies filter patterns for methods when the annotation is applied at the class level.
  - </p> <p> This filter is ignored when the annotation is applied at the method level.
- **Parameters:**
  - (none)
- **Returns:** array of filter patterns for method names that should trigger cache refresh

### Annotation SqlFragment (com.landawn.abacus.jdbc.annotation.SqlFragment)
Defines a query template variable for dynamic query construction.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `String value() default ""`
- **Summary:** Specifies the name of the query template variable to be replaced.
- **Contract:**
  - If not specified (empty string), the parameter name will be used.
  - <p> The value can be: </p> <ul> <li> A simple placeholder name (e.g., "tableName") </li> <li> A custom placeholder with default value syntax (e.g., "{where -> WHERE active = true}") </li> </ul> <p> Simple placeholder example: </p> <pre> {@code @Query("SELECT * FROM {schema}.{table} WHERE id = :id") User findById( @SqlFragment("schema") String schemaName, @SqlFragment("table") String tableName, @Bind("id") long id ); } </pre> <p> Custom placeholder with default: </p> <pre> {@code // Custom syntax allows for more complex replacements @Query("SELECT * FROM users {filter -> WHERE active = true}") List<User> findUsers(@SqlFragment("{filter -> WHERE active = true}") String customFilter); // Usage: findUsers("WHERE role = 'ADMIN'"); // Replaces the entire {filter -> ...} block findUsers(null); // Uses the default "WHERE active = true" } </pre> <p> Using parameter name when value is empty: </p> <pre> {@code @Query("SELECT {columns} FROM users") List<Map<String, Object>> findWithColumns(@SqlFragment String columns); // The parameter name "columns" is used as the placeholder name } </pre>
- **Parameters:**
  - (none)
- **Returns:** the query template variable name, or empty string if using the parameter name

### Annotation SqlFragmentList (com.landawn.abacus.jdbc.annotation.SqlFragmentList)
Defines a named query template variable from a collection or array parameter.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `String value() default ""`
- **Summary:** Specifies the name of the query template variable to be replaced.
- **Contract:**
  - If not specified (empty string), the parameter name will be used.
  - <p> The variable should be referenced in the query template using curly braces: {@code {variableName}} </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Explicit name @Query("SELECT {cols} FROM users") List<User> findWithColumns(@SqlFragmentList("cols") List<String> columnList); // Using parameter name (when value is not specified) @Query("SELECT {columns} FROM users") List<User> findWithColumns(@SqlFragmentList List<String> columns); } </pre>
- **Parameters:**
  - (none)
- **Returns:** the name of the query template variable, or empty string if using the parameter name

### Annotation SqlLogEnabled (com.landawn.abacus.jdbc.annotation.SqlLogEnabled)
Controls SQL statement logging for DAO methods or classes.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> boolean
- **Signature:** `boolean value() default true`
- **Summary:** Specifies whether SQL logging is enabled or disabled.
- **Contract:**
  - <p> When set to {@code true} (default), SQL statements will be logged.
  - When set to {@code false} , SQL logging is disabled regardless of other settings.
- **Parameters:**
  - (none)
- **Returns:** {@code true} to enable SQL logging, {@code false} to disable it
##### maxSqlLogLength(...) -> int
- **Signature:** `int maxSqlLogLength() default JdbcUtil.DEFAULT_MAX_SQL_LOG_LENGTH`
- **Summary:** Specifies the maximum length of SQL statements in logs.
- **Contract:**
  - <p> This is particularly useful when dealing with: </p> <ul> <li> Large INSERT statements with many values </li> <li> Complex queries with multiple joins </li> <li> Queries with large IN clauses </li> <li> Statements with embedded large text or binary data </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code @SqlLogEnabled(maxSqlLogLength = 500) void insertBatchData(List<Data> largeDataset); @SqlLogEnabled(maxSqlLogLength = 2048) // Allow longer logs for complex queries List<Report> generateComplexReport(); } </pre>
- **Parameters:**
  - (none)
- **Returns:** the maximum number of characters to include from SQL statements in logs
##### filter(...) -> String\[\]
- **Signature:** `String[] filter() default { ".*" }`
- **Summary:** Specifies filter patterns for methods when the annotation is applied at the class level.
- **Contract:**
  - Specifies filter patterns for methods when the annotation is applied at the class level.
  - </p> <p> This filter is ignored when the annotation is applied at the method level.
- **Parameters:**
  - (none)
- **Returns:** array of filter patterns (default matches all methods)

### Annotation SqlMapper (com.landawn.abacus.jdbc.annotation.SqlMapper)
Associates a DAO interface with an external SQL mapper XML file.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### value(...) -> String
- **Signature:** `String value() default ""`
- **Summary:** Specifies the path to the SQL mapper XML file.
- **Contract:**
  - The path is relative to the classpath root and should include the file extension.
  - <p> If not specified (empty string), the default mapper file location will be used.
- **Parameters:**
  - (none)
- **Returns:** the classpath-relative path to the SQL mapper XML file.

### Annotation SqlScript (com.landawn.abacus.jdbc.annotation.SqlScript)
Marks a {@code static final String} field (typically inside a DAO interface's nested helper class) as an embeddable SQL script that can be referenced by {@code @Query(id = "...")} .

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### id(...) -> String
- **Signature:** `String id() default ""`
- **Summary:** Supplies an optional identifier that overrides the annotated field name when the SQL is registered.
- **Contract:**
  - Supplies an optional identifier that overrides the annotated field name when the SQL is registered.
  - When left empty, the declaration name (for example {@code sql_listUserWithBiggerId} ) becomes the key.
- **Parameters:**
  - (none)
- **Returns:** the identifier used by {@link Query#id()} ; empty means the annotated field name is used

### Annotation Transactional (com.landawn.abacus.jdbc.annotation.Transactional)
Declares transaction boundaries for DAO methods.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### propagation(...) -> Propagation
- **Signature:** `Propagation propagation() default Propagation.REQUIRED`
- **Summary:** Specifies the transaction propagation behavior.
- **Contract:**
  - <p> Common propagation behaviors: </p> <ul> <li> {@link Propagation#REQUIRED} (default) - Join existing transaction or create new one </li> <li> {@link Propagation#REQUIRES_NEW} - Always create a new transaction </li> <li> {@link Propagation#SUPPORTS} - Use transaction if exists, otherwise non-transactional </li> <li> {@link Propagation#MANDATORY} - Must execute within existing transaction </li> <li> {@link Propagation#NOT_SUPPORTED} - Execute non-transactionally, suspend existing </li> <li> {@link Propagation#NEVER} - Execute non-transactionally, fail if transaction exists </li> </ul> <p> Example scenarios: </p> <pre> {@code // Main business operation - needs transaction @Transactional(propagation = Propagation.REQUIRED) void processOrder(Order order) { ...
- **Parameters:**
  - (none)
- **Returns:** the propagation behavior for this transaction
- **See also:** Propagation
##### isolation(...) -> IsolationLevel
- **Signature:** `IsolationLevel isolation() default IsolationLevel.DEFAULT`
- **Summary:** Specifies the transaction isolation level.
- **Parameters:**
  - (none)
- **Returns:** the isolation level for this transaction
- **See also:** IsolationLevel

## com.landawn.abacus.jdbc.dao
### Interface CrudDao (com.landawn.abacus.jdbc.dao.CrudDao)
The CrudDao interface provides comprehensive CRUD (Create, Read, Update, Delete) operations for entity management.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### idExtractor(...) -> Jdbc.BiRowMapper<ID>
- **Signature:** `@SuppressWarnings("SameReturnValue") @NonDBOperation default Jdbc.BiRowMapper<ID> idExtractor()`
- **Summary:** Returns the functional interface of {@code Jdbc.BiRowMapper} that extracts the ID from a database row.
- **Contract:**
  - <p> Override this method to provide a custom ID extractor if the default behavior doesn't suit your needs.
- **Parameters:**
  - (none)
- **Returns:** a BiRowMapper that extracts the ID from a row, or {@code null} to use default extraction
##### generateId(...) -> ID
- **Signature:** `@Deprecated @NonDBOperation default ID generateId() throws SQLException, UnsupportedOperationException`
- **Summary:** Generates a new ID for entity insertion.
- **Contract:**
  - <p> This method should be overridden by implementations that support ID generation.
- **Parameters:**
  - (none)
- **Returns:** the generated ID
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the operation is not supported (default behavior)
##### insert(...) -> ID
- **Signature:** `ID insert(final T entityToInsert) throws SQLException`
- **Summary:** Inserts the specified entity into the database and returns the generated ID.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (must not be null)
- **Returns:** the ID of the inserted entity (either database-generated or entity-provided)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs or the entity is null
- **Signature:** `ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws SQLException`
- **Summary:** Inserts the specified entity with only the specified properties.
- **Contract:**
  - This is useful when you want to insert an entity with only certain fields populated.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (must not be null)
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement. If {@code null} or empty, all properties will be inserted
- **Returns:** the ID of the inserted entity (either database-generated or entity-provided)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `ID insert(final String namedInsertSql, final T entityToInsert) throws SQLException`
- **Summary:** Inserts an entity using a custom named SQL insert statement.
- **Contract:**
  - The SQL should use named parameters that match the entity's property names.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement
  - `entityToInsert` (`T`) — the entity whose properties will be bound to the named parameters
- **Returns:** the ID of the inserted entity (either database-generated or entity-provided)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### batchInsert(...) -> List<ID>
- **Signature:** `default List<ID> batchInsert(final Collection<? extends T> entities) throws SQLException`
- **Summary:** Performs batch insert of multiple entities using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws SQLException`
- **Summary:** Performs batch insert of multiple entities with a specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws SQLException`
- **Summary:** Performs batch insert with only specified properties for all entities.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws SQLException`
- **Summary:** Performs batch insert with only specified properties and custom batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws SQLException`
- **Summary:** Performs batch insert using a custom named SQL statement with default batch size.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement
  - `entities` (`Collection<? extends T>`) — the collection of entities whose properties will be bound to the named parameters
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws SQLException`
- **Summary:** Performs batch insert using a custom named SQL statement with specified batch size.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement
  - `entities` (`Collection<? extends T>`) — the collection of entities whose properties will be bound to the named parameters
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForBoolean(...) -> OptionalBoolean
- **Signature:** `OptionalBoolean queryForBoolean(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a boolean value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalBoolean if no record is found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean("isActive", userId); if (isActive.isPresent() && isActive.getAsBoolean()) { System.out.println("User is active"); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalBoolean containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForBoolean()
##### queryForChar(...) -> OptionalChar
- **Signature:** `OptionalChar queryForChar(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a char value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalChar if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalChar containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForChar()
##### queryForByte(...) -> OptionalByte
- **Signature:** `OptionalByte queryForByte(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a byte value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalByte if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalByte containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForByte()
##### queryForShort(...) -> OptionalShort
- **Signature:** `OptionalShort queryForShort(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a short value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalShort if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalShort containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForShort()
##### queryForInt(...) -> OptionalInt
- **Signature:** `OptionalInt queryForInt(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for an integer value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalInt if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalInt containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForInt()
##### queryForLong(...) -> OptionalLong
- **Signature:** `OptionalLong queryForLong(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a long value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalLong if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalLong containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForLong()
##### queryForFloat(...) -> OptionalFloat
- **Signature:** `OptionalFloat queryForFloat(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a float value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalFloat if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalFloat containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForFloat()
##### queryForDouble(...) -> OptionalDouble
- **Signature:** `OptionalDouble queryForDouble(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a double value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalDouble if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalDouble containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForDouble()
##### queryForString(...) -> Nullable<String>
- **Signature:** `Nullable<String> queryForString(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a String value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the String value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForString()
##### queryForDate(...) -> Nullable<java.sql.Date>
- **Signature:** `Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a Date value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the Date value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForDate()
##### queryForTime(...) -> Nullable<java.sql.Time>
- **Signature:** `Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a Time value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the Time value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForTime()
##### queryForTimestamp(...) -> Nullable<java.sql.Timestamp>
- **Signature:** `Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a Timestamp value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the Timestamp value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForTimestamp()
##### queryForBytes(...) -> Nullable<byte\[\]>
- **Signature:** `Nullable<byte[]> queryForBytes(final String singleSelectPropName, final ID id) throws SQLException`
- **Summary:** Queries for a byte array value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the byte array value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForBytes()
##### queryForSingleResult(...) -> Nullable<V>
- **Signature:** `<V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws SQLException`
- **Summary:** Queries for a single value of the specified type from a property of the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** a Nullable containing the value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForSingleResult(Class)
##### queryForSingleNonNull(...) -> Optional<V>
- **Signature:** `<V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws SQLException`
- **Summary:** Queries for a single non-null value of the specified type from a property of the entity.
- **Contract:**
  - Returns an empty Optional if no record is found or if the value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** an Optional containing the non-null value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForSingleNonNull(Class)
- **Signature:** `@Beta <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws SQLException`
- **Summary:** Queries for a single non-null value using a custom row mapper.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the custom mapper to transform the result
- **Returns:** an Optional containing the mapped non-null value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForSingleNonNull(Class)
##### queryForUniqueResult(...) -> Nullable<V>
- **Signature:** `<V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique single result of the specified type.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForUniqueResult("email", userId, String.class); // Throws DuplicatedResultException if multiple records found } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** a Nullable containing the unique value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForUniqueResult(Class)
##### queryForUniqueNonNull(...) -> Optional<V>
- **Signature:** `<V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique non-null result of the specified type.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
  - Returns empty Optional if no record found or value is {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Optional<String> email = userDao.queryForUniqueNonNull("email", userId, String.class); email.ifPresent(e -> sendEmail(e)); // Throws DuplicatedResultException if multiple records found } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** an Optional containing the unique non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForUniqueNonNull(Class)
- **Signature:** `@Beta <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique non-null result using a custom row mapper.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the custom mapper to transform the result
- **Returns:** an Optional containing the mapped unique non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters, AbstractQuery#queryForUniqueNonNull(Class)
##### get(...) -> Optional<T>
- **Signature:** `default Optional<T> get(final ID id) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID.
- **Contract:**
  - Returns an Optional containing the entity if found, otherwise empty.
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
- **Returns:** an Optional containing the entity if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default Optional<T> get(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties populated.
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select, excluding properties of joining entities. All properties will be selected if null
- **Returns:** an Optional containing the entity if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
##### gett(...) -> T
- **Signature:** `T gett(final ID id) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); if (user != null) { System.out.println("Found user: " + user.getName()); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
- **Returns:** the entity if found, otherwise null
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `T gett(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.
  - This is useful for performance optimization when you only need specific fields.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Only load id, name, and email fields User user = userDao.gett(userId, Arrays.asList("id", "name", "email")); if (user != null) { System.out.println("User name: " + user.getName()); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select, excluding properties of joining entities. All properties will be selected if null
- **Returns:** the entity if found, otherwise null
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
##### batchGet(...) -> List<T>
- **Signature:** `default List<T> batchGet(final Collection<? extends ID> ids) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs using the default batch size.
- **Contract:**
  - The returned list may be smaller than the input ID collection if some entities are not found.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
- **Returns:** a list of found entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default List<T> batchGet(final Collection<? extends ID> ids, final int batchSize) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with a specified batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of found entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with only selected properties populated.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select, excluding properties of joining entities. All properties will be selected if null
- **Returns:** a list of found entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final int batchSize) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with only selected properties populated and custom batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select, excluding properties of joining entities. All properties will be selected if null
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of found entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
##### exists(...) -> boolean
- **Signature:** `boolean exists(final ID id) throws SQLException`
- **Summary:** Checks if an entity with the specified ID exists in the database.
- **Contract:**
  - Checks if an entity with the specified ID exists in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(userId)) { System.out.println("User exists"); } else { System.out.println("User not found"); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to check for existence
- **Returns:** {@code true} if an entity with the given ID exists, {@code false} otherwise
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#exists()
##### notExists(...) -> boolean
- **Signature:** `@Beta default boolean notExists(final ID id) throws SQLException`
- **Summary:** Checks if an entity with the specified ID does not exist in the database.
- **Contract:**
  - Checks if an entity with the specified ID does not exist in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(userId)) { // Create new user } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to check for non-existence
- **Returns:** {@code true} if no entity with the given ID exists, {@code false} otherwise
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#notExists()
##### count(...) -> int
- **Signature:** `@Beta int count(final Collection<? extends ID> ids) throws SQLException`
- **Summary:** Counts how many of the specified IDs exist in the database.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to count
- **Returns:** the number of existing entities with the given IDs
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### update(...) -> int
- **Signature:** `int update(final T entityToUpdate) throws SQLException`
- **Summary:** Updates an existing entity in the database.
- **Parameters:**
  - `entityToUpdate` (`T`) — the entity with updated values
- **Returns:** the number of rows updated (typically 1 if successful, 0 if not found)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws SQLException`
- **Summary:** Updates only specified properties of an existing entity.
- **Contract:**
  - This is useful when you want to update only certain fields.
- **Parameters:**
  - `entityToUpdate` (`T`) — the entity containing the values to update
  - `propNamesToUpdate` (`Collection<String>`) — the property names to update. If {@code null} or empty, all properties will be updated
- **Returns:** the number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int update(final String propName, final Object propValue, final ID id) throws SQLException`
- **Summary:** Updates a single property of an entity identified by ID.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `id` (`ID`) — the entity ID to update
- **Returns:** the number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int update(final Map<String, Object> updateProps, final ID id) throws SQLException`
- **Summary:** Updates multiple properties of an entity identified by ID.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `id` (`ID`) — the entity ID to update
- **Returns:** the number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### batchUpdate(...) -> int
- **Signature:** `default int batchUpdate(final Collection<? extends T> entities) throws SQLException`
- **Summary:** Performs batch update of multiple entities using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
- **Returns:** the total number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws SQLException`
- **Summary:** Performs batch update of multiple entities with a specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** the total number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws SQLException`
- **Summary:** Performs batch update of multiple entities updating only specified properties.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `propNamesToUpdate` (`Collection<String>`) — the property names to update for all entities
- **Returns:** the total number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws SQLException`
- **Summary:** Performs batch update of multiple entities updating only specified properties with custom batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `propNamesToUpdate` (`Collection<String>`) — the property names to update for all entities
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** the total number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### upsert(...) -> T
- **Signature:** `default T upsert(final T entity) throws SQLException`
- **Summary:** Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.
- **Contract:**
  - Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.
  - If an entity with the same ID exists, it will be updated; otherwise, a new entity will be inserted.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User(); user.setId(userId); user.setName("John Doe"); user.setEmail("john@example.com"); User savedUser = userDao.upsert(user); // Insert if new, update if exists } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
- **Returns:** the saved entity (either newly inserted or updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Override default T upsert(final T entity, final Condition cond) throws SQLException`
- **Summary:** Performs an upsert operation: inserts the entity if it doesn't exist based on the specified condition, otherwise updates the existing entity.
- **Contract:**
  - Performs an upsert operation: inserts the entity if it doesn't exist based on the specified condition, otherwise updates the existing entity.
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
  - `cond` (`Condition`) — the condition to check if the entity exists
- **Returns:** the saved entity (either newly inserted or updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters
##### batchUpsert(...) -> List<T>
- **Signature:** `default List<T> batchUpsert(final Collection<? extends T> entities) throws SQLException`
- **Summary:** Performs batch upsert of multiple entities using the default batch size.
- **Contract:**
  - Each entity will be inserted if new or updated if it already exists based on ID fields.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
- **Returns:** a list of saved entities (both inserted and updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws SQLException`
- **Summary:** Performs batch upsert of multiple entities with a specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of saved entities (both inserted and updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws SQLException`
- **Summary:** Performs batch upsert based on specified unique properties for matching.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify each entity
- **Returns:** a list of saved entities (both inserted and updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws SQLException`
- **Summary:** Performs batch upsert based on specified unique properties with custom batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify each entity
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of saved entities (both inserted and updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### refresh(...) -> boolean
- **Signature:** `default boolean refresh(final T entity) throws SQLException`
- **Summary:** Refreshes an entity by reloading all its properties from the database.
- **Contract:**
  - This is useful when you want to ensure an entity has the latest values from the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); if (userDao.refresh(user)) { System.out.println("User refreshed with latest data"); } else { System.out.println("User no longer exists in database"); } } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to refresh (must have ID populated)
- **Returns:** {@code true} if the entity was successfully refreshed, {@code false} if not found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") default boolean refresh(final T entity, final Collection<String> propNamesToRefresh) throws SQLException`
- **Summary:** Refreshes specific properties of an entity from the database.
- **Parameters:**
  - `entity` (`T`) — the entity to refresh (must have ID populated)
  - `propNamesToRefresh` (`Collection<String>`) — the properties to refresh from the database
- **Returns:** {@code true} if the entity was successfully refreshed, {@code false} if not found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### batchRefresh(...) -> int
- **Signature:** `default int batchRefresh(final Collection<? extends T> entities) throws SQLException`
- **Summary:** Refreshes multiple entities from the database using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
- **Returns:** the number of entities successfully refreshed
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int batchRefresh(final Collection<? extends T> entities, final int batchSize) throws SQLException`
- **Summary:** Refreshes multiple entities from the database with a specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** the number of entities successfully refreshed
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh) throws SQLException`
- **Summary:** Refreshes specific properties of multiple entities using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
  - `propNamesToRefresh` (`Collection<String>`) — the properties to refresh from the database
- **Returns:** the number of entities successfully refreshed
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh, final int batchSize) throws SQLException`
- **Summary:** Refreshes specific properties of multiple entities with a custom batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
  - `propNamesToRefresh` (`Collection<String>`) — the properties to refresh from the database
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** the number of entities successfully refreshed
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### delete(...) -> int
- **Signature:** `int delete(final T entity) throws SQLException`
- **Summary:** Deletes an entity from the database.
- **Contract:**
  - The entity must have its ID field(s) populated.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); int deletedRows = userDao.delete(user); if (deletedRows > 0) { System.out.println("User deleted successfully"); } } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to delete (must have ID populated)
- **Returns:** the number of rows deleted (typically 1 if successful, 0 if not found)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### deleteById(...) -> int
- **Signature:** `int deleteById(final ID id) throws SQLException`
- **Summary:** Deletes an entity by its ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code int deletedRows = userDao.deleteById(userId); if (deletedRows == 0) { System.out.println("User not found"); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to delete
- **Returns:** the number of rows deleted (typically 1 if successful, 0 if not found)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### batchDelete(...) -> int
- **Signature:** `default int batchDelete(final Collection<? extends T> entities) throws SQLException`
- **Summary:** Performs batch delete of multiple entities using the default batch size.
- **Contract:**
  - Each entity must have its ID field(s) populated.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to delete
- **Returns:** the total number of rows deleted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int batchDelete(final Collection<? extends T> entities, final int batchSize) throws SQLException`
- **Summary:** Performs batch delete of multiple entities with a specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to delete
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** the total number of rows deleted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### batchDeleteByIds(...) -> int
- **Signature:** `default int batchDeleteByIds(final Collection<? extends ID> ids) throws SQLException`
- **Summary:** Deletes multiple entities by their IDs using the default batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to delete
- **Returns:** the total number of rows deleted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws SQLException`
- **Summary:** Deletes multiple entities by their IDs with a specified batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to delete
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** the total number of rows deleted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs

### Interface CrudDaoL (com.landawn.abacus.jdbc.dao.CrudDaoL)
A specialized CrudDao interface that uses {@code Long} as the ID type.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### queryForBoolean(...) -> OptionalBoolean
- **Signature:** `default OptionalBoolean queryForBoolean(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a boolean value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalBoolean if no record is found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean("isActive", 123L); if (isActive.isPresent() && isActive.getAsBoolean()) { System.out.println("User is active"); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalBoolean containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForChar(...) -> OptionalChar
- **Signature:** `default OptionalChar queryForChar(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a char value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalChar if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalChar containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForByte(...) -> OptionalByte
- **Signature:** `default OptionalByte queryForByte(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a byte value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalByte if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalByte containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForShort(...) -> OptionalShort
- **Signature:** `default OptionalShort queryForShort(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a short value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalShort if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalShort containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForInt(...) -> OptionalInt
- **Signature:** `default OptionalInt queryForInt(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for an integer value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalInt if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalInt containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForLong(...) -> OptionalLong
- **Signature:** `default OptionalLong queryForLong(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a long value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalLong if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalLong containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForFloat(...) -> OptionalFloat
- **Signature:** `default OptionalFloat queryForFloat(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a float value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalFloat if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalFloat containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForDouble(...) -> OptionalDouble
- **Signature:** `default OptionalDouble queryForDouble(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a double value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalDouble if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalDouble containing the value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForString(...) -> Nullable<String>
- **Signature:** `default Nullable<String> queryForString(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a String value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the String value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForDate(...) -> Nullable<java.sql.Date>
- **Signature:** `default Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a Date value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the Date value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForTime(...) -> Nullable<java.sql.Time>
- **Signature:** `default Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a Time value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the Time value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForTimestamp(...) -> Nullable<java.sql.Timestamp>
- **Signature:** `default Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a Timestamp value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the Timestamp value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForBytes(...) -> Nullable<byte\[\]>
- **Signature:** `default Nullable<byte[]> queryForBytes(final String singleSelectPropName, final long id) throws SQLException`
- **Summary:** Queries for a byte array value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the byte array value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForSingleResult(...) -> Nullable<V>
- **Signature:** `default <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws SQLException`
- **Summary:** Queries for a single value of the specified type from a property of the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** a Nullable containing the value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForSingleNonNull(...) -> Optional<V>
- **Signature:** `default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws SQLException`
- **Summary:** Queries for a single non-null value of the specified type from a property of the entity.
- **Contract:**
  - Returns an empty Optional if no record is found or if the value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** an Optional containing the non-null value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws SQLException`
- **Summary:** Queries for a single non-null value using a custom row mapper.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the custom mapper to transform the result
- **Returns:** an Optional containing the mapped non-null value if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForUniqueResult(...) -> Nullable<V>
- **Signature:** `default <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique single result of the specified type.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForUniqueResult("email", 123L, String.class); // Throws DuplicatedResultException if multiple records found } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** a Nullable containing the unique value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
##### queryForUniqueNonNull(...) -> Optional<V>
- **Signature:** `default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique non-null result of the specified type.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
  - Returns empty Optional if no record found or value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** an Optional containing the unique non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique non-null result using a custom row mapper.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the custom mapper to transform the result
- **Returns:** an Optional containing the mapped unique non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
##### get(...) -> Optional<T>
- **Signature:** `default Optional<T> get(final long id) throws SQLException`
- **Summary:** Retrieves an entity by its ID.
- **Contract:**
  - Returns an Optional containing the entity if found, otherwise empty.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
- **Returns:** an Optional containing the entity if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default Optional<T> get(final long id, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties populated.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select, excluding properties of joining entities. All properties will be selected if null
- **Returns:** an Optional containing the entity if found, otherwise empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### gett(...) -> T
- **Signature:** `default T gett(final long id) throws SQLException`
- **Summary:** Retrieves an entity by its ID, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L); if (user != null) { System.out.println("Found user: " + user.getName()); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
- **Returns:** the entity if found, otherwise null
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default T gett(final long id, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.
  - This is useful for performance optimization when you only need specific fields.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Only load id, name, email fields User user = userDao.gett(123L, Arrays.asList("id", "name", "email")); if (user != null) { System.out.println("User name: " + user.getName()); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select, excluding properties of joining entities. All properties will be selected if null
- **Returns:** the entity if found, otherwise null
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### exists(...) -> boolean
- **Signature:** `default boolean exists(final long id) throws SQLException`
- **Summary:** Checks if an entity with the specified ID exists in the database.
- **Contract:**
  - Checks if an entity with the specified ID exists in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(123L)) { System.out.println("User exists"); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID to check for existence
- **Returns:** {@code true} if an entity with the given ID exists, {@code false} otherwise
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### notExists(...) -> boolean
- **Signature:** `@Beta default boolean notExists(final long id) throws SQLException`
- **Summary:** Checks if an entity with the specified ID does not exist in the database.
- **Contract:**
  - Checks if an entity with the specified ID does not exist in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(123L)) { // Create new user with this ID } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID to check for non-existence
- **Returns:** {@code true} if no entity with the given ID exists, {@code false} otherwise
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### update(...) -> int
- **Signature:** `default int update(final String propName, final Object propValue, final long id) throws SQLException`
- **Summary:** Updates a single property of an entity identified by ID.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `id` (`long`) — the primitive long ID of the entity to update
- **Returns:** the number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int update(final Map<String, Object> updateProps, final long id) throws SQLException`
- **Summary:** Updates multiple properties of an entity identified by ID.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `id` (`long`) — the primitive long ID of the entity to update
- **Returns:** the number of rows updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### deleteById(...) -> int
- **Signature:** `default int deleteById(final long id) throws SQLException`
- **Summary:** Deletes an entity by its ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code int deletedRows = userDao.deleteById(123L); if (deletedRows == 0) { System.out.println("User not found"); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to delete
- **Returns:** the number of rows deleted (typically 1 if successful, 0 if not found)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs

### Interface CrudJoinEntityHelper (com.landawn.abacus.jdbc.dao.CrudJoinEntityHelper)
Interface for CRUD operations with automatic join entity loading support.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### get(...) -> Optional<T>
- **Signature:** `@Beta default Optional<T> get(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and loads the specified type of join entities.
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and optionally loads all join entities.
- **Contract:**
  - When includeAllJoinEntities is {@code true} , all fields annotated with @JoinedBy will be loaded.
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** an Optional containing the entity with join entities loaded as specified, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties and loads the specified join entities.
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of join entities to load
- **Returns:** an Optional containing the entity with selected properties and join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties and loads multiple types of join entities.
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
- **Returns:** an Optional containing the entity with selected properties and specified join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties and optionally loads all join entities.
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** an Optional containing the entity with selected properties and join entities as specified, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
##### gett(...) -> T
- **Signature:** `@Beta default T gett(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and loads the specified type of join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID and loads the specified type of join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId, Order.class); if (user != null) { // Process user with orders loaded user.getOrders().forEach(order -> processOrder(order)); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `joinEntitiesToLoad` (`Class<?>`) — the class of join entities to load
- **Returns:** the entity with specified join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId, true); if (user != null) { // All @JoinedBy fields are populated performCompleteUserAnalysis(user); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** the entity with join entities loaded as specified, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties and loads the specified join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with only selected properties and loads the specified join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with specific fields and orders User user = userDao.gett(userId, Arrays.asList("id", "name", "email"), Order.class); if (user != null) { displayUserWithOrders(user); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of join entities to load
- **Returns:** the entity with selected properties and join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties and loads multiple types of join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with only selected properties and loads multiple types of join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with selected properties and multiple relations User user = userDao.gett(userId, Arrays.asList("id", "name", "status"), Arrays.asList(Order.class, UserProfile.class)); if (user != null) { processUserWithOrdersAndProfile(user); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
- **Returns:** the entity with selected properties and specified join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with only selected properties and optionally loads all join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with only selected properties and optionally loads all join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with minimal fields and all relations User user = userDao.gett(userId, Arrays.asList("id", "name", "email"), true); // Load all @JoinedBy fields if (user != null) { performFullUserAnalysis(user); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** the entity with selected properties and join entities as specified, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
##### batchGet(...) -> List<T>
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs and loads the specified type of join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load for each entity
- **Returns:** a list of entities with the specified join entities loaded
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs and optionally loads all join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** a list of entities with join entities loaded as specified
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with selected properties and loads the specified join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of join entities to load for each entity
- **Returns:** a list of entities with selected properties and join entities loaded
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with selected properties and loads multiple types of join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load for each entity
- **Returns:** a list of entities with selected properties and specified join entities loaded
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with selected properties and optionally loads all join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** a list of entities with selected properties and join entities as specified
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with selected properties and loads the specified join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of join entities to load for each entity
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of entities with selected properties and join entities loaded
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with selected properties and loads multiple types of join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load for each entity
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of entities with selected properties and specified join entities loaded
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final int batchSize) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves multiple entities by their IDs with selected properties and optionally loads all join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of entities with selected properties and join entities as specified
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input {@code ids}
  - `java.sql.SQLException` — if a database access error occurs

### Interface CrudJoinEntityHelperL (com.landawn.abacus.jdbc.dao.CrudJoinEntityHelperL)
A specialized interface for CRUD operations with join entity support that uses {@code Long} as the ID type.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### get(...) -> Optional<T>
- **Signature:** `@Beta default Optional<T> get(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and loads the specified join entities.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** an Optional containing the retrieved entity with the specified join entities loaded, or an empty Optional if no entity is found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and optionally loads all join entities.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** an Optional containing the retrieved entity with join entities loaded, or an empty Optional if no entity is found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with selected properties and loads the specified join entities.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** an Optional containing the retrieved entity with join entities loaded, or an empty Optional if no entity is found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with selected properties and loads multiple join entity types.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
- **Returns:** an Optional containing the retrieved entity with join entities loaded, or an empty Optional if no entity is found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with selected properties and optionally loads all join entities.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** an Optional containing the retrieved entity with join entities loaded, or an empty Optional if no entity is found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
##### gett(...) -> T
- **Signature:** `@Beta default T gett(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and loads the specified join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID and loads the specified join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L, Order.class); if (user != null) { System.out.println("User: " + user.getName()); System.out.println("Orders: " + user.getOrders().size()); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** the retrieved entity with join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L, true); if (user != null) { // All @JoinedBy annotated fields are loaded processUserWithAllRelations(user); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** the retrieved entity with join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with selected properties and loads the specified join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with selected properties and loads the specified join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with minimal fields plus orders User user = userDao.gett(123L, Arrays.asList("id", "name"), Order.class); if (user != null) { displayUserSummary(user); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** the retrieved entity with join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with selected properties and loads multiple join entity types, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with selected properties and loads multiple join entity types, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with orders and addresses User user = userDao.gett(123L, null, Arrays.asList(Order.class, Address.class)); if (user != null) { processUserWithRelations(user); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
- **Returns:** the retrieved entity with join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default T gett(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException`
- **Summary:** Retrieves an entity by its ID with selected properties and optionally loads all join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with selected properties and optionally loads all join entities, returning {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with essential fields and all relations User user = userDao.gett(123L, Arrays.asList("id", "name", "status"), true); if (user != null) { performCompleteUserAnalysis(user); } } </pre>
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** the retrieved entity with join entities loaded, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `java.sql.SQLException` — if a database access error occurs

### Interface Dao (com.landawn.abacus.jdbc.dao.Dao)
The {@code Dao} interface provides a comprehensive data access abstraction layer for database operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### dataSource(...) -> javax.sql.DataSource
- **Signature:** `@NonDBOperation javax.sql.DataSource dataSource()`
- **Summary:** Retrieves the underlying data source used by this DAO for database connections.
- **Parameters:**
  - (none)
- **Returns:** the data source configured for this DAO
##### sqlMapper(...) -> SQLMapper
- **Signature:** `@NonDBOperation SQLMapper sqlMapper()`
- **Summary:** Retrieves the {@code SQLMapper} instance configured for this DAO.
- **Contract:**
  - If no SQLMapper is configured, an empty SQLMapper instance will be returned.
- **Parameters:**
  - (none)
- **Returns:** the SQLMapper instance, never null
##### targetEntityClass(...) -> Class<T>
- **Signature:** `@Deprecated @NonDBOperation @Internal Class<T> targetEntityClass()`
- **Summary:** Retrieves the class object representing the entity type managed by this DAO.
- **Parameters:**
  - (none)
- **Returns:** the class of the target entity type T
##### targetTableName(...) -> String
- **Signature:** `@Deprecated @NonDBOperation @Internal String targetTableName()`
- **Summary:** Retrieves the name of the database table associated with the entity type.
- **Parameters:**
  - (none)
- **Returns:** the name of the target table
##### executor(...) -> Executor
- **Signature:** `@Deprecated @NonDBOperation @Internal Executor executor()`
- **Summary:** Retrieves the executor used for asynchronous operations.
- **Contract:**
  - This executor is used when async methods are called without specifying a custom executor.
- **Parameters:**
  - (none)
- **Returns:** the default executor for asynchronous operations
##### asyncExecutor(...) -> AsyncExecutor
- **Signature:** `@Deprecated @NonDBOperation @Internal AsyncExecutor asyncExecutor()`
- **Summary:** Retrieves the async executor wrapper that provides enhanced async operation support.
- **Parameters:**
  - (none)
- **Returns:** the async executor instance
##### prepareQuery(...) -> PreparedQuery
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query) throws SQLException`
- **Summary:** Creates a PreparedQuery for the specified SQL query string.
- **Parameters:**
  - `query` (`String`) — the SQL query string
- **Returns:** a PreparedQuery instance for the specified query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query, final boolean generateKeys) throws SQLException`
- **Summary:** Creates a PreparedQuery with the option to generate keys for INSERT statements.
- **Contract:**
  - When generateKeys is {@code true} , auto-generated keys can be retrieved after execution.
- **Parameters:**
  - `query` (`String`) — the SQL query string
  - `generateKeys` (`boolean`) — {@code true} to return generated keys, {@code false} otherwise
- **Returns:** a PreparedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query, final int[] returnColumnIndexes) throws SQLException`
- **Summary:** Creates a PreparedQuery that will return specific columns as generated keys.
- **Contract:**
  - This is useful when you need to retrieve specific auto-generated column values.
- **Parameters:**
  - `query` (`String`) — the SQL query string
  - `returnColumnIndexes` (`int[]`) — array of column indexes to return as generated keys
- **Returns:** a PreparedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query, final String[] returnColumnNames) throws SQLException`
- **Summary:** Creates a PreparedQuery that will return specific named columns as generated keys.
- **Parameters:**
  - `query` (`String`) — the SQL query string
  - `returnColumnNames` (`String[]`) — array of column names to return as generated keys
- **Returns:** a PreparedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQuery(final String sql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws SQLException`
- **Summary:** Creates a PreparedQuery using a custom statement creator function.
- **Parameters:**
  - `sql` (`String`) — the SQL query string
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — function to create the PreparedStatement with custom options
- **Returns:** a PreparedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQuery(final Condition cond) throws SQLException`
- **Summary:** Creates a SELECT query based on the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a PreparedQuery instance for the SELECT statement
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQuery(final Collection<String> selectPropNames, final Condition cond) throws SQLException`
- **Summary:** Creates a SELECT query for specific columns based on the specified condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the property names to select, or {@code null} to select all
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a PreparedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### prepareQueryForLargeResult(...) -> PreparedQuery
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQueryForLargeResult(final String query) throws SQLException`
- **Summary:** Creates a PreparedQuery optimized for queries that return large result sets.
- **Parameters:**
  - `query` (`String`) — the SQL query string
- **Returns:** a PreparedQuery configured for large results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** JdbcUtil#prepareNamedQueryForLargeResult(DataSource, String)
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQueryForLargeResult(final Condition cond) throws SQLException`
- **Summary:** Creates a SELECT query optimized for large result sets based on the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a PreparedQuery configured for large results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** JdbcUtil#prepareNamedQueryForLargeResult(DataSource, String)
- **Signature:** `@Beta @NonDBOperation default PreparedQuery prepareQueryForLargeResult(final Collection<String> selectPropNames, final Condition cond) throws SQLException`
- **Summary:** Creates a SELECT query for specific columns optimized for large result sets.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the property names to select, or {@code null} to select all
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a PreparedQuery configured for large results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### prepareNamedQuery(...) -> NamedQuery
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery) throws SQLException`
- **Summary:** Creates a NamedQuery for the specified named SQL query string.
- **Parameters:**
  - `namedQuery` (`String`) — the named SQL query string with :paramName placeholders
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final boolean generateKeys) throws SQLException`
- **Summary:** Creates a NamedQuery with the option to generate keys for INSERT statements.
- **Parameters:**
  - `namedQuery` (`String`) — the named SQL query string
  - `generateKeys` (`boolean`) — {@code true} to return generated keys
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final int[] returnColumnIndexes) throws SQLException`
- **Summary:** Creates a NamedQuery that will return specific columns as generated keys.
- **Parameters:**
  - `namedQuery` (`String`) — the named SQL query string
  - `returnColumnIndexes` (`int[]`) — array of column indexes to return
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final String[] returnColumnNames) throws SQLException`
- **Summary:** Creates a NamedQuery that will return specific named columns as generated keys.
- **Parameters:**
  - `namedQuery` (`String`) — the named SQL query string
  - `returnColumnNames` (`String[]`) — array of column names to return
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws SQLException`
- **Summary:** Creates a NamedQuery using a custom statement creator function.
- **Parameters:**
  - `namedQuery` (`String`) — the named SQL query string
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — function to create the PreparedStatement
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedSql) throws SQLException`
- **Summary:** Creates a NamedQuery from a pre-parsed SQL object.
- **Contract:**
  - This is more efficient when reusing the same query multiple times.
- **Parameters:**
  - `namedSql` (`ParsedSql`) — the pre-parsed named query
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedSql, final boolean generateKeys) throws SQLException`
- **Summary:** Creates a NamedQuery from a pre-parsed SQL object with key generation option.
- **Parameters:**
  - `namedSql` (`ParsedSql`) — the pre-parsed named query
  - `generateKeys` (`boolean`) — {@code true} to return generated keys
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final int[] returnColumnIndexes) throws SQLException`
- **Summary:** Creates a NamedQuery from a pre-parsed SQL with specific return columns by index.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed named query
  - `returnColumnIndexes` (`int[]`) — array of column indexes to return
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final String[] returnColumnNames) throws SQLException`
- **Summary:** Creates a NamedQuery from a pre-parsed SQL with specific return columns by name.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed named query
  - `returnColumnNames` (`String[]`) — array of column names to return
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws SQLException`
- **Summary:** Creates a NamedQuery from a pre-parsed SQL with custom statement creation.
- **Parameters:**
  - `namedSql` (`ParsedSql`) — the pre-parsed named query
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — function to create the PreparedStatement
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final Condition cond) throws SQLException`
- **Summary:** Creates a named SELECT query based on the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final Collection<String> selectPropNames, final Condition cond) throws SQLException`
- **Summary:** Creates a named SELECT query for specific columns based on the specified condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the property names to select, or {@code null} for all
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a NamedQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### prepareNamedQueryForLargeResult(...) -> NamedQuery
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final String namedQuery) throws SQLException`
- **Summary:** Creates a NamedQuery optimized for large result sets.
- **Parameters:**
  - `namedQuery` (`String`) — the named SQL query string
- **Returns:** a NamedQuery configured for large results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final ParsedSql namedSql) throws SQLException`
- **Summary:** Creates a NamedQuery from pre-parsed SQL optimized for large result sets.
- **Parameters:**
  - `namedSql` (`ParsedSql`) — the pre-parsed named query
- **Returns:** a NamedQuery configured for large results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final Condition cond) throws SQLException`
- **Summary:** Creates a named SELECT query optimized for large result sets based on condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a NamedQuery configured for large results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final Collection<String> selectPropNames, final Condition cond) throws SQLException`
- **Summary:** Creates a named SELECT query for specific columns optimized for large result sets.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the property names to select, or {@code null} for all
  - `cond` (`Condition`) — the condition for the WHERE clause
- **Returns:** a NamedQuery configured for large results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### prepareCallableQuery(...) -> CallableQuery
- **Signature:** `@Beta @NonDBOperation default CallableQuery prepareCallableQuery(final String query) throws SQLException`
- **Summary:** Creates a CallableQuery for executing stored procedures or functions.
- **Contract:**
  - The query should use the JDBC escape syntax: {call procedure_name(?, ?)} <p> <b> Usage Examples: </b> </p> <pre> {@code CallableQuery query = dao.prepareCallableQuery("{call get_user_count(?)}"); query.registerOutParameter(1, Types.INTEGER); query.execute(); int count = query.getInt(1); } </pre>
- **Parameters:**
  - `query` (`String`) — the stored procedure call string
- **Returns:** a CallableQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta @NonDBOperation default CallableQuery prepareCallableQuery(final String sql, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws SQLException`
- **Summary:** Creates a CallableQuery using a custom statement creator.
- **Parameters:**
  - `sql` (`String`) — the stored procedure call string
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, CallableStatement, SQLException>`) — function to create the CallableStatement
- **Returns:** a CallableQuery instance
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### save(...) -> void
- **Signature:** `void save(final T entityToSave) throws SQLException`
- **Summary:** Saves (inserts) the specified entity to the database.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to insert
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void save(final T entityToSave, final Collection<String> propNamesToSave) throws SQLException`
- **Summary:** Saves (inserts) the specified entity with only the specified properties.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to insert
  - `propNamesToSave` (`Collection<String>`) — the property names to include in the INSERT
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void save(final String namedInsertSql, final T entityToSave) throws SQLException`
- **Summary:** Saves (inserts) the entity using a custom named INSERT SQL statement.
- **Contract:**
  - The SQL should use named parameters that match the entity properties.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named INSERT SQL statement
  - `entityToSave` (`T`) — the entity providing the parameter values
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### batchSave(...) -> void
- **Signature:** `default void batchSave(final Collection<? extends T> entitiesToSave) throws SQLException`
- **Summary:** Batch saves (inserts) multiple entities using the default batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to insert
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** #batchSave(Collection, int)
- **Signature:** `void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws SQLException`
- **Summary:** Batch saves (inserts) multiple entities with a specified batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to insert
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws SQLException`
- **Summary:** Batch saves entities with only the specified properties using default batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to insert
  - `propNamesToSave` (`Collection<String>`) — the property names to include in the INSERT
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws SQLException`
- **Summary:** Batch saves entities with only the specified properties and custom batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to insert
  - `propNamesToSave` (`Collection<String>`) — the property names to include
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws SQLException`
- **Summary:** Batch saves entities using a custom named INSERT SQL with default batch size.
- **Contract:**
  - The SQL should use named parameters matching entity properties.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named INSERT SQL statement
  - `entitiesToSave` (`Collection<? extends T>`) — the entities providing parameter values
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws SQLException`
- **Summary:** Batch saves entities using a custom named INSERT SQL with specified batch size.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named INSERT SQL statement
  - `entitiesToSave` (`Collection<? extends T>`) — the entities providing parameter values
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### exists(...) -> boolean
- **Signature:** `boolean exists(final Condition cond) throws SQLException`
- **Summary:** Checks if at least one record exists that matches the specified condition.
- **Contract:**
  - Checks if at least one record exists that matches the specified condition.
  - More efficient than counting when you only need to know if records exist.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code boolean hasActiveUsers = dao.exists(Filters.eq("status", "ACTIVE")); if (hasActiveUsers) { // Process active users } } </pre>
- **Parameters:**
  - `cond` (`Condition`) — the condition to check
- **Returns:** {@code true} if at least one matching record exists
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** Filters
##### notExists(...) -> boolean
- **Signature:** `@Beta default boolean notExists(final Condition cond) throws SQLException`
- **Summary:** Checks if no records exist that match the specified condition.
- **Contract:**
  - Checks if no records exist that match the specified condition.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (dao.notExists(Filters.eq("email", email))) { // Email is available, proceed with registration } } </pre>
- **Parameters:**
  - `cond` (`Condition`) — the condition to check
- **Returns:** {@code true} if no matching records exist
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### count(...) -> int
- **Signature:** `int count(final Condition cond) throws SQLException`
- **Summary:** Counts the number of records that match the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition for counting
- **Returns:** the number of matching records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### findFirst(...) -> Optional<T>
- **Signature:** `Optional<T> findFirst(final Condition cond) throws SQLException`
- **Summary:** Finds the first record that matches the specified condition.
- **Contract:**
  - Returns an Optional containing the entity if found, empty otherwise.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
- **Returns:** Optional containing the first matching entity
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> Optional<R> findFirst(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException`
- **Summary:** Finds the first record matching the condition and maps it using the provided mapper.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result row
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
- **Signature:** `<R> Optional<R> findFirst(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException`
- **Summary:** Finds the first record matching the condition and maps it using a bi-function mapper.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the bi-function to map the result row
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
- **Signature:** `Optional<T> findFirst(final Collection<String> selectPropNames, final Condition cond) throws SQLException`
- **Summary:** Finds the first record with only specified properties matching the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
- **Returns:** Optional containing the first matching entity
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException`
- **Summary:** Finds the first record with specified properties and maps the result.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
- **Signature:** `<R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException`
- **Summary:** Finds the first record with specified properties using a bi-function mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the bi-function to map the result
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
##### findOnlyOne(...) -> Optional<T>
- **Signature:** `Optional<T> findOnlyOne(final Condition cond) throws DuplicatedResultException, SQLException`
- **Summary:** Finds exactly one record matching the condition, throwing exception if multiple found.
- **Contract:**
  - Finds exactly one record matching the condition, throwing exception if multiple found.
  - Use this when you expect exactly zero or one result.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Optional<User> user = dao.findOnlyOne(Filters.eq("email", "john@example.com")); // Throws DuplicatedResultException if multiple users have this email } </pre>
- **Parameters:**
  - `cond` (`Condition`) — the search condition
- **Returns:** Optional containing the single matching entity
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record matches
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException`
- **Summary:** Finds exactly one record and maps it, throwing exception if multiple found.
- **Contract:**
  - Finds exactly one record and maps it, throwing exception if multiple found.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record matches
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
- **Signature:** `<R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException`
- **Summary:** Finds exactly one record using a bi-function mapper, throwing if multiple found.
- **Contract:**
  - Finds exactly one record using a bi-function mapper, throwing if multiple found.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the bi-function to map the result
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record matches
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
- **Signature:** `Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Condition cond) throws DuplicatedResultException, SQLException`
- **Summary:** Finds exactly one record with specified properties, throwing if multiple found.
- **Contract:**
  - Finds exactly one record with specified properties, throwing if multiple found.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
- **Returns:** Optional containing the single matching entity
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record matches
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException`
- **Summary:** Finds exactly one record with specified properties and maps it.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record matches
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
- **Signature:** `<R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException`
- **Summary:** Finds exactly one record with specified properties using a bi-function mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the bi-function to map the result
- **Returns:** Optional containing the mapped result
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record matches
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.IllegalArgumentException` — if rowMapper returns null
##### queryForBoolean(...) -> OptionalBoolean
- **Signature:** `OptionalBoolean queryForBoolean(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a boolean value from a single column.
- **Contract:**
  - Returns an OptionalBoolean containing the value if found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = dao.queryForBoolean("is_active", Filters.eq("id", 123)); if (isActive.orElse(false)) { // User is active } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalBoolean containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForChar(...) -> OptionalChar
- **Signature:** `OptionalChar queryForChar(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a char value from a single column.
- **Contract:**
  - Returns an OptionalChar containing the value if found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalChar grade = dao.queryForChar("grade", Filters.eq("student_id", 123)); if (grade.isPresent()) { System.out.println("Grade: " + grade.getAsChar()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalChar containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForByte(...) -> OptionalByte
- **Signature:** `OptionalByte queryForByte(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a byte value from a single column.
- **Contract:**
  - Returns an OptionalByte containing the value if found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalByte containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForShort(...) -> OptionalShort
- **Signature:** `OptionalShort queryForShort(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a short value from a single column.
- **Contract:**
  - Returns an OptionalShort containing the value if found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalShort containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForInt(...) -> OptionalInt
- **Signature:** `OptionalInt queryForInt(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for an integer value from a single column.
- **Contract:**
  - Returns an OptionalInt containing the value if found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalInt containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForLong(...) -> OptionalLong
- **Signature:** `OptionalLong queryForLong(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a long value from a single column.
- **Contract:**
  - Returns an OptionalLong containing the value if found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalLong containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForFloat(...) -> OptionalFloat
- **Signature:** `OptionalFloat queryForFloat(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a float value from a single column.
- **Contract:**
  - Returns an OptionalFloat containing the value if found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalFloat containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForDouble(...) -> OptionalDouble
- **Signature:** `OptionalDouble queryForDouble(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a double value from a single column.
- **Contract:**
  - Returns an OptionalDouble containing the value if found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** OptionalDouble containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForString(...) -> Nullable<String>
- **Signature:** `Nullable<String> queryForString(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a String value from a single column.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** Nullable containing the String value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForDate(...) -> Nullable<java.sql.Date>
- **Signature:** `Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a Date value from a single column.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** Nullable containing the Date value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForTime(...) -> Nullable<java.sql.Time>
- **Signature:** `Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a Time value from a single column.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** Nullable containing the Time value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForTimestamp(...) -> Nullable<java.sql.Timestamp>
- **Signature:** `Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a Timestamp value from a single column.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** Nullable containing the Timestamp value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForBytes(...) -> Nullable<byte\[\]>
- **Signature:** `Nullable<byte[]> queryForBytes(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Queries for a byte array from a single column.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
- **Returns:** Nullable containing the byte array
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### queryForSingleResult(...) -> Nullable<V>
- **Signature:** `<V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws SQLException`
- **Summary:** Queries for a single value of the specified type from a column.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** Nullable containing the value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleResult(Class)
##### queryForSingleNonNull(...) -> Optional<V>
- **Signature:** `<V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws SQLException`
- **Summary:** Queries for a single non-null value of the specified type.
- **Contract:**
  - Returns an Optional, empty if no value found or if the value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** Optional containing the non-null value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleNonNull(Class)
- **Signature:** `@Beta <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws SQLException`
- **Summary:** Queries for a single value using a custom row mapper.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the function to map the result
- **Returns:** Optional containing the mapped value
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleNonNull(Type)
##### queryForUniqueResult(...) -> Nullable<V>
- **Signature:** `<V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique single value, throwing if multiple rows found.
- **Contract:**
  - Queries for a unique single value, throwing if multiple rows found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> uniqueEmail = dao.queryForUniqueResult( "email", Filters.eq("username", "john_doe"), String.class ); // Throws DuplicatedResultException if multiple users have this username } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** Nullable containing the unique value
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one row matches
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueResult(Class)
##### queryForUniqueNonNull(...) -> Optional<V>
- **Signature:** `<V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique non-null single value, throwing if multiple rows found.
- **Contract:**
  - Queries for a unique non-null single value, throwing if multiple rows found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** Optional containing the unique non-null value
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one row matches
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueNonNull(Class)
- **Signature:** `@Beta <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, SQLException`
- **Summary:** Queries for a unique value using a custom row mapper.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the function to map the result
- **Returns:** Optional containing the unique mapped value
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one row matches
  - `java.sql.SQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueNonNull(Type)
##### query(...) -> Dataset
- **Signature:** `Dataset query(final Condition cond) throws SQLException`
- **Summary:** Executes a query and returns the results as a Dataset.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
- **Returns:** Dataset containing the query results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `Dataset query(final Collection<String> selectPropNames, final Condition cond) throws SQLException`
- **Summary:** Executes a query for specific columns and returns results as a Dataset.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
- **Returns:** Dataset containing the query results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> R query(final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws SQLException`
- **Summary:** Executes a query and processes results with a custom result extractor.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — function to process the ResultSet
- **Returns:** the extracted result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws SQLException`
- **Summary:** Executes a query for specific columns with a custom result extractor.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — function to process the ResultSet
- **Returns:** the extracted result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> R query(final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws SQLException`
- **Summary:** Executes a query with a bi-function result extractor.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — bi-function to process the ResultSet
- **Returns:** the extracted result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws SQLException`
- **Summary:** Executes a query for specific columns with a bi-function result extractor.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — bi-function to process the ResultSet
- **Returns:** the extracted result
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### list(...) -> List<T>
- **Signature:** `List<T> list(final Condition cond) throws SQLException`
- **Summary:** Returns a list of all entities matching the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
- **Returns:** list of matching entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a list of results mapped by the provided row mapper.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map each row
- **Returns:** list of mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a list of results mapped by a bi-function row mapper.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map each row
- **Returns:** list of mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a filtered list of results mapped by the row mapper.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter rows
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map filtered rows
- **Returns:** list of filtered and mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a filtered list using bi-function filter and mapper.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.BiRowFilter`) — bi-predicate to filter rows
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map filtered rows
- **Returns:** list of filtered and mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `List<T> list(final Collection<String> selectPropNames, final Condition cond) throws SQLException`
- **Summary:** Returns a list of entities with only the specified properties populated.
- **Contract:**
  - More efficient than loading full entities when only specific fields are needed.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
- **Returns:** list of partially loaded entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a list of selected properties mapped by the row mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map each row
- **Returns:** list of mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a list of selected properties mapped by a bi-function mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map each row
- **Returns:** list of mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a filtered list of selected properties mapped by the row mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter rows
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map filtered rows
- **Returns:** list of filtered and mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a filtered list with bi-function filter and mapper for selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.BiRowFilter`) — bi-predicate to filter rows
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map filtered rows
- **Returns:** list of filtered and mapped results
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") default <R> List<R> list(final String singleSelectPropName, final Condition cond) throws SQLException`
- **Summary:** Returns a list of values from a single property/column.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property to select
  - `cond` (`Condition`) — the search condition
- **Returns:** list of property values
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a list of single property values mapped by the row mapper.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property to select
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map the property value
- **Returns:** list of mapped values
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException`
- **Summary:** Returns a filtered list of single property values.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property to select
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter values
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map filtered values
- **Returns:** list of filtered and mapped values
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### stream(...) -> Stream<T>
- **Signature:** `@LazyEvaluation Stream<T> stream(final Condition cond)`
- **Summary:** Returns a lazy Stream of entities matching the condition.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
- **Returns:** lazy stream of matching entities
- **See also:** Filters
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper)`
- **Summary:** Returns a lazy Stream with custom row mapping.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map each row
- **Returns:** lazy stream of mapped results
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper)`
- **Summary:** Returns a lazy Stream with bi-function row mapping.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map each row
- **Returns:** lazy stream of mapped results
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper)`
- **Summary:** Returns a filtered lazy Stream with row mapping.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter rows
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map filtered rows
- **Returns:** lazy stream of filtered and mapped results
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper)`
- **Summary:** Returns a filtered lazy Stream with bi-function filter and mapper.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.BiRowFilter`) — bi-predicate to filter rows
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map filtered rows
- **Returns:** lazy stream of filtered and mapped results
- **Signature:** `@LazyEvaluation Stream<T> stream(final Collection<String> selectPropNames, final Condition cond)`
- **Summary:** Returns a lazy Stream of entities with selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
- **Returns:** lazy stream of partially loaded entities
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper)`
- **Summary:** Returns a lazy Stream of selected properties with row mapping.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map each row
- **Returns:** lazy stream of mapped results
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper)`
- **Summary:** Returns a lazy Stream with bi-function mapping for selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map each row
- **Returns:** lazy stream of mapped results
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper)`
- **Summary:** Returns a filtered lazy Stream of selected properties with mapping.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter rows
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map filtered rows
- **Returns:** lazy stream of filtered and mapped results
- **Signature:** `@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper)`
- **Summary:** Returns a filtered lazy Stream with maximum flexibility.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.BiRowFilter`) — bi-predicate to filter rows
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — bi-function to map filtered rows
- **Returns:** lazy stream of filtered and mapped results
- **Signature:** `@LazyEvaluation default <R> Stream<R> stream(final String singleSelectPropName, final Condition cond)`
- **Summary:** Returns a lazy Stream of values from a single property.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property to select
  - `cond` (`Condition`) — the search condition
- **Returns:** lazy stream of property values
- **Signature:** `@LazyEvaluation default <R> Stream<R> stream(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper)`
- **Summary:** Returns a lazy Stream of single property values with custom mapping.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property to select
  - `cond` (`Condition`) — the search condition
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map property values
- **Returns:** lazy stream of mapped values
- **Signature:** `@LazyEvaluation default <R> Stream<R> stream(final String singleSelectPropName, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper)`
- **Summary:** Returns a filtered lazy Stream of single property values.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property to select
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter values
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — function to map filtered values
- **Returns:** lazy stream of filtered and mapped values
##### paginate(...) -> Stream<Dataset>
- **Signature:** `@Beta @LazyEvaluation Stream<Dataset> paginate(final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, Dataset> paramSetter)`
- **Summary:** Returns a paginated Stream of query results as Dataset pages.
- **Contract:**
  - The condition must include orderBy for consistent pagination.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Stream<Dataset> pages = dao.paginate( Filters.criteria().where(Filters.gt("id", 0)).orderBy("id"), 100, (query, lastPageResult) -> { if (lastPageResult != null && lastPageResult.size() > 0) { long lastId = lastPageResult.getLong(lastPageResult.size() - 1, "id"); query.setLong(1, lastId); } } ); } </pre>
- **Parameters:**
  - `cond` (`Condition`) — the condition with required orderBy clause
  - `pageSize` (`int`) — the number of records per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super PreparedQuery, Dataset>`) — function to set parameters for next page based on previous results
- **Returns:** stream of Dataset pages
- **Signature:** `@Beta @LazyEvaluation <R> Stream<R> paginate(final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.ResultExtractor<? extends R> resultExtractor)`
- **Summary:** Returns a paginated Stream with custom result extraction.
- **Parameters:**
  - `cond` (`Condition`) — the condition with required orderBy clause
  - `pageSize` (`int`) — the number of records per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super PreparedQuery, R>`) — function to set parameters for next page
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — function to process each page's ResultSet
- **Returns:** stream of processed page results
- **Signature:** `@Beta @LazyEvaluation <R> Stream<R> paginate(final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.BiResultExtractor<? extends R> resultExtractor)`
- **Summary:** Returns a paginated Stream with bi-function result extraction.
- **Parameters:**
  - `cond` (`Condition`) — the condition with required orderBy clause
  - `pageSize` (`int`) — the number of records per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super PreparedQuery, R>`) — function to set parameters for next page
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — bi-function to process each page
- **Returns:** stream of processed page results
- **Signature:** `@Beta @LazyEvaluation Stream<Dataset> paginate(final Collection<String> selectPropNames, final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, Dataset> paramSetter)`
- **Summary:** Returns a paginated Stream with selected properties as Dataset pages.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the condition with required orderBy clause
  - `pageSize` (`int`) — the number of records per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super PreparedQuery, Dataset>`) — function to set parameters for next page
- **Returns:** stream of Dataset pages with selected properties
- **Signature:** `@Beta @LazyEvaluation <R> Stream<R> paginate(final Collection<String> selectPropNames, final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.ResultExtractor<? extends R> resultExtractor)`
- **Summary:** Returns a paginated Stream of selected properties with custom extraction.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the condition with required orderBy clause
  - `pageSize` (`int`) — the number of records per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super PreparedQuery, R>`) — function to set parameters for next page
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — function to process each page
- **Returns:** stream of processed page results
- **Signature:** `@Beta @LazyEvaluation <R> Stream<R> paginate(final Collection<String> selectPropNames, final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.BiResultExtractor<? extends R> resultExtractor)`
- **Summary:** Returns a paginated Stream with bi-function extraction for selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the condition with required orderBy clause
  - `pageSize` (`int`) — the number of records per page
  - `paramSetter` (`Jdbc.BiParametersSetter<? super PreparedQuery, R>`) — function to set parameters for next page
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — bi-function to process each page
- **Returns:** stream of processed page results
##### forEach(...) -> void
- **Signature:** `void forEach(final Condition cond, final Jdbc.RowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over query results, applying the row consumer to each row.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowConsumer` (`Jdbc.RowConsumer`) — consumer to process each row
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void forEach(final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over results with a bi-consumer receiving ResultSet and column labels.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — bi-consumer to process each row
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void forEach(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over filtered results, processing only rows that pass the filter.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter rows
  - `rowConsumer` (`Jdbc.RowConsumer`) — consumer for filtered rows
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void forEach(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over filtered results with bi-function filter and consumer.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.BiRowFilter`) — bi-predicate to filter rows
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — bi-consumer for filtered rows
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over selected properties, applying the consumer to each row.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowConsumer` (`Jdbc.RowConsumer`) — consumer to process each row
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over selected properties with a bi-consumer.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — bi-consumer to process each row
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over filtered results of selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.RowFilter`) — predicate to filter rows
  - `rowConsumer` (`Jdbc.RowConsumer`) — consumer for filtered rows
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws SQLException`
- **Summary:** Iterates over filtered results with maximum flexibility.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select, {@code null} for all
  - `cond` (`Condition`) — the search condition
  - `rowFilter` (`Jdbc.BiRowFilter`) — bi-predicate to filter rows
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — bi-consumer for filtered rows
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### foreach(...) -> void
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void foreach(final Collection<String> selectPropNames, final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws SQLException`
- **Summary:** Iterates over results using a disposable object array consumer.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties to select
  - `cond` (`Condition`) — the search condition
  - `rowConsumer` (`Consumer<DisposableObjArray>`) — consumer that receives reusable row array
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void foreach(final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws SQLException`
- **Summary:** Iterates over all results using a disposable object array consumer.
- **Parameters:**
  - `cond` (`Condition`) — the search condition
  - `rowConsumer` (`Consumer<DisposableObjArray>`) — consumer that receives reusable row array
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### update(...) -> int
- **Signature:** `default int update(final String propName, final Object propValue, final Condition cond) throws SQLException`
- **Summary:** Updates a single property for all records matching the condition.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `cond` (`Condition`) — the condition to match records
- **Returns:** the number of records updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int update(final Map<String, Object> updateProps, final Condition cond) throws SQLException`
- **Summary:** Updates multiple properties for all records matching the condition.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — map of property names to new values
  - `cond` (`Condition`) — the condition to match records
- **Returns:** the number of records updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int update(final T entity, final Condition cond) throws SQLException`
- **Summary:** Updates records matching the condition with all non-null properties from the entity.
- **Parameters:**
  - `entity` (`T`) — the entity containing update values
  - `cond` (`Condition`) — the condition to match records
- **Returns:** the number of records updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws SQLException`
- **Summary:** Updates records with only the specified properties from the entity.
- **Parameters:**
  - `entity` (`T`) — the entity containing update values
  - `propNamesToUpdate` (`Collection<String>`) — the property names to update
  - `cond` (`Condition`) — the condition to match records
- **Returns:** the number of records updated
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### upsert(...) -> T
- **Signature:** `default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws SQLException`
- **Summary:** Performs an upsert operation - inserts if not exists, updates if exists.
- **Contract:**
  - Performs an upsert operation - inserts if not exists, updates if exists.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User("john@example.com", "John Doe"); User saved = dao.upsert(user, Arrays.asList("email")); // Inserts if email doesn't exist, updates if it does } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
  - `uniquePropNamesForQuery` (`List<String>`) — property names that uniquely identify the record
- **Returns:** the saved entity (newly inserted or updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default T upsert(final T entity, final Condition cond) throws SQLException`
- **Summary:** Performs an upsert operation based on a custom condition.
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
  - `cond` (`Condition`) — condition to check for existence
- **Returns:** the saved entity (newly inserted or updated)
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### delete(...) -> int
- **Signature:** `int delete(final Condition cond) throws SQLException`
- **Summary:** Deletes all records matching the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match records for deletion
- **Returns:** the number of records deleted
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### asyncCall(...) -> ContinuableFuture<R>
- **Signature:** `@SuppressWarnings("deprecation") @Beta @NonDBOperation default <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super TD, ? extends R, SQLException> sqlAction)`
- **Summary:** Executes an asynchronous database operation using the default executor.
- **Parameters:**
  - `sqlAction` (`Throwables.Function<? super TD, ? extends R, SQLException>`) — function that performs database operations
- **Returns:** ContinuableFuture with the operation result
- **Signature:** `@Beta @NonDBOperation default <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super TD, ? extends R, SQLException> sqlAction, final Executor executor)`
- **Summary:** Executes an asynchronous database operation using the specified executor.
- **Parameters:**
  - `sqlAction` (`Throwables.Function<? super TD, ? extends R, SQLException>`) — function that performs database operations
  - `executor` (`Executor`) — the executor to run the operation
- **Returns:** ContinuableFuture with the operation result
##### asyncRun(...) -> ContinuableFuture<Void>
- **Signature:** `@SuppressWarnings("deprecation") @Beta @NonDBOperation default ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super TD, SQLException> sqlAction)`
- **Summary:** Executes an asynchronous database operation without return value using default executor.
- **Parameters:**
  - `sqlAction` (`Throwables.Consumer<? super TD, SQLException>`) — consumer that performs database operations
- **Returns:** ContinuableFuture that completes when operation finishes
- **Signature:** `@Beta @NonDBOperation default ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super TD, SQLException> sqlAction, final Executor executor)`
- **Summary:** Executes an asynchronous database operation without return value using specified executor.
- **Parameters:**
  - `sqlAction` (`Throwables.Consumer<? super TD, SQLException>`) — consumer that performs database operations
  - `executor` (`Executor`) — the executor to run the operation
- **Returns:** ContinuableFuture that completes when operation finishes

### Interface JoinEntityHelper (com.landawn.abacus.jdbc.dao.JoinEntityHelper)
Interface for handling join entities in database operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### targetDaoInterface(...) -> Class<TD>
- **Signature:** `@Deprecated @NonDBOperation @Internal Class<TD> targetDaoInterface()`
- **Summary:** Retrieves the class type of the target DAO interface.
- **Parameters:**
  - (none)
- **Returns:** the class type of the target DAO interface
##### targetEntityClass(...) -> Class<T>
- **Signature:** `@Deprecated @NonDBOperation @Internal Class<T> targetEntityClass()`
- **Summary:** Retrieves the class type of the target entity.
- **Parameters:**
  - (none)
- **Returns:** the class type of the target entity
##### targetTableName(...) -> String
- **Signature:** `@Deprecated @NonDBOperation @Internal String targetTableName()`
- **Summary:** Retrieves the name of the target table.
- **Parameters:**
  - (none)
- **Returns:** the name of the target table
##### executor(...) -> Executor
- **Signature:** `@Deprecated @NonDBOperation @Internal Executor executor()`
- **Summary:** Retrieves the executor for executing tasks in parallel.
- **Parameters:**
  - (none)
- **Returns:** the executor for executing parallel tasks
##### findFirst(...) -> Optional<T>
- **Signature:** `default Optional<T> findFirst(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws SQLException`
- **Summary:** Finds the first entity that matches the specified condition and loads the specified join entity.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default Optional<T> findFirst(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws SQLException`
- **Summary:** Finds the first entity that matches the specified condition and loads multiple types of join entities.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default Optional<T> findFirst(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws SQLException`
- **Summary:** Finds the first entity that matches the specified condition, optionally loading all join entities.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### findOnlyOne(...) -> Optional<T>
- **Signature:** `default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, SQLException`
- **Summary:** Finds the only entity that matches the specified condition and loads the specified join entity.
- **Contract:**
  - Throws an exception if more than one entity matches the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an {@code Optional} containing the only matching entity with join entities loaded, or empty if no match
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified condition
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, SQLException`
- **Summary:** Finds the only entity that matches the specified condition and loads multiple types of join entities.
- **Contract:**
  - Throws an exception if more than one entity matches the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an {@code Optional} containing the only matching entity with join entities loaded, or empty if no match
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified condition
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws DuplicatedResultException, SQLException`
- **Summary:** Finds the only entity that matches the specified condition, optionally loading all join entities.
- **Contract:**
  - Throws an exception if more than one entity matches the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `cond` (`Condition`) — the condition to match
- **Returns:** an {@code Optional} containing the only matching entity with join entities loaded, or empty if no match
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified condition
  - `java.sql.SQLException` — if a database access error occurs
##### list(...) -> List<T>
- **Signature:** `@Beta default List<T> list(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws SQLException`
- **Summary:** Retrieves a list of entities that match the specified condition and loads the specified join entity for each.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of entities matching the condition with join entities loaded
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> list(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws SQLException`
- **Summary:** Retrieves a list of entities that match the specified condition and loads multiple types of join entities for each.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of entities matching the condition with join entities loaded
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default List<T> list(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws SQLException`
- **Summary:** Retrieves a list of entities that match the specified condition, optionally loading all join entities.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of entities matching the condition with join entities loaded
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### stream(...) -> Stream<T>
- **Signature:** `@Beta default Stream<T> stream(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond)`
- **Summary:** Streams entities that match the specified condition and loads the specified join entity for each.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** a {@code Stream} of entities matching the condition with join entities loaded
- **Signature:** `@Beta default Stream<T> stream(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond)`
- **Summary:** Streams entities that match the specified condition and loads multiple types of join entities for each.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** a {@code Stream} of entities matching the condition with join entities loaded
- **Signature:** `@Beta default Stream<T> stream(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond)`
- **Summary:** Streams entities that match the specified condition, optionally loading all join entities.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `cond` (`Condition`) — the condition to match
- **Returns:** a {@code Stream} of entities matching the condition with join entities loaded
##### loadJoinEntities(...) -> void
- **Signature:** `default void loadJoinEntities(final T entity, final Class<?> joinEntityClass) throws SQLException`
- **Summary:** Loads join entities of the specified type for a single entity.
- **Contract:**
  - If multiple properties in the entity are of the specified type, all will be loaded.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntities(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities of the specified type for a single entity with specific property selection.
- **Contract:**
  - If multiple properties in the entity are of the specified type, all will be loaded.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws SQLException`
- **Summary:** Loads join entities of the specified type for a collection of entities.
- **Contract:**
  - If multiple properties in the entities are of the specified type, all will be loaded.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities of the specified type for a collection of entities with specific property selection.
- **Contract:**
  - If multiple properties in the entities are of the specified type, all will be loaded.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntities(final T entity, final String joinEntityPropName) throws SQLException`
- **Summary:** Loads join entities for a single entity by property name.
- **Contract:**
  - The property name must correspond to a field annotated with {@code @JoinedBy} .
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void loadJoinEntities(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities for a single entity by property name with specific property selection.
- **Contract:**
  - The property name must correspond to a field annotated with {@code @JoinedBy} .
  - This is an abstract method that must be implemented by concrete DAO classes.
  - </p> <p> The implementation should handle both collection-type properties (List, Set, etc.) and single-entity properties.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities. Must not be {@code null}
  - `joinEntityPropName` (`String`) — the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. This parameter is useful for performance optimization when only specific fields are needed
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws SQLException`
- **Summary:** Loads join entities for a collection of entities by property name.
- **Contract:**
  - The property name must correspond to a field annotated with {@code @JoinedBy} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities for a collection of entities by property name with specific property selection.
- **Contract:**
  - The property name must correspond to a field annotated with {@code @JoinedBy} .
  - This is an abstract method that must be implemented by concrete DAO classes.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities. Can be empty but not {@code null} . If empty, this method returns immediately
  - `joinEntityPropName` (`String`) — the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. Specifying only needed properties can significantly improve query performance and reduce memory usage
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Performance:** </p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, this method executes O(1) queries instead of O(N) </li> <li> Large collections may be automatically batched to prevent excessive memory usage </li> <li> Selecting fewer properties via {@code selectPropNames} can significantly improve performance </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = userDao.list(Filters.between("createdDate", startDate, endDate)); // Load only essential fields from addresses userDao.loadJoinEntities(users, "addresses", Arrays.asList("city", "country")); // Load all fields from orders for multiple users userDao.loadJoinEntities(users, "orders", null); } </pre>
- **Signature:** `default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws SQLException`
- **Summary:** Loads multiple join entities for a single entity by property names.
- **Contract:**
  - Each property name must correspond to a field annotated with {@code @JoinedBy} .
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException`
- **Summary:** Loads multiple join entities for a single entity with optional parallel execution.
- **Contract:**
  - When parallel execution is enabled, join entities are loaded concurrently for better performance.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException`
- **Summary:** Loads multiple join entities for a single entity using a custom executor for parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws SQLException`
- **Summary:** Loads multiple join entities for a collection of entities by property names.
- **Contract:**
  - Each property name must correspond to a field annotated with {@code @JoinedBy} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException`
- **Summary:** Loads multiple join entities for a collection of entities with optional parallel execution.
- **Contract:**
  - When parallel execution is enabled, different join entity types are loaded concurrently.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException`
- **Summary:** Loads multiple join entities for a collection of entities using a custom executor for parallel execution.
- **Contract:**
  - This method provides fine-grained control over the threading behavior when loading multiple join entity types.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### loadAllJoinEntities(...) -> void
- **Signature:** `@SuppressWarnings("deprecation") default void loadAllJoinEntities(final T entity) throws SQLException`
- **Summary:** Loads all join entities for a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load all join entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadAllJoinEntities(final T entity, final boolean inParallel) throws SQLException`
- **Summary:** Loads all join entities for a single entity with optional parallel execution.
- **Contract:**
  - When parallel execution is enabled, all join entities are loaded concurrently for better performance.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load all join entities
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadAllJoinEntities(final T entity, final Executor executor) throws SQLException`
- **Summary:** Loads all join entities for a single entity using a custom executor for parallel execution.
- **Contract:**
  - This method provides fine-grained control over the threading behavior when loading all join entities.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load all join entities
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") default void loadAllJoinEntities(final Collection<T> entities) throws SQLException`
- **Summary:** Loads all join entities for a collection of entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load all join entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws SQLException`
- **Summary:** Loads all join entities for a collection of entities with optional parallel execution.
- **Contract:**
  - When parallel execution is enabled, different join entity types are loaded concurrently.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load all join entities
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadAllJoinEntities(final Collection<T> entities, final Executor executor) throws SQLException`
- **Summary:** Loads all join entities for a collection of entities using a custom executor for parallel execution.
- **Contract:**
  - This method provides fine-grained control over the threading behavior when loading all join entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load all join entities
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### loadJoinEntitiesIfNull(...) -> void
- **Signature:** `default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass) throws SQLException`
- **Summary:** Loads join entities of the specified type for a single entity only if they are currently {@code null} .
- **Contract:**
  - Loads join entities of the specified type for a single entity only if they are currently {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load orders only if not already loaded userDao.loadJoinEntitiesIfNull(user, Order.class); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities of the specified type for a single entity only if they are currently {@code null} , with specific property selection.
- **Contract:**
  - Loads join entities of the specified type for a single entity only if they are currently {@code null} , with specific property selection.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load addresses with specific fields only if not already loaded userDao.loadJoinEntitiesIfNull(user, Address.class, Arrays.asList("street", "city")); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass) throws SQLException`
- **Summary:** Loads join entities of the specified type for a collection of entities only if they are currently {@code null} .
- **Contract:**
  - Loads join entities of the specified type for a collection of entities only if they are currently {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities of the specified type for a collection of entities only if they are currently {@code null} , with specific property selection.
- **Contract:**
  - Loads join entities of the specified type for a collection of entities only if they are currently {@code null} , with specific property selection.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName) throws SQLException`
- **Summary:** Loads join entities for a single entity by property name only if the property is currently {@code null} .
- **Contract:**
  - Loads join entities for a single entity by property name only if the property is currently {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load orders only if not already loaded userDao.loadJoinEntitiesIfNull(user, "orders"); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities for a single entity by property name only if the property is currently {@code null} , with specific property selection.
- **Contract:**
  - Loads join entities for a single entity by property name only if the property is currently {@code null} , with specific property selection.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load addresses with specific fields only if not already loaded userDao.loadJoinEntitiesIfNull(user, "addresses", Arrays.asList("city", "country")); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName) throws SQLException`
- **Summary:** Loads join entities for a collection of entities by property name only if the property is currently {@code null} .
- **Contract:**
  - Loads join entities for a collection of entities by property name only if the property is currently {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException`
- **Summary:** Loads join entities for a collection of entities by property name only if the property is currently {@code null} , with specific property selection.
- **Contract:**
  - Loads join entities for a collection of entities by property name only if the property is currently {@code null} , with specific property selection.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames) throws SQLException`
- **Summary:** Loads multiple join entities for a single entity by property names only if they are currently {@code null} .
- **Contract:**
  - Loads multiple join entities for a single entity by property names only if they are currently {@code null} .
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException`
- **Summary:** Loads multiple join entities for a single entity only if they are currently {@code null} , with optional parallel execution.
- **Contract:**
  - Loads multiple join entities for a single entity only if they are currently {@code null} , with optional parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException`
- **Summary:** Loads multiple join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution.
- **Contract:**
  - Loads multiple join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws SQLException`
- **Summary:** Loads multiple join entities for a collection of entities by property names only if they are currently {@code null} .
- **Contract:**
  - Loads multiple join entities for a collection of entities by property names only if they are currently {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException`
- **Summary:** Loads multiple join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution.
- **Contract:**
  - Loads multiple join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException`
- **Summary:** Loads multiple join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution.
- **Contract:**
  - Loads multiple join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") default void loadJoinEntitiesIfNull(final T entity) throws SQLException`
- **Summary:** Loads all join entities for a single entity only if they are currently {@code null} .
- **Contract:**
  - Loads all join entities for a single entity only if they are currently {@code null} .
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntitiesIfNull(final T entity, final boolean inParallel) throws SQLException`
- **Summary:** Loads all join entities for a single entity only if they are currently {@code null} , with optional parallel execution.
- **Contract:**
  - Loads all join entities for a single entity only if they are currently {@code null} , with optional parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntitiesIfNull(final T entity, final Executor executor) throws SQLException`
- **Summary:** Loads all join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution.
- **Contract:**
  - Loads all join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity for which to load join entities
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") default void loadJoinEntitiesIfNull(final Collection<T> entities) throws SQLException`
- **Summary:** Loads all join entities for a collection of entities only if they are currently {@code null} .
- **Contract:**
  - Loads all join entities for a collection of entities only if they are currently {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final boolean inParallel) throws SQLException`
- **Summary:** Loads all join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution.
- **Contract:**
  - Loads all join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `inParallel` (`boolean`) — if {@code true} , join entities will be loaded in parallel
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final Executor executor) throws SQLException`
- **Summary:** Loads all join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution.
- **Contract:**
  - Loads all join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to load join entities
  - `executor` (`Executor`) — the executor to use for parallel loading
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### deleteJoinEntities(...) -> int
- **Signature:** `default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws SQLException`
- **Summary:** Deletes all join entities of the specified type for a single entity.
- **Contract:**
  - This operation is performed within a transaction if multiple join properties exist for the specified type.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to delete
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws SQLException`
- **Summary:** Deletes all join entities of the specified type for a collection of entities.
- **Contract:**
  - This operation is performed within a transaction if multiple join properties exist for the specified type.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete join entities
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to delete
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int deleteJoinEntities(final T entity, final String joinEntityPropName) throws SQLException`
- **Summary:** Deletes join entities for a single entity by property name.
- **Contract:**
  - The property name must correspond to a field annotated with {@code @JoinedBy} .
  - This is an abstract method that must be implemented by concrete DAO classes.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete join entities. Must not be {@code null}
  - `joinEntityPropName` (`String`) — the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
- **Returns:** the total number of deleted records. Returns 0 if no matching records were found
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws SQLException`
- **Summary:** Deletes join entities for a collection of entities by property name.
- **Contract:**
  - The property name must correspond to a field annotated with {@code @JoinedBy} .
  - This is an abstract method that must be implemented by concrete DAO classes.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete join entities. Can be empty but not {@code null} . If empty, this method returns 0 immediately
  - `joinEntityPropName` (`String`) — the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
- **Returns:** the total number of deleted records across all parent entities. Returns 0 if no matching records were found or if {@code entities} is empty
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Performance:** </p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, executes O(1) or O(N/batch_size) DELETE statements instead of O(N) </li> <li> Much more efficient than deleting join entities one parent at a time </li> <li> The actual number of deleted records may be less than or greater than the number of parent entities </li> </ul> <p> Important notes: </p> <ul> <li> This operation does NOT modify the in-memory join properties of the entities </li> <li> All deletions are permanent unless executed within a transaction </li> <li> For transactional deletion of multiple properties, use {@link #deleteJoinEntities(Collection, Collection)} </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = userDao.list(Filters.in("id", userIdsToClean)); // Delete all reviews for these users int deletedCount = userDao.deleteJoinEntities(users, "reviews"); System.out.println("Deleted " + deletedCount + " reviews for " + users.size() + " users"); } </pre>
- **Signature:** `default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws SQLException`
- **Summary:** Deletes multiple join entities for a single entity by property names.
- **Contract:**
  - This operation is performed within a transaction when multiple properties are specified.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException`
- **Summary:** Deletes multiple join entities for a single entity with optional parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `inParallel` (`boolean`) — if {@code true} , join entities will be deleted in parallel
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException`
- **Summary:** Deletes multiple join entities for a single entity using a custom executor for parallel execution.
- **Contract:**
  - Note: This operation cannot be completed within a single transaction when executed in multiple threads.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `executor` (`Executor`) — the executor to use for parallel deletion
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws SQLException`
- **Summary:** Deletes multiple join entities for a collection of entities by property names.
- **Contract:**
  - This operation is performed within a transaction when multiple properties are specified.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException`
- **Summary:** Deletes multiple join entities for a collection of entities with optional parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `inParallel` (`boolean`) — if {@code true} , join entities will be deleted in parallel
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException`
- **Summary:** Deletes multiple join entities for a collection of entities using a custom executor for parallel execution.
- **Contract:**
  - Note: This operation cannot be completed within a single transaction when executed in multiple threads.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete join entities
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `executor` (`Executor`) — the executor to use for parallel deletion
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
##### deleteAllJoinEntities(...) -> int
- **Signature:** `@SuppressWarnings("deprecation") default int deleteAllJoinEntities(final T entity) throws SQLException`
- **Summary:** Deletes all join entities for a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete all join entities
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws SQLException`
- **Summary:** Deletes all join entities for a single entity with optional parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete all join entities
  - `inParallel` (`boolean`) — if {@code true} , join entities will be deleted in parallel
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteAllJoinEntities(final T entity, final Executor executor) throws SQLException`
- **Summary:** Deletes all join entities for a single entity using a custom executor for parallel execution.
- **Contract:**
  - Note: This operation cannot be completed within a single transaction when executed in multiple threads.
- **Parameters:**
  - `entity` (`T`) — the entity for which to delete all join entities
  - `executor` (`Executor`) — the executor to use for parallel deletion
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") default int deleteAllJoinEntities(final Collection<T> entities) throws SQLException`
- **Summary:** Deletes all join entities for a collection of entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete all join entities
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws SQLException`
- **Summary:** Deletes all join entities for a collection of entities with optional parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete all join entities
  - `inParallel` (`boolean`) — if {@code true} , join entities will be deleted in parallel
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
- **Signature:** `@Deprecated @Beta default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws SQLException`
- **Summary:** Deletes all join entities for a collection of entities using a custom executor for parallel execution.
- **Contract:**
  - Note: This operation cannot be completed within a single transaction when executed in multiple threads.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities for which to delete all join entities
  - `executor` (`Executor`) — the executor to use for parallel deletion
- **Returns:** the total number of deleted records
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs

### Interface NoUpdateCrudDao (com.landawn.abacus.jdbc.dao.NoUpdateCrudDao)
A CRUD Data Access Object interface that disables update and delete operations while allowing read and insert operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### update(...) -> int
- **Signature:** `@Deprecated @Override default int update(final T entityToUpdate) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entityToUpdate` (`T`) — the entity with updated values
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
- **Signature:** `@Deprecated @Override default int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entityToUpdate` (`T`) — the entity containing the values to update
  - `propNamesToUpdate` (`Collection<String>`) — the property names to update. If {@code null} or empty, all properties will be updated
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
- **Signature:** `@Override @Deprecated default int update(final String propName, final Object propValue, final ID id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `id` (`ID`) — the entity ID to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
- **Signature:** `@Deprecated @Override default int update(final Map<String, Object> updateProps, final ID id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `id` (`ID`) — the entity ID to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
##### batchUpdate(...) -> int
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `propNamesToUpdate` (`Collection<String>`) — the property names to update for all entities
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `propNamesToUpdate` (`Collection<String>`) — the property names to update for all entities
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
##### upsert(...) -> T
- **Signature:** `@Deprecated @Override default T upsert(final T entity) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to upsert
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upserts are not supported
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
  - `cond` (`Condition`) — the condition to check if the entity exists
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upserts are not supported
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify the entity
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upserts are not supported
##### batchUpsert(...) -> List<T>
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upserts are not supported
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upserts are not supported
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify each entity
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upserts are not supported
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify each entity
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upserts are not supported
##### delete(...) -> int
- **Signature:** `@Deprecated @Override default int delete(final T entity) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to delete (must have ID populated)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as deletes are not supported
##### deleteById(...) -> int
- **Signature:** `@Deprecated @Override default int deleteById(final ID id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `id` (`ID`) — the entity ID to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as deletes are not supported
##### batchDelete(...) -> int
- **Signature:** `@Deprecated @Override default int batchDelete(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as deletes are not supported
- **Signature:** `@Deprecated @Override default int batchDelete(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to delete
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as deletes are not supported
##### batchDeleteByIds(...) -> int
- **Signature:** `@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as deletes are not supported
- **Signature:** `@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of IDs to delete
  - `batchSize` (`int`) — the number of IDs to process in each batch
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as deletes are not supported

### Interface NoUpdateCrudDaoL (com.landawn.abacus.jdbc.dao.NoUpdateCrudDaoL)
A CRUD Data Access Object interface for entities with {@code Long} type primary keys that disables update and delete operations while allowing read and insert operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### update(...) -> int
- **Signature:** `@Deprecated @Override default int update(final String propName, final Object propValue, final long id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `id` (`long`) — the primitive long ID of the entity to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
- **Signature:** `@Deprecated @Override default int update(final Map<String, Object> updateProps, final long id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `id` (`long`) — the primitive long ID of the entity to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as updates are not supported
##### deleteById(...) -> int
- **Signature:** `@Deprecated @Override default int deleteById(final long id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `id` (`long`) — the primitive long ID of the entity to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as deletes are not supported

### Interface NoUpdateDao (com.landawn.abacus.jdbc.dao.NoUpdateDao)
This interface extends the base Dao interface but disables update and delete operations while allowing read and insert operations to ensure data integrity in scenarios where modifications to existing records should be prevented.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### prepareQuery(...) -> PreparedQuery
- **Signature:** `@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a SQL query for execution.
- **Contract:**
  - <p> The query string should be a valid SQL SELECT or INSERT statement.
- **Parameters:**
  - `query` (`String`) — the SQL query string to prepare (must be SELECT or INSERT)
- **Returns:** a PreparedQuery object for executing the query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final boolean generateKeys) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a SQL query with support for auto-generated keys retrieval.
- **Contract:**
  - <p> When {@code generateKeys} is {@code true} , the prepared statement will be configured to return auto-generated keys which can be retrieved after executing an INSERT.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Row generated = dao.prepareQuery("INSERT INTO users (name, email) VALUES (?, ?)", true) .setString(1, "John Doe") .setString(2, "john@example.com") .insert() .orElse(null); if (generated != null) { long generatedId = generated.getLong(1); } } </pre>
- **Parameters:**
  - `query` (`String`) — the SQL query string to prepare (must be SELECT or INSERT)
  - `generateKeys` (`boolean`) — {@code true} to enable retrieval of auto-generated keys
- **Returns:** a PreparedQuery object configured for key generation if applicable
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final int[] returnColumnIndexes) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a SQL query with specific column indexes for auto-generated key retrieval.
- **Contract:**
  - This method allows precise control over which auto-generated columns should be returned after an INSERT operation by specifying their column indexes.
  - This is useful when your table has multiple auto-generated columns and you only need specific ones.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Retrieve only the first and third auto-generated columns Row generated = dao.prepareQuery("INSERT INTO orders (customer_id, total) VALUES (?, ?)", new int\[\] {1, 3}) .setLong(1, customerId) .setBigDecimal(2, orderTotal) .insert() .orElse(null); if (generated != null) { long firstColumn = generated.getLong(1); BigDecimal thirdColumn = generated.getBigDecimal(2); } } </pre>
- **Parameters:**
  - `query` (`String`) — the SQL query string to prepare (must be SELECT or INSERT)
  - `returnColumnIndexes` (`int[]`) — an array of column indexes indicating the columns that should be returned from the inserted row
- **Returns:** a PreparedQuery object configured for specific column retrieval
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final String[] returnColumnNames) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a SQL query with specific column names for auto-generated key retrieval.
- **Contract:**
  - This method provides the most readable way to specify which auto-generated columns should be returned after an INSERT operation by using column names instead of indexes.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Row generated = dao.prepareQuery("INSERT INTO users (name, email) VALUES (?, ?)", new String\[\] {"id", "created_timestamp"}) .setString(1, "Jane Doe") .setString(2, "jane@example.com") .insert() .orElse(null); if (generated != null) { long id = generated.getLong("id"); Timestamp created = generated.getTimestamp("created_timestamp"); } } </pre>
- **Parameters:**
  - `query` (`String`) — the SQL query string to prepare (must be SELECT or INSERT)
  - `returnColumnNames` (`String[]`) — an array of column names indicating the columns that should be returned from the inserted row
- **Returns:** a PreparedQuery object configured for named column retrieval
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `query` (`String`) — the SQL query string
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — custom statement creator function
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as custom statement creation operations are not supported
##### prepareNamedQuery(...) -> NamedQuery
- **Signature:** `@NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a named parameter SQL query for execution.
- **Contract:**
  - <p> Named parameters can appear multiple times in the query and will all be set to the same value when the parameter is bound.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters (must be SELECT or INSERT)
- **Returns:** a NamedQuery object for executing the query with named parameters
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final boolean generateKeys) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a named parameter SQL query with support for auto-generated keys retrieval.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters (must be SELECT or INSERT)
  - `generateKeys` (`boolean`) — {@code true} to enable retrieval of auto-generated keys
- **Returns:** a NamedQuery object configured for key generation if applicable
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final int[] returnColumnIndexes) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a named parameter SQL query with specific column indexes for auto-generated key retrieval.
- **Contract:**
  - This method combines named parameters with precise control over which auto-generated columns should be returned by their index positions.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters (must be SELECT or INSERT)
  - `returnColumnIndexes` (`int[]`) — an array of column indexes for generated key retrieval
- **Returns:** a NamedQuery object configured for specific column retrieval
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final String[] returnColumnNames) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a named parameter SQL query with specific column names for auto-generated key retrieval.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters (must be SELECT or INSERT)
  - `returnColumnNames` (`String[]`) — an array of column names for generated key retrieval
- **Returns:** a NamedQuery object configured for named column retrieval
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT or INSERT statement
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — custom statement creator function
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as custom statement creation operations are not supported
- **Signature:** `@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a named query using a pre-parsed SQL object.
- **Contract:**
  - This method is useful when you have already parsed a named query and want to avoid the overhead of parsing it again.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed SQL query object (must represent SELECT or INSERT)
- **Returns:** a NamedQuery object for executing the parsed query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final boolean generateKeys) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a parsed named query with support for auto-generated keys retrieval.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed SQL query object (must represent SELECT or INSERT)
  - `generateKeys` (`boolean`) — {@code true} to enable retrieval of auto-generated keys
- **Returns:** a NamedQuery object configured for key generation if applicable
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final int[] returnColumnIndexes) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a parsed named query with specific column indexes for auto-generated key retrieval.
- **Contract:**
  - This method combines pre-parsed SQL efficiency with precise control over which auto-generated columns should be returned.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed SQL query object (must represent SELECT or INSERT)
  - `returnColumnIndexes` (`int[]`) — an array of column indexes for generated key retrieval
- **Returns:** a NamedQuery object configured for specific column retrieval
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the query is not a SELECT or INSERT statement
- **Signature:** `@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final String[] returnColumnNames) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a parsed named query with specific column names for auto-generated key retrieval.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed SQL query object (must represent SELECT or INSERT)
  - `returnColumnNames` (`String[]`) — an array of column names for generated key retrieval
- **Returns:** a NamedQuery object configured for named column retrieval
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the query is not a SELECT or INSERT statement
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed SQL query object
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>`) — custom statement creator function
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as custom statement creation operations are not supported
##### prepareCallableQuery(...) -> CallableQuery
- **Signature:** `@Deprecated @NonDBOperation @Override default CallableQuery prepareCallableQuery(final String query) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `query` (`String`) — the stored procedure call string
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as callable query operations are not supported
- **Signature:** `@Deprecated @NonDBOperation @Override default CallableQuery prepareCallableQuery(final String query, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `query` (`String`) — the stored procedure call string
  - `stmtCreator` (`Throwables.BiFunction<Connection, String, CallableStatement, SQLException>`) — custom statement creator function
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as callable query operations are not supported
##### update(...) -> int
- **Signature:** `@Override @Deprecated default int update(final String propName, final Object propValue, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `propName` (`String`) — the name of the property to update
  - `propValue` (`Object`) — the new value for the property
  - `cond` (`Condition`) — the condition to identify records to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final Map<String, Object> updateProps, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `cond` (`Condition`) — the condition to identify records to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final T entity, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity containing values to update
  - `cond` (`Condition`) — the condition to identify records to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity containing values to update
  - `propNamesToUpdate` (`Collection<String>`) — collection of property names to update from the entity
  - `cond` (`Condition`) — the condition to identify records to update
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
##### upsert(...) -> T
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to be upserted
  - `uniquePropNamesForQuery` (`List<String>`) — the list of property names to determine uniqueness
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upsert operations are not supported
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to be upserted
  - `cond` (`Condition`) — the condition to check if the record exists
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as upsert operations are not supported
##### delete(...) -> int
- **Signature:** `@Deprecated @Override default int delete(final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `cond` (`Condition`) — the condition to identify records to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported

### Interface ReadOnlyCrudDao (com.landawn.abacus.jdbc.dao.ReadOnlyCrudDao)
A completely read-only CRUD Data Access Object interface that prevents all data modification operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### insert(...) -> ID
- **Signature:** `@Deprecated @Override default ID insert(final T entityToInsert) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (ignored)
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default ID insert(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement (ignored)
  - `entityToSave` (`T`) — the entity whose properties will be bound to the named parameters (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
##### batchInsert(...) -> List<ID>
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert (ignored)
  - `batchSize` (`int`) — the number of entities to process in each batch (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert (ignored)
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert (ignored)
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement (ignored)
  - `batchSize` (`int`) — the number of entities to process in each batch (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement (ignored)
  - `entities` (`Collection<? extends T>`) — the collection of entities whose properties will be bound to the named parameters (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement (ignored)
  - `entities` (`Collection<? extends T>`) — the collection of entities whose properties will be bound to the named parameters (ignored)
  - `batchSize` (`int`) — the number of entities to process in each batch (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported

### Interface ReadOnlyCrudDaoL (com.landawn.abacus.jdbc.dao.ReadOnlyCrudDaoL)
A read-only CRUD (Create, Read, Update, Delete) Data Access Object interface specifically designed for entities with {@code Long} type primary keys.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Interface ReadOnlyCrudJoinEntityHelper (com.landawn.abacus.jdbc.dao.ReadOnlyCrudJoinEntityHelper)
A read-only interface for handling join entity operations with CRUD DAOs.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Interface ReadOnlyCrudJoinEntityHelperL (com.landawn.abacus.jdbc.dao.ReadOnlyCrudJoinEntityHelperL)
A read-only interface for handling join entity operations with CRUD DAOs that use {@code Long} type primary keys.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Interface ReadOnlyDao (com.landawn.abacus.jdbc.dao.ReadOnlyDao)
A strictly read-only Data Access Object interface that only allows SELECT queries.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### prepareQuery(...) -> PreparedQuery
- **Signature:** `@NonDBOperation @Override default PreparedQuery prepareQuery(final String query) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a SQL query for execution.
- **Contract:**
  - <p> The query string must be a valid SQL SELECT statement.
- **Parameters:**
  - `query` (`String`) — the SQL query string to prepare (must be a SELECT statement)
- **Returns:** a PreparedQuery object for executing the query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT statement
- **Signature:** `@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final boolean generateKeys) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `query` (`String`) — the SQL query string
  - `generateKeys` (`boolean`) — {@code true} to retrieve auto-generated keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
- **Signature:** `@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final int[] returnColumnIndexes) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `query` (`String`) — the SQL query string
  - `returnColumnIndexes` (`int[]`) — an array of column indexes for returned keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
- **Signature:** `@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final String[] returnColumnNames) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `query` (`String`) — the SQL query string
  - `returnColumnNames` (`String[]`) — an array of column names for returned keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
##### prepareNamedQuery(...) -> NamedQuery
- **Signature:** `@NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a named parameter SQL query for execution.
- **Contract:**
  - <p> Named parameters can appear multiple times in the query and will all be set to the same value when the parameter is bound.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters (must be a SELECT statement)
- **Returns:** a NamedQuery object for executing the query with named parameters
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the specified query is not a SELECT statement
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final boolean generateKeys) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters
  - `generateKeys` (`boolean`) — {@code true} to retrieve auto-generated keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final int[] returnColumnIndexes) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters
  - `returnColumnIndexes` (`int[]`) — an array of column indexes for returned keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final String[] returnColumnNames) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedQuery` (`String`) — the SQL query string with named parameters
  - `returnColumnNames` (`String[]`) — an array of column names for returned keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
- **Signature:** `@NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery) throws SQLException, UnsupportedOperationException`
- **Summary:** Prepares a named query using a pre-parsed SQL object.
- **Contract:**
  - This method is useful when you have already parsed a named query and want to avoid the overhead of parsing it again.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the pre-parsed SQL query object (must represent a SELECT statement)
- **Returns:** a NamedQuery object for executing the parsed query
- **Throws:**
  - `java.sql.SQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the query is not a SELECT statement
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final boolean generateKeys) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the parsed SQL query with named parameters
  - `generateKeys` (`boolean`) — {@code true} to retrieve auto-generated keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final int[] returnColumnIndexes) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the parsed SQL query with named parameters
  - `returnColumnIndexes` (`int[]`) — an array of column indexes for returned keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
- **Signature:** `@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final String[] returnColumnNames) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedQuery` (`ParsedSql`) — the parsed SQL query with named parameters
  - `returnColumnNames` (`String[]`) — an array of column names for returned keys
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as key generation operations are not supported
##### save(...) -> void
- **Signature:** `@Deprecated @Override default void save(final T entityToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to save
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void save(final T entityToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to save
  - `propNamesToSave` (`Collection<String>`) — collection of property names to save
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void save(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named SQL insert statement
  - `entityToSave` (`T`) — the entity to save
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
##### batchSave(...) -> void
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — collection of entities to save
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — collection of entities to save
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — collection of entities to save
  - `propNamesToSave` (`Collection<String>`) — collection of property names to save
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — collection of entities to save
  - `propNamesToSave` (`Collection<String>`) — collection of property names to save
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named SQL insert statement
  - `entitiesToSave` (`Collection<? extends T>`) — collection of entities to save
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named SQL insert statement
  - `entitiesToSave` (`Collection<? extends T>`) — collection of entities to save
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported

### Interface ReadOnlyJoinEntityHelper (com.landawn.abacus.jdbc.dao.ReadOnlyJoinEntityHelper)
A read-only interface for handling join entity operations in a Data Access Object (DAO) pattern.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### deleteJoinEntities(...) -> int
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityClass` (`Class<?>`) — the class of the join entity to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityClass` (`Class<?>`) — the class of the join entity to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final String joinEntityPropName) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityPropName` (`String`) — the property name of the join entity to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityPropName` (`String`) — the property name of the join entity to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names of join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names of join entities to delete
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names of join entities to delete
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names of join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names of join entities to delete
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names of join entities to delete
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
##### deleteAllJoinEntities(...) -> int
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final T entity) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose all join entities should be deleted
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose all join entities should be deleted
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final T entity, final Executor executor) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entity` (`T`) — the entity whose all join entities should be deleted
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all join entities should be deleted
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all join entities should be deleted
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only mode.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all join entities should be deleted
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface

### Interface UncheckedCrudDao (com.landawn.abacus.jdbc.dao.UncheckedCrudDao)
The UncheckedCrudDao interface provides comprehensive CRUD (Create, Read, Update, Delete) operations with unchecked exceptions.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### generateId(...) -> ID
- **Signature:** `@Deprecated @NonDBOperation @Override default ID generateId() throws UncheckedSQLException, UnsupportedOperationException`
- **Summary:** Generates a new ID for entity insertion.
- **Contract:**
  - <p> This method should be overridden by implementations that support ID generation.
- **Parameters:**
  - (none)
- **Returns:** the generated ID
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
  - `java.lang.UnsupportedOperationException` — if the operation is not supported (default behavior)
##### insert(...) -> ID
- **Signature:** `@Override ID insert(final T entityToInsert) throws UncheckedSQLException`
- **Summary:** Inserts the specified entity into the database and returns the generated ID.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (must not be null)
- **Returns:** the generated ID of the inserted entity
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs or the entity is null
- **Signature:** `@Override ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws UncheckedSQLException`
- **Summary:** Inserts the specified entity with only the specified properties.
- **Contract:**
  - This is useful when you want to insert an entity with only certain fields populated.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (must not be null)
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement. If {@code null} or empty, all properties will be inserted
- **Returns:** the generated ID of the inserted entity
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override ID insert(final String namedInsertSql, final T entityToInsert) throws UncheckedSQLException`
- **Summary:** Inserts an entity using a custom named SQL insert statement.
- **Contract:**
  - The SQL should use named parameters that match the entity's property names.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement
  - `entityToInsert` (`T`) — the entity whose properties will be bound to the named parameters
- **Returns:** the generated ID of the inserted entity
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchInsert(...) -> List<ID>
- **Signature:** `@Override default List<ID> batchInsert(final Collection<? extends T> entities) throws UncheckedSQLException`
- **Summary:** Performs batch insert of multiple entities using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException`
- **Summary:** Performs batch insert of multiple entities with a specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws UncheckedSQLException`
- **Summary:** Performs batch insert with only specified properties for all entities.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws UncheckedSQLException`
- **Summary:** Performs batch insert with only specified properties and custom batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to insert
  - `propNamesToInsert` (`Collection<String>`) — the property names to include in the INSERT statement
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws UncheckedSQLException`
- **Summary:** Performs batch insert using a custom named SQL statement with default batch size.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement
  - `entities` (`Collection<? extends T>`) — the collection of entities whose properties will be bound to the named parameters
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException`
- **Summary:** Performs batch insert using a custom named SQL statement with specified batch size.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named parameter SQL insert statement
  - `entities` (`Collection<? extends T>`) — the collection of entities whose properties will be bound to the named parameters
  - `batchSize` (`int`) — the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.
- **Returns:** a list of generated IDs in the same order as the input entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForBoolean(...) -> OptionalBoolean
- **Signature:** `@Override OptionalBoolean queryForBoolean(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalBoolean} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean("isActive", userId); if (isActive.isPresent() && isActive.getAsBoolean()) { // User is active } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalBoolean containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForBoolean()
##### queryForChar(...) -> OptionalChar
- **Signature:** `@Override OptionalChar queryForChar(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalChar} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalChar grade = userDao.queryForChar("grade", studentId); if (grade.isPresent()) { System.out.println("Student grade: " + grade.getAsChar()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalChar containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForChar()
##### queryForByte(...) -> OptionalByte
- **Signature:** `@Override OptionalByte queryForByte(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalByte} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalByte level = userDao.queryForByte("accessLevel", userId); if (level.isPresent() && level.getAsByte() > 5) { // User has admin access } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalByte containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForByte()
##### queryForShort(...) -> OptionalShort
- **Signature:** `@Override OptionalShort queryForShort(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalShort} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalShort age = userDao.queryForShort("age", userId); if (age.isPresent()) { System.out.println("User age: " + age.getAsShort()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalShort containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForShort()
##### queryForInt(...) -> OptionalInt
- **Signature:** `@Override OptionalInt queryForInt(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalInt} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalInt loginCount = userDao.queryForInt("loginCount", userId); if (loginCount.isPresent() && loginCount.getAsInt() > 100) { // Frequent user } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalInt containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForInt()
##### queryForLong(...) -> OptionalLong
- **Signature:** `@Override OptionalLong queryForLong(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalLong} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalLong totalBytes = userDao.queryForLong("storageUsed", userId); if (totalBytes.isPresent()) { System.out.println("Storage used: " + totalBytes.getAsLong() + " bytes"); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalLong containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForLong()
##### queryForFloat(...) -> OptionalFloat
- **Signature:** `@Override OptionalFloat queryForFloat(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalFloat} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalFloat rating = userDao.queryForFloat("averageRating", productId); if (rating.isPresent() && rating.getAsFloat() >= 4.5f) { // Highly rated product } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalFloat containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForFloat()
##### queryForDouble(...) -> OptionalDouble
- **Signature:** `@Override OptionalDouble queryForDouble(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalDouble} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalDouble balance = userDao.queryForDouble("accountBalance", accountId); if (balance.isPresent()) { processPayment(balance.getAsDouble()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** an OptionalDouble containing the value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForDouble()
##### queryForString(...) -> Nullable<String>
- **Signature:** `@Override Nullable<String> queryForString(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<String>} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForString("email", userId); if (email.isPresent()) { sendNotification(email.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the String value, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForString()
##### queryForDate(...) -> Nullable<java.sql.Date>
- **Signature:** `@Override Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<java.sql.Date>} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<java.sql.Date> birthDate = userDao.queryForDate("birthDate", userId); if (birthDate.isPresent()) { calculateAge(birthDate.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the Date value, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForDate()
##### queryForTime(...) -> Nullable<java.sql.Time>
- **Signature:** `@Override Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<java.sql.Time>} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<java.sql.Time> startTime = userDao.queryForTime("workStartTime", employeeId); if (startTime.isPresent()) { scheduleShift(startTime.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the Time value, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForTime()
##### queryForTimestamp(...) -> Nullable<java.sql.Timestamp>
- **Signature:** `@Override Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<java.sql.Timestamp>} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<java.sql.Timestamp> lastLogin = userDao.queryForTimestamp("lastLoginTime", userId); if (lastLogin.isPresent()) { updateActivity(lastLogin.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the Timestamp value, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForTimestamp()
##### queryForBytes(...) -> Nullable<byte\[\]>
- **Signature:** `@Override Nullable<byte[]> queryForBytes(final String singleSelectPropName, final ID id) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<byte\[\]>} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - The returned {@code Nullable} can contain {@code null} if the database value is {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<byte\[\]> avatar = userDao.queryForBytes("profileImage", userId); if (avatar.isPresent()) { displayImage(avatar.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
- **Returns:** a Nullable containing the byte array value, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForBytes()
##### queryForSingleResult(...) -> Nullable<V>
- **Signature:** `@Override <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<V>} describing the value of a single property for the entity with the specified ID, converted to the specified target type.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<BigDecimal> price = userDao.queryForSingleResult("price", productId, BigDecimal.class); if (price.isPresent()) { applyDiscount(price.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueClass` (`Class<? extends V>`) — the class of the target value type
- **Returns:** a Nullable containing the converted value, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleResult(Class)
##### queryForSingleNonNull(...) -> Optional<V>
- **Signature:** `@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the non-null value of a single property for the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueClass` (`Class<? extends V>`) — the class of the target value type
- **Returns:** an Optional containing the non-null value, or empty if no entity found or value is null
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleNonNull(Class)
- **Signature:** `@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the non-null value mapped by the row mapper for the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the function to map the result set row
- **Returns:** an Optional containing the non-null mapped value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleNonNull(Class)
##### queryForUniqueResult(...) -> Nullable<V>
- **Signature:** `@Override <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Returns a {@code Nullable} describing the value of a single property for the entity with the specified ID.
- **Contract:**
  - Throws {@code DuplicatedResultException} if more than one record is found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Assuming email should be unique per user Nullable<String> email = userDao.queryForUniqueResult("email", userId, String.class); } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueClass` (`Class<? extends V>`) — the class of the target value type
- **Returns:** a Nullable containing the unique result value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueResult(Class)
##### queryForUniqueNonNull(...) -> Optional<V>
- **Signature:** `@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the unique non-null value of a single property for the entity with the specified ID.
- **Contract:**
  - Throws {@code DuplicatedResultException} if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `targetValueClass` (`Class<? extends V>`) — the class of the target value type
- **Returns:** an Optional containing the unique non-null value, or empty if no entity found or value is null
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueNonNull(Class)
- **Signature:** `@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the unique non-null value mapped by the row mapper for the entity with the specified ID.
- **Contract:**
  - Throws {@code DuplicatedResultException} if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`ID`) — the entity ID
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the function to map the result set row
- **Returns:** an Optional containing the unique non-null mapped value, or empty if no entity found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueNonNull(Class)
##### get(...) -> Optional<T>
- **Signature:** `@Override default Optional<T> get(final ID id) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID.
- **Parameters:**
  - `id` (`ID`) — the entity ID
- **Returns:** an Optional containing the entity if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default Optional<T> get(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID, selecting only the specified properties.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties to select, or {@code null} to select all
- **Returns:** an Optional containing the entity with selected properties if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### gett(...) -> T
- **Signature:** `@Override T gett(final ID id) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID.
- **Contract:**
  - Returns the entity directly or {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); if (user != null) { processUser(user); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID
- **Returns:** the entity if found, otherwise null
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override T gett(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID, selecting only the specified properties.
- **Contract:**
  - Returns the entity directly or {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId, Arrays.asList("id", "email", "status")); if (user != {@code null} && "ACTIVE".equals(user.getStatus())) { sendEmail(user.getEmail()); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties to select, or {@code null} to select all
- **Returns:** the entity with selected properties if found, otherwise null
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchGet(...) -> List<T>
- **Signature:** `@Override default List<T> batchGet(final Collection<? extends ID> ids) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Gets multiple entities by their IDs in batch using the default batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
- **Returns:** a list of found entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default List<T> batchGet(final Collection<? extends ID> ids, final int batchSize) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Gets multiple entities by their IDs in batch using the specified batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `batchSize` (`int`) — the size of each batch
- **Returns:** a list of found entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Gets multiple entities by their IDs with only the specified properties selected.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select, or {@code null} to select all
- **Returns:** a list of found entities with selected properties
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final int batchSize) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Gets multiple entities by their IDs with only the specified properties selected, using the specified batch size for efficient querying.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select, or {@code null} to select all
  - `batchSize` (`int`) — the size of each batch
- **Returns:** a list of found entities with selected properties
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### exists(...) -> boolean
- **Signature:** `@Override boolean exists(final ID id) throws UncheckedSQLException`
- **Summary:** Checks if an entity with the specified ID exists in the database.
- **Contract:**
  - Checks if an entity with the specified ID exists in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(userId)) { // User exists, proceed with update userDao.update("lastAccess", new Date(), userId); } else { // User doesn't exist, create new userDao.insert(new User(userId)); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to check
- **Returns:** {@code true} if the entity exists, {@code false} otherwise
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#exists()
##### notExists(...) -> boolean
- **Signature:** `@Beta @Override default boolean notExists(final ID id) throws UncheckedSQLException`
- **Summary:** Checks if an entity with the specified ID does not exist in the database.
- **Contract:**
  - Checks if an entity with the specified ID does not exist in the database.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(userId)) { // User doesn't exist, safe to create userDao.insert(new User(userId)); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID to check
- **Returns:** {@code true} if the entity does not exist, {@code false} if it exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#notExists()
##### count(...) -> int
- **Signature:** `@Beta @Override int count(final Collection<? extends ID> ids) throws UncheckedSQLException`
- **Summary:** Counts the number of entities with the specified IDs.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code List<Long> requestedIds = Arrays.asList(1L, 2L, 3L, 4L, 5L); int existingCount = userDao.count(requestedIds); if (existingCount < requestedIds.size()) { // Some users don't exist } } </pre>
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs to count
- **Returns:** the count of existing entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### update(...) -> int
- **Signature:** `@Override int update(final T entityToUpdate) throws UncheckedSQLException`
- **Summary:** Updates the specified entity in the database.
- **Contract:**
  - The entity must have its ID set.
- **Parameters:**
  - `entityToUpdate` (`T`) — the entity containing the values to update
- **Returns:** the number of rows updated (typically 1 if successful, 0 if not found)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws UncheckedSQLException`
- **Summary:** Updates only the specified properties of the entity in the database.
- **Parameters:**
  - `entityToUpdate` (`T`) — the entity containing the values to update
  - `propNamesToUpdate` (`Collection<String>`) — the properties to update
- **Returns:** the number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default int update(final String propName, final Object propValue, final ID id) throws UncheckedSQLException`
- **Summary:** Updates a single property value for the entity with the specified ID.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `id` (`ID`) — the entity ID
- **Returns:** the number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int update(final Map<String, Object> updateProps, final ID id) throws UncheckedSQLException`
- **Summary:** Updates multiple properties for the entity with the specified ID.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `id` (`ID`) — the entity ID
- **Returns:** the number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchUpdate(...) -> int
- **Signature:** `@Override default int batchUpdate(final Collection<? extends T> entities) throws UncheckedSQLException`
- **Summary:** Batch updates multiple entities using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
- **Returns:** the total number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch updates multiple entities using the specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `batchSize` (`int`) — the size of each batch
- **Returns:** the total number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws UncheckedSQLException`
- **Summary:** Batch updates only the specified properties of multiple entities using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `propNamesToUpdate` (`Collection<String>`) — the properties to update for each entity
- **Returns:** the total number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch updates only the specified properties of multiple entities using the specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to update
  - `propNamesToUpdate` (`Collection<String>`) — the properties to update for each entity
  - `batchSize` (`int`) — the size of each batch
- **Returns:** the total number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### upsert(...) -> T
- **Signature:** `@Override default T upsert(final T entity) throws UncheckedSQLException`
- **Summary:** Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.
- **Contract:**
  - Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.
  - The entity must have ID field(s) defined.
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
- **Returns:** the inserted or updated entity
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UncheckedSQLException`
- **Summary:** Performs an upsert operation: inserts the entity if it doesn't exist based on the specified unique properties, otherwise updates the existing entity.
- **Contract:**
  - Performs an upsert operation: inserts the entity if it doesn't exist based on the specified unique properties, otherwise updates the existing entity.
  - If no record matches the unique properties, inserts the entity.
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify the record
- **Returns:** the inserted or updated entity
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default T upsert(final T entity, final Condition cond) throws UncheckedSQLException`
- **Summary:** Executes an upsert operation based on the specified condition.
- **Contract:**
  - If no record matches the condition, inserts the entity.
- **Parameters:**
  - `entity` (`T`) — the entity to insert or update
  - `cond` (`Condition`) — the condition to check for existing record
- **Returns:** the inserted or updated entity
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchUpsert(...) -> List<T>
- **Signature:** `@Override default List<T> batchUpsert(final Collection<? extends T> entities) throws UncheckedSQLException`
- **Summary:** Batch upserts multiple entities using the default batch size.
- **Contract:**
  - Entities are inserted if they don't exist (based on ID), otherwise updated.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
- **Returns:** a list of upserted entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch upserts multiple entities using the specified batch size.
- **Contract:**
  - Entities are inserted if they don't exist (based on ID), otherwise updated.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `batchSize` (`int`) — the size of each batch
- **Returns:** a list of upserted entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws UncheckedSQLException`
- **Summary:** Batch upserts multiple entities based on the specified unique properties.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify each record
- **Returns:** a list of upserted entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch upserts multiple entities based on the specified unique properties using the specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to upsert
  - `uniquePropNamesForQuery` (`List<String>`) — the property names that uniquely identify each record
  - `batchSize` (`int`) — the size of each batch
- **Returns:** a list of upserted entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### refresh(...) -> boolean
- **Signature:** `@Override default boolean refresh(final T entity) throws UncheckedSQLException`
- **Summary:** Refreshes the specified entity by reloading all its properties from the database.
- **Contract:**
  - The entity must have its ID set.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User(); user.setId(123L); boolean found = userDao.refresh(user); if (found) { // User now contains all current values from database System.out.println("User email: " + user.getEmail()); } } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to refresh (must have ID set)
- **Returns:** {@code true} if the entity was found and refreshed, {@code false} if not found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override @SuppressWarnings("deprecation") default boolean refresh(final T entity, final Collection<String> propNamesToRefresh) throws UncheckedSQLException`
- **Summary:** Refreshes only the specified properties of the entity from the database.
- **Contract:**
  - The entity must have its ID set.
- **Parameters:**
  - `entity` (`T`) — the entity to refresh (must have ID set)
  - `propNamesToRefresh` (`Collection<String>`) — the properties to refresh from the database
- **Returns:** {@code false} if no record found by the ID in the specified entity, {@code true} otherwise
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchRefresh(...) -> int
- **Signature:** `@Override default int batchRefresh(final Collection<? extends T> entities) throws UncheckedSQLException`
- **Summary:** Batch refreshes multiple entities from the database using the default batch size.
- **Contract:**
  - Each entity must have its ID set.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
- **Returns:** the count of successfully refreshed entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default int batchRefresh(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch refreshes multiple entities from the database using the specified batch size.
- **Contract:**
  - Each entity must have its ID set.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
  - `batchSize` (`int`) — the size of each batch
- **Returns:** the count of successfully refreshed entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh) throws UncheckedSQLException`
- **Summary:** Batch refreshes only the specified properties of multiple entities using the default batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
  - `propNamesToRefresh` (`Collection<String>`) — the properties to refresh for each entity
- **Returns:** the count of successfully refreshed entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override @SuppressWarnings("deprecation") default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch refreshes only the specified properties of multiple entities using the specified batch size.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to refresh
  - `propNamesToRefresh` (`Collection<String>`) — the properties to refresh for each entity
  - `batchSize` (`int`) — the size of each batch
- **Returns:** the count of successfully refreshed entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### delete(...) -> int
- **Signature:** `@Override int delete(final T entity) throws UncheckedSQLException`
- **Summary:** Deletes the specified entity from the database.
- **Contract:**
  - The entity must have its ID set.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); int deletedRows = userDao.delete(user); if (deletedRows > 0) { System.out.println("User deleted successfully"); } } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to delete (must have ID set)
- **Returns:** the number of rows deleted (typically 1 or 0)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### deleteById(...) -> int
- **Signature:** `@Override int deleteById(final ID id) throws UncheckedSQLException`
- **Summary:** Deletes the entity with the specified ID from the database.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code int deletedRows = userDao.deleteById(userId); if (deletedRows == 0) { System.out.println("User not found"); } } </pre>
- **Parameters:**
  - `id` (`ID`) — the ID of the entity to delete
- **Returns:** the number of rows deleted (typically 1 or 0)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchDelete(...) -> int
- **Signature:** `@Override default int batchDelete(final Collection<? extends T> entities) throws UncheckedSQLException`
- **Summary:** Batch deletes multiple entities from the database using the default batch size.
- **Contract:**
  - Each entity must have its ID set.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to delete
- **Returns:** the total number of rows deleted
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int batchDelete(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch deletes multiple entities from the database using the specified batch size.
- **Contract:**
  - Each entity must have its ID set.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the collection of entities to delete
  - `batchSize` (`int`) — the size of each batch
- **Returns:** the total number of rows deleted
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchDeleteByIds(...) -> int
- **Signature:** `@Override default int batchDeleteByIds(final Collection<? extends ID> ids) throws UncheckedSQLException`
- **Summary:** Batch deletes entities by their IDs using the default batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs to delete
- **Returns:** the total number of rows deleted
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch deletes entities by their IDs using the specified batch size.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs to delete
  - `batchSize` (`int`) — the size of each batch
- **Returns:** the total number of rows deleted
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs

### Interface UncheckedCrudDaoL (com.landawn.abacus.jdbc.dao.UncheckedCrudDaoL)
A specialized CrudDao interface that uses {@code Long} as the ID type with unchecked exception handling.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### queryForBoolean(...) -> OptionalBoolean
- **Signature:** `@Override default OptionalBoolean queryForBoolean(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a boolean value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalBoolean if no record is found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean("isActive", 123L); if (isActive.isPresent() && isActive.getAsBoolean()) { System.out.println("User is active"); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalBoolean containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForChar(...) -> OptionalChar
- **Signature:** `@Override default OptionalChar queryForChar(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a char value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalChar if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalChar containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForByte(...) -> OptionalByte
- **Signature:** `@Override default OptionalByte queryForByte(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a byte value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalByte if no record is found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalByte level = userDao.queryForByte("level", 123L); if (level.isPresent() && level.getAsByte() >= 5) { // User has sufficient level } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalByte containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForShort(...) -> OptionalShort
- **Signature:** `@Override default OptionalShort queryForShort(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a short value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalShort if no record is found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalShort year = userDao.queryForShort("birthYear", 123L); if (year.isPresent()) { int age = currentYear - year.getAsShort(); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalShort containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForInt(...) -> OptionalInt
- **Signature:** `@Override default OptionalInt queryForInt(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for an integer value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalInt if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalInt containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForLong(...) -> OptionalLong
- **Signature:** `@Override default OptionalLong queryForLong(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a long value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalLong if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalLong containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForFloat(...) -> OptionalFloat
- **Signature:** `@Override default OptionalFloat queryForFloat(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a float value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalFloat if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalFloat containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForDouble(...) -> OptionalDouble
- **Signature:** `@Override default OptionalDouble queryForDouble(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a double value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns an empty OptionalDouble if no record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** an OptionalDouble containing the value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForString(...) -> Nullable<String>
- **Signature:** `@Override default Nullable<String> queryForString(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a String value from a single property of the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForString("email", 123L); if (email.isPresent()) { sendNotification(email.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the String value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForDate(...) -> Nullable<java.sql.Date>
- **Signature:** `@Override default Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a Date value from a single property of the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the Date value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForTime(...) -> Nullable<java.sql.Time>
- **Signature:** `@Override default Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a Time value from a single property of the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the Time value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForTimestamp(...) -> Nullable<java.sql.Timestamp>
- **Signature:** `@Override default Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a Timestamp value from a single property of the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the Timestamp value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForBytes(...) -> Nullable<byte\[\]>
- **Signature:** `@Override default Nullable<byte[]> queryForBytes(final String singleSelectPropName, final long id) throws UncheckedSQLException`
- **Summary:** Queries for a byte array value from a single property of the entity with the specified ID.
- **Contract:**
  - Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
- **Returns:** a Nullable containing the byte array value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForSingleResult(...) -> Nullable<V>
- **Signature:** `@Override default <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws UncheckedSQLException`
- **Summary:** Queries for a single value of the specified type from a property of the entity with the specified ID.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** a Nullable containing the value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForSingleNonNull(...) -> Optional<V>
- **Signature:** `@Override default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws UncheckedSQLException`
- **Summary:** Queries for a single non-null value of the specified type from a property of the entity.
- **Contract:**
  - Returns an empty Optional if no record is found or if the value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** an Optional containing the non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws UncheckedSQLException`
- **Summary:** Queries for a single non-null value using a custom row mapper.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the custom mapper to transform the result
- **Returns:** an Optional containing the mapped non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForUniqueResult(...) -> Nullable<V>
- **Signature:** `@Override default <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Queries for a unique single result of the specified type.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** a Nullable containing the unique value if found, or Nullable.empty() if no record exists
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForUniqueNonNull(...) -> Optional<V>
- **Signature:** `@Override default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Queries for a unique non-null result of the specified type.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
  - Returns empty Optional if no record found or value is {@code null} .
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `targetValueType` (`Class<? extends V>`) — the class of the value type to convert to
- **Returns:** an Optional containing the unique non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Queries for a unique non-null result using a custom row mapper.
- **Contract:**
  - Throws DuplicatedResultException if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the property name to select
  - `id` (`long`) — the primitive long ID of the entity
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the custom mapper to transform the result
- **Returns:** an Optional containing the mapped unique non-null value if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### get(...) -> Optional<T>
- **Signature:** `@Override default Optional<T> get(final long id) throws UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID.
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long
- **Returns:** an Optional containing the entity if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default Optional<T> get(final long id, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID, selecting only the specified properties.
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long
  - `selectPropNames` (`Collection<String>`) — the properties to select, or {@code null} to select all
- **Returns:** an Optional containing the entity with selected properties if found, otherwise empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### gett(...) -> T
- **Signature:** `@Override default T gett(final long id) throws UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID, returning it directly or {@code null} if not found.
- **Contract:**
  - Retrieves the entity with the specified ID, returning it directly or {@code null} if not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L); if (user != null) { processUser(user); } } </pre>
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long
- **Returns:** the entity if found, otherwise null
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default T gett(final long id, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Retrieves the entity with the specified ID and selected properties, returning it directly or {@code null} if not found.
- **Contract:**
  - Retrieves the entity with the specified ID and selected properties, returning it directly or {@code null} if not found.
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long
  - `selectPropNames` (`Collection<String>`) — the properties to select, or {@code null} to select all
- **Returns:** the entity with selected properties if found, otherwise null
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### exists(...) -> boolean
- **Signature:** `@Override default boolean exists(final long id) throws UncheckedSQLException`
- **Summary:** Checks if an entity with the specified ID exists.
- **Contract:**
  - Checks if an entity with the specified ID exists.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(123L)) { // User exists } else { // Create new user } } </pre>
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long
- **Returns:** {@code true} if the entity exists, {@code false} otherwise
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### notExists(...) -> boolean
- **Signature:** `@Beta @Override default boolean notExists(final long id) throws UncheckedSQLException`
- **Summary:** Checks if an entity with the specified ID does not exist.
- **Contract:**
  - Checks if an entity with the specified ID does not exist.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(123L)) { // Safe to create new user with this ID } } </pre>
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long
- **Returns:** {@code true} if the entity does not exist, {@code false} if it exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### update(...) -> int
- **Signature:** `@Override default int update(final String propName, final Object propValue, final long id) throws UncheckedSQLException`
- **Summary:** Updates a single property value for the entity with the specified ID.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `id` (`long`) — the entity ID as primitive long
- **Returns:** the number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default int update(final Map<String, Object> updateProps, final long id) throws UncheckedSQLException`
- **Summary:** Updates multiple properties for the entity with the specified ID.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `id` (`long`) — the entity ID as primitive long
- **Returns:** the number of rows updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### deleteById(...) -> int
- **Signature:** `@Override default int deleteById(final long id) throws UncheckedSQLException`
- **Summary:** Deletes the entity with the specified ID.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code int deleted = userDao.deleteById(123L); if (deleted > 0) { System.out.println("User deleted successfully"); } } </pre>
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long
- **Returns:** the number of rows deleted (typically 1 or 0)
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs

### Interface UncheckedCrudJoinEntityHelper (com.landawn.abacus.jdbc.dao.UncheckedCrudJoinEntityHelper)
The UncheckedCrudJoinEntityHelper interface combines CRUD operations with join entity management capabilities, providing a comprehensive solution for handling entities with relationships.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### get(...) -> Optional<T>
- **Signature:** `@Beta @Override default Optional<T> get(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID and loads the specified join entity class.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with their orders loaded Optional<User> user = userDao.get(userId, Order.class); if (user.isPresent()) { List<Order> orders = user.get().getOrders(); // Orders are already loaded } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default Optional<T> get(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID and optionally loads all join entities.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID with selected properties and loads the specified join entity class.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** an Optional containing the entity with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID with selected properties and loads multiple join entity classes.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
- **Returns:** an Optional containing the entity with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default Optional<T> get(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID with selected properties and optionally loads all join entities.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** an Optional containing the entity with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### gett(...) -> T
- **Signature:** `@Beta @Override default T gett(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID and loads the specified join entity class, returning the entity directly.
- **Contract:**
  - This is a beta API that returns {@code null} if the entity is not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with orders, returns {@code null} if not found User user = userDao.gett(userId, Order.class); if (user != null) { // Process user with loaded orders } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** the entity with loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default T gett(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID and optionally loads all join entities, returning the entity directly.
- **Contract:**
  - This is a beta API that returns {@code null} if the entity is not found.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with all relationships User user = userDao.gett(userId, true); if (user != null) { // All relationships are loaded } } </pre>
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** the entity with loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default T gett(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID with selected properties and loads the specified join entity class.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** the entity with selected properties and loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default T gett(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID with selected properties and loads multiple join entity classes.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
- **Returns:** the entity with selected properties and loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default T gett(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by ID with selected properties and optionally loads all join entities.
- **Parameters:**
  - `id` (`ID`) — the entity ID
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** the entity with selected properties and loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchGet(...) -> List<T>
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities by IDs and loads the specified join entity class for each.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load for each entity
- **Returns:** a list of entities with loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities by IDs and optionally loads all join entities for each.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** a list of entities with loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities with selected properties and loads the specified join entity class.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load for each entity
- **Returns:** a list of entities with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities with selected properties and loads multiple join entity classes.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
- **Returns:** a list of entities with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities with selected properties and optionally loads all join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** a list of entities with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities with selected properties using a specific batch size and loads the specified join entity class.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load for each entity
  - `batchSize` (`int`) — the size of each batch for processing
- **Returns:** a list of entities with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities with selected properties using a specific batch size and loads multiple join entity classes.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `batchSize` (`int`) — the size of each batch for processing
- **Returns:** a list of entities with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final int batchSize) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Batch gets entities with selected properties using a specific batch size and optionally loads all join entities.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — the collection of entity IDs
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `batchSize` (`int`) — the size of each batch for processing
- **Returns:** a list of entities with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if the size of result is bigger than the size of input IDs
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs

### Interface UncheckedCrudJoinEntityHelperL (com.landawn.abacus.jdbc.dao.UncheckedCrudJoinEntityHelperL)
A specialized interface for CRUD operations with join entity support, specifically designed for entities with {@link Long} type primary keys.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### get(...) -> Optional<T>
- **Signature:** `@Override @Beta default Optional<T> get(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID and loads the specified join entity class.
- **Contract:**
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Fetch a user and load their orders Optional<User> userWithOrders = userDao.get(123L, Order.class); if (userWithOrders.isPresent()) { User user = userWithOrders.get(); List<Order> orders = user.getOrders(); // Orders are already loaded } } </pre>
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
- **Returns:** An {@link Optional} containing the entity with loaded join entities, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default Optional<T> get(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with the option to load all associated join entities.
- **Contract:**
  - <p> When {@code includeAllJoinEntities} is {@code true} , all mapped relationships will be loaded.
  - This is useful when you need the complete object graph but should be used carefully to avoid performance issues with large datasets.
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** An {@link Optional} containing the entity, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with specific properties and loads the specified join entity.
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — The properties (columns) to select from the main entity. If {@code null} , all properties are selected
  - `joinEntitiesToLoad` (`Class<?>`) — The class of the join entities to load
- **Returns:** An {@link Optional} containing the entity with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with specific properties and loads multiple join entity types.
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — The properties (columns) to select from the main entity. If {@code null} , all properties are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — Collection of join entity classes to load
- **Returns:** An {@link Optional} containing the entity with selected properties and loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with specific properties and optionally loads all join entities.
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — The properties (columns) to select from the main entity. If {@code null} , all properties are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
- **Returns:** An {@link Optional} containing the entity with selected properties
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
##### gett(...) -> T
- **Signature:** `@Override @Beta default T gett(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID and loads the specified join entity class, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID and loads the specified join entity class, returning {@code null} if not found.
  - It returns {@code null} if the entity is not found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get a user with orders loaded User user = userDao.gett(123L, Order.class); if (user != null) { List<Order> orders = user.getOrders(); // Orders are already loaded } } </pre>
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `joinEntitiesToLoad` (`Class<?>`) — The class of the join entities to load
- **Returns:** The entity with loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default T gett(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with the option to load all join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with the option to load all join entities, returning {@code null} if not found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get a complete user object graph User fullUser = userDao.gett(123L, true); if (fullUser != null) { // All relationships are loaded } // Get just the user without relationships User userOnly = userDao.gett(123L, false); } </pre>
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `includeAllJoinEntities` (`boolean`) — If {@code true} , loads all mapped join entities
- **Returns:** The entity, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default T gett(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with specific properties and loads the specified join entity, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with specific properties and loads the specified join entity, returning {@code null} if not found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get essential user data with orders User user = userDao.gett(123L, Arrays.asList("id", "name", "email"), Order.class); if (user != null) { // Process user with orders } } </pre>
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — The class of the join entities to load
- **Returns:** The entity with selected properties and loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default T gett(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with specific properties and loads multiple join entity types, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with specific properties and loads multiple join entity types, returning {@code null} if not found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with specific fields and multiple relationships User user = userDao.gett(123L, Arrays.asList("id", "name", "email", "createdDate"), Arrays.asList(Order.class, Address.class, Preference.class)); if (user != null) { // User has limited fields but all specified relationships are loaded List<Order> orders = user.getOrders(); List<Address> addresses = user.getAddresses(); } } </pre>
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — Collection of join entity classes to load
- **Returns:** The entity with selected properties and loaded join entities, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation
- **Signature:** `@Override @Beta default T gett(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Retrieves an entity by its ID with specific properties and optionally loads all join entities, returning {@code null} if not found.
- **Contract:**
  - Retrieves an entity by its ID with specific properties and optionally loads all join entities, returning {@code null} if not found.
  - </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get minimal user data but with all relationships User user = userDao.gett(123L, Arrays.asList("id", "name"), // Only these fields true); // But load all join entities if (user != null) { // Process user with all relationships } // Get complete user data without any relationships User userOnly = userDao.gett(123L, {@code null}, // All fields false); // No join entities } </pre>
- **Parameters:**
  - `id` (`long`) — The primary key value of the entity to retrieve
  - `selectPropNames` (`Collection<String>`) — the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — If {@code true} , loads all mapped join entities
- **Returns:** The entity with selected properties, or {@code null} if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found by the specified {@code id}
  - `com.landawn.abacus.exception.UncheckedSQLException` — If any SQL error occurs during the operation

### Interface UncheckedDao (com.landawn.abacus.jdbc.dao.UncheckedDao)
Interface for an unchecked Data Access Object (DAO) that extends the base DAO interface.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### save(...) -> void
- **Signature:** `@Override void save(final T entityToSave) throws UncheckedSQLException`
- **Summary:** Saves the specified entity to the database.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to save
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void save(final T entityToSave, final Collection<String> propNamesToSave) throws UncheckedSQLException`
- **Summary:** Saves the specified entity with only the specified properties.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to save
  - `propNamesToSave` (`Collection<String>`) — the properties to save, or {@code null} to save all properties
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void save(final String namedInsertSql, final T entityToSave) throws UncheckedSQLException`
- **Summary:** Saves the entity using a named insert SQL statement.
- **Contract:**
  - The SQL statement should contain named parameters that will be populated from the entity properties.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL statement
  - `entityToSave` (`T`) — the entity to save
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### batchSave(...) -> void
- **Signature:** `@Override default void batchSave(final Collection<? extends T> entitiesToSave) throws UncheckedSQLException`
- **Summary:** Batch saves the specified entities to the database using the default batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to save
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** CrudDao#batchInsert(Collection)
- **Signature:** `@Override void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch saves the specified entities to the database using the specified batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to save
  - `batchSize` (`int`) — the size of each batch
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** CrudDao#batchInsert(Collection)
- **Signature:** `@Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws UncheckedSQLException`
- **Summary:** Batch saves the specified entities with only the specified properties using the default batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to save
  - `propNamesToSave` (`Collection<String>`) — the properties to save for each entity
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** CrudDao#batchInsert(Collection)
- **Signature:** `@Override void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch saves the specified entities with only the specified properties using the specified batch size.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to save
  - `propNamesToSave` (`Collection<String>`) — the properties to save for each entity
  - `batchSize` (`int`) — the size of each batch
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** CrudDao#batchInsert(Collection)
- **Signature:** `@Beta @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws UncheckedSQLException`
- **Summary:** Batch saves entities using a named insert SQL statement with the default batch size.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL statement
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to save
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** CrudDao#batchInsert(Collection)
- **Signature:** `@Beta @Override void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws UncheckedSQLException`
- **Summary:** Batch saves entities using a named insert SQL statement with the specified batch size.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL statement
  - `entitiesToSave` (`Collection<? extends T>`) — the collection of entities to save
  - `batchSize` (`int`) — the size of each batch
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** CrudDao#batchInsert(Collection)
##### exists(...) -> boolean
- **Signature:** `@Override boolean exists(final Condition cond) throws UncheckedSQLException`
- **Summary:** Checks if any records exist that match the specified condition.
- **Contract:**
  - Checks if any records exist that match the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
- **Returns:** {@code true} if at least one record is found, {@code false} otherwise
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#exists()
##### notExists(...) -> boolean
- **Signature:** `@Beta @Override default boolean notExists(final Condition cond) throws UncheckedSQLException`
- **Summary:** Checks if no records exist that match the specified condition.
- **Contract:**
  - Checks if no records exist that match the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
- **Returns:** {@code true} if no records are found, {@code false} if at least one record exists
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#notExists()
##### count(...) -> int
- **Signature:** `@Override int count(final Condition cond) throws UncheckedSQLException`
- **Summary:** Counts the number of records that match the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
- **Returns:** the count of matching records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### findFirst(...) -> Optional<T>
- **Signature:** `@Override Optional<T> findFirst(final Condition cond) throws UncheckedSQLException`
- **Summary:** Finds and returns the first record that matches the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the first matching record, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findFirst(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Finds the first record matching the condition and maps it using the provided row mapper.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result set row to the desired type
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findFirst(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Finds the first record matching the condition and maps it using the provided bi-row mapper.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map the result set row with column labels
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override Optional<T> findFirst(final Collection<String> selectPropNames, final Condition cond) throws UncheckedSQLException`
- **Summary:** Finds the first record matching the condition, selecting only the specified properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the first matching record, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Finds the first record matching the condition with selected properties and maps it using the row mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result set row
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Finds the first record matching the condition with selected properties and maps it using the bi-row mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map the result set row with column labels
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### findOnlyOne(...) -> Optional<T>
- **Signature:** `@Override Optional<T> findOnlyOne(final Condition cond) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one record matching the condition.
- **Contract:**
  - Throws an exception if multiple records are found.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the single matching record, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one record matching the condition and maps it using the row mapper.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result set row
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one record matching the condition and maps it using the bi-row mapper.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map the result set row with column labels
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Condition cond) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one record matching the condition, selecting only the specified properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the single matching record, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one record with selected properties and maps it using the row mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the result set row
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one record with selected properties and maps it using the bi-row mapper.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map the result set row with column labels
- **Returns:** an Optional containing the mapped result, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### queryForBoolean(...) -> OptionalBoolean
- **Signature:** `@Override OptionalBoolean queryForBoolean(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalBoolean} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalBoolean} describing the value in the first row/column if it exists.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean("isActive", Filters.eq("id", 1)); if (isActive.isPresent() && isActive.getAsBoolean()) { // User is active } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalBoolean containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForBoolean()
##### queryForChar(...) -> OptionalChar
- **Signature:** `@Override OptionalChar queryForChar(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalChar} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalChar} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalChar containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForChar()
##### queryForByte(...) -> OptionalByte
- **Signature:** `@Override OptionalByte queryForByte(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalByte} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalByte} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalByte containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForByte()
##### queryForShort(...) -> OptionalShort
- **Signature:** `@Override OptionalShort queryForShort(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalShort} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalShort} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalShort containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForShort()
##### queryForInt(...) -> OptionalInt
- **Signature:** `@Override OptionalInt queryForInt(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalInt} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalInt} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalInt containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForInt()
##### queryForLong(...) -> OptionalLong
- **Signature:** `@Override OptionalLong queryForLong(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalLong} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalLong} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalLong containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForLong()
##### queryForFloat(...) -> OptionalFloat
- **Signature:** `@Override OptionalFloat queryForFloat(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalFloat} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalFloat} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalFloat containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForFloat()
##### queryForDouble(...) -> OptionalDouble
- **Signature:** `@Override OptionalDouble queryForDouble(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns an {@code OptionalDouble} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code OptionalDouble} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** an OptionalDouble containing the value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForDouble()
##### queryForString(...) -> Nullable<String>
- **Signature:** `@Override Nullable<String> queryForString(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<String>} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns a {@code Nullable<String>} describing the value in the first row/column if it exists.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForString("email", Filters.eq("username", "john_doe")); if (email.isPresent()) { sendEmail(email.get()); } } </pre>
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** a Nullable containing the String value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForString()
##### queryForDate(...) -> Nullable<java.sql.Date>
- **Signature:** `@Override Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<java.sql.Date>} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns a {@code Nullable<java.sql.Date>} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** a Nullable containing the Date value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForDate()
##### queryForTime(...) -> Nullable<java.sql.Time>
- **Signature:** `@Override Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<java.sql.Time>} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns a {@code Nullable<java.sql.Time>} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** a Nullable containing the Time value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForTime()
##### queryForTimestamp(...) -> Nullable<java.sql.Timestamp>
- **Signature:** `@Override Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<java.sql.Timestamp>} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns a {@code Nullable<java.sql.Timestamp>} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** a Nullable containing the Timestamp value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForTimestamp()
##### queryForBytes(...) -> Nullable<byte\[\]>
- **Signature:** `@Override Nullable<byte[]> queryForBytes(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<byte\[\]>} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns a {@code Nullable<byte\[\]>} describing the value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** a Nullable containing the byte array value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForBytes()
##### queryForSingleResult(...) -> Nullable<V>
- **Signature:** `@Override <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws UncheckedSQLException`
- **Summary:** Returns a {@code Nullable<V>} describing the value in the first row/column if it exists, converted to the specified target type.
- **Contract:**
  - Returns a {@code Nullable<V>} describing the value in the first row/column if it exists, converted to the specified target type.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** a Nullable containing the converted value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleResult(Class)
##### queryForSingleNonNull(...) -> Optional<V>
- **Signature:** `@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the non-null value in the first row/column if it exists.
- **Contract:**
  - Returns an {@code Optional} describing the non-null value in the first row/column if it exists.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** an Optional containing the non-null value, or empty if no match found or value is null
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleNonNull(Class)
- **Signature:** `@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the non-null value mapped by the row mapper.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the function to map the result set row
- **Returns:** an Optional containing the non-null mapped value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForSingleNonNull(Class)
##### queryForUniqueResult(...) -> Nullable<V>
- **Signature:** `@Override <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Returns a {@code Nullable} describing the value in the first row/column if it exists.
- **Contract:**
  - Returns a {@code Nullable} describing the value in the first row/column if it exists.
  - Throws {@code DuplicatedResultException} if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** a Nullable containing the unique result value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueResult(Class)
##### queryForUniqueNonNull(...) -> Optional<V>
- **Signature:** `@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the unique non-null value in the first row/column.
- **Contract:**
  - Throws {@code DuplicatedResultException} if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `targetValueType` (`Class<? extends V>`) — the class of the target value type
- **Returns:** an Optional containing the unique non-null value, or empty if no match found or value is null
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueNonNull(Class)
- **Signature:** `@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Returns an {@code Optional} describing the unique non-null value mapped by the row mapper.
- **Contract:**
  - Throws {@code DuplicatedResultException} if more than one record is found.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends V>`) — the function to map the result set row
- **Returns:** an Optional containing the unique non-null mapped value, or empty if no match found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **See also:** AbstractQuery#queryForUniqueNonNull(Class)
##### query(...) -> Dataset
- **Signature:** `@Override Dataset query(final Condition cond) throws UncheckedSQLException`
- **Summary:** Executes a query and returns the results as a Dataset containing all matching records.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
- **Returns:** a Dataset containing all matching records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override Dataset query(final Collection<String> selectPropNames, final Condition cond) throws UncheckedSQLException`
- **Summary:** Executes a query selecting only specified properties and returns the results as a Dataset.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
- **Returns:** a Dataset containing the selected properties of matching records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> R query(final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException`
- **Summary:** Executes a query and processes the result set using the provided result extractor.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — the function to extract results from the ResultSet
- **Returns:** the extracted result
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException`
- **Summary:** Executes a query with selected properties and processes the result set using the result extractor.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `resultExtractor` (`Jdbc.ResultExtractor<? extends R>`) — the function to extract results from the ResultSet
- **Returns:** the extracted result
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> R query(final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException`
- **Summary:** Executes a query and processes the result set using the bi-result extractor which receives column labels.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — the function to extract results with column labels
- **Returns:** the extracted result
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException`
- **Summary:** Executes a query with selected properties and processes using the bi-result extractor.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `resultExtractor` (`Jdbc.BiResultExtractor<? extends R>`) — the function to extract results with column labels
- **Returns:** the extracted result
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### list(...) -> List<T>
- **Signature:** `@Override List<T> list(final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a list of all entities matching the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of matching entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a list of results mapped by the provided row mapper for records matching the condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map each result set row
- **Returns:** a list of mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a list of results mapped by the bi-row mapper for records matching the condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map each result set row with column labels
- **Returns:** a list of mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a filtered list of results mapped by the row mapper for records matching the condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.RowFilter`) — the predicate to filter rows before mapping
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map filtered result set rows
- **Returns:** a list of filtered and mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a filtered list using bi-row filter and bi-row mapper for records matching the condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.BiRowFilter`) — the bi-predicate to filter rows with column labels
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map filtered rows with column labels
- **Returns:** a list of filtered and mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override List<T> list(final Collection<String> selectPropNames, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a list of entities with only selected properties for records matching the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of entities with selected properties
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a list of mapped results with selected properties for records matching the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map each result set row
- **Returns:** a list of mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a list of mapped results using bi-row mapper with selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map each row with column labels
- **Returns:** a list of mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a filtered and mapped list with selected properties for records matching the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.RowFilter`) — the predicate to filter rows before mapping
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map filtered rows
- **Returns:** a list of filtered and mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a filtered and mapped list using bi-filters and bi-mappers with selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.BiRowFilter`) — the bi-predicate to filter rows with column labels
  - `rowMapper` (`Jdbc.BiRowMapper<? extends R>`) — the function to map filtered rows with column labels
- **Returns:** a list of filtered and mapped results
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default <R> List<R> list(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException`
- **Summary:** Returns a list of values for a single property from records matching the condition.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of values for the specified property
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a list of mapped values for a single property from records matching the condition.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map the single column value
- **Returns:** a list of mapped values
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException`
- **Summary:** Returns a filtered list of mapped values for a single property from records matching the condition.
- **Parameters:**
  - `singleSelectPropName` (`String`) — the single property name to select
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.RowFilter`) — the predicate to filter rows before mapping
  - `rowMapper` (`Jdbc.RowMapper<? extends R>`) — the function to map filtered values
- **Returns:** a list of filtered and mapped values
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### forEach(...) -> void
- **Signature:** `@Override void forEach(final Condition cond, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through all records matching the condition and processes each row with the row consumer.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to process each result set row
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void forEach(final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through records using a bi-row consumer that receives column labels.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the bi-consumer to process each row with column labels
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void forEach(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through filtered records matching the condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.RowFilter`) — the predicate to filter rows
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to process filtered rows
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void forEach(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through filtered records using bi-row filter and bi-row consumer.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.BiRowFilter`) — the bi-predicate to filter rows with column labels
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the bi-consumer to process filtered rows with column labels
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through records with selected properties matching the condition.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to process each row
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through records with selected properties using a bi-row consumer.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the bi-consumer to process each row with column labels
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through filtered records with selected properties.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.RowFilter`) — the predicate to filter rows
  - `rowConsumer` (`Jdbc.RowConsumer`) — the consumer to process filtered rows
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException`
- **Summary:** Iterates through filtered records with selected properties using bi-row filter and consumer.
- **Contract:**
  - <p> <b> Usage Examples: </b> </p> <pre> {@code userDao.forEach( Arrays.asList("id", "email", "preferences"), Filters.eq("active", true), (rs, cols) -> shouldReceiveNotification(rs.getString("preferences")), (rs, cols) -> queueNotification(rs.getLong("id"), rs.getString("email")) ); } </pre>
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected, or {@code null} to select all
  - `cond` (`Condition`) — the condition to match
  - `rowFilter` (`Jdbc.BiRowFilter`) — the bi-predicate to filter rows with column labels
  - `rowConsumer` (`Jdbc.BiRowConsumer`) — the bi-consumer to process filtered rows with column labels
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### foreach(...) -> void
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void foreach(final Collection<String> selectPropNames, final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws UncheckedSQLException`
- **Summary:** Processes each record with selected properties using a consumer that receives DisposableObjArray.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected
  - `cond` (`Condition`) — the condition to match
  - `rowConsumer` (`Consumer<DisposableObjArray>`) — the consumer that receives row data as DisposableObjArray
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void foreach(final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws UncheckedSQLException`
- **Summary:** Processes each record matching the condition using a consumer that receives DisposableObjArray.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match
  - `rowConsumer` (`Consumer<DisposableObjArray>`) — the consumer that receives row data as DisposableObjArray
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### update(...) -> int
- **Signature:** `@Override default int update(final String propName, final Object propValue, final Condition cond) throws UncheckedSQLException`
- **Summary:** Updates a single property value for all records matching the condition.
- **Parameters:**
  - `propName` (`String`) — the property name to update
  - `propValue` (`Object`) — the new value for the property
  - `cond` (`Condition`) — the condition to match records to update
- **Returns:** the number of records updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int update(final Map<String, Object> updateProps, final Condition cond) throws UncheckedSQLException`
- **Summary:** Updates multiple properties for all records matching the condition.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — a map of property names to their new values
  - `cond` (`Condition`) — the condition to match records to update
- **Returns:** the number of records updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default int update(final T entity, final Condition cond) throws UncheckedSQLException`
- **Summary:** Updates all records matching the condition with values from the specified entity.
- **Parameters:**
  - `entity` (`T`) — the entity containing values to update
  - `cond` (`Condition`) — the condition to match records to update
- **Returns:** the number of records updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws UncheckedSQLException`
- **Summary:** Updates records matching the condition with specified properties from the entity.
- **Parameters:**
  - `entity` (`T`) — the entity containing values to update
  - `propNamesToUpdate` (`Collection<String>`) — the properties to update from the entity
  - `cond` (`Condition`) — the condition to match records to update
- **Returns:** the number of records updated
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### upsert(...) -> T
- **Signature:** `@Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UncheckedSQLException`
- **Summary:** Executes an upsert operation: inserts the entity if no record matches the unique properties, otherwise updates the existing record.
- **Contract:**
  - Executes an upsert operation: inserts the entity if no record matches the unique properties, otherwise updates the existing record.
- **Parameters:**
  - `entity` (`T`) — the entity to add or update
  - `uniquePropNamesForQuery` (`List<String>`) — the list of property names that uniquely identify the record
- **Returns:** the added or updated entity from the database
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default T upsert(final T entity, final Condition cond) throws UncheckedSQLException`
- **Summary:** Executes an upsert operation: inserts the entity if no record matches the condition, otherwise updates the existing record.
- **Contract:**
  - Executes an upsert operation: inserts the entity if no record matches the condition, otherwise updates the existing record.
- **Parameters:**
  - `entity` (`T`) — the entity to add or update
  - `cond` (`Condition`) — the condition to verify if the record exists
- **Returns:** the added or updated entity from the database
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### delete(...) -> int
- **Signature:** `@Override int delete(final Condition cond) throws UncheckedSQLException`
- **Summary:** Deletes all records that match the specified condition.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match records to delete
- **Returns:** the number of records deleted
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs

### Interface UncheckedJoinEntityHelper (com.landawn.abacus.jdbc.dao.UncheckedJoinEntityHelper)
The UncheckedJoinEntityHelper interface provides advanced functionality for handling entity relationships and join operations in DAOs with unchecked exceptions.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### findFirst(...) -> Optional<T>
- **Signature:** `@Override default Optional<T> findFirst(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException`
- **Summary:** Finds the first entity matching the condition and loads the specified join entity class.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default Optional<T> findFirst(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException`
- **Summary:** Finds the first entity matching the condition and loads multiple join entity classes.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default Optional<T> findFirst(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws UncheckedSQLException`
- **Summary:** Finds the first entity matching the condition and optionally loads all join entities.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the entity with join entities loaded, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### findOnlyOne(...) -> Optional<T>
- **Signature:** `@Override default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one entity matching the condition and loads the specified join entity class.
- **Contract:**
  - Throws an exception if multiple entities are found.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the unique entity with loaded join entities, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found for the specified condition
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one entity matching the condition and loads multiple join entity classes.
- **Contract:**
  - Throws an exception if multiple entities are found.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the unique entity with loaded join entities, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found for the specified condition
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws DuplicatedResultException, UncheckedSQLException`
- **Summary:** Finds exactly one entity matching the condition and optionally loads all join entities.
- **Contract:**
  - Throws an exception if multiple entities are found.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `cond` (`Condition`) — the condition to match
- **Returns:** an Optional containing the unique entity with loaded join entities, or empty if not found
- **Throws:**
  - `com.landawn.abacus.exception.DuplicatedResultException` — if more than one record is found for the specified condition
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### list(...) -> List<T>
- **Signature:** `@Beta @Override default List<T> list(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException`
- **Summary:** Lists all entities matching the condition and loads the specified join entity class for each.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Class<?>`) — the class of the join entities to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of entities with loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> list(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException`
- **Summary:** Lists all entities matching the condition and loads multiple join entity classes for each.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `joinEntitiesToLoad` (`Collection<Class<?>>`) — the collection of join entity classes to load
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of entities with loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default List<T> list(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws UncheckedSQLException`
- **Summary:** Lists all entities matching the condition and optionally loads all join entities for each.
- **Parameters:**
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected
  - `includeAllJoinEntities` (`boolean`) — if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded
  - `cond` (`Condition`) — the condition to match
- **Returns:** a list of entities with loaded join entities
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### loadJoinEntities(...) -> void
- **Signature:** `@Override default void loadJoinEntities(final T entity, final Class<?> joinEntityClass) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class for a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity to load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadJoinEntities(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class with selected properties for a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity to load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class for multiple entities in batch.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class with selected properties for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntities(final T entity, final String joinEntityPropName) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property name of a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity to load join entities for
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void loadJoinEntities(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property name with selected properties for a single entity.
- **Contract:**
  - </p> <p> The implementation should handle both collection-type properties (List, Set, etc.) and single-entity properties.
- **Parameters:**
  - `entity` (`T`) — the entity to load join entities for. Must not be {@code null}
  - `joinEntityPropName` (`String`) — the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. This parameter is useful for performance optimization when only specific fields are needed
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs (wraps {@link java.sql.SQLException} )
- **Signature:** `@Override default void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property name for multiple entities in batch.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load join entities for
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property name with selected properties for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load join entities for. Can be empty but not {@code null} . If empty, this method returns immediately
  - `joinEntityPropName` (`String`) — the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. Specifying only needed properties can significantly improve query performance and reduce memory usage
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs (wraps {@link java.sql.SQLException} )
- **Performance:** </p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, this method executes O(1) queries instead of O(N) </li> <li> Large collections may be automatically batched to prevent excessive memory usage </li> <li> Selecting fewer properties via {@code selectPropNames} can significantly improve performance </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = userDao.batchGet(userIds); // Load address property with selected fields for all users userDao.loadJoinEntities( users, "addresses", Arrays.asList("street", "city", "country", "isPrimary") ); // Use in stream operations without try-catch users.stream() .peek(u -> userDao.loadJoinEntities(u, "orders", null)) .filter(u -> u.getOrders().size() > 5) .collect(Collectors.toList()); } </pre>
- **Signature:** `@Override default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities for multiple property names of a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity to load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads join entities for multiple property names of a single entity, optionally in parallel.
- **Parameters:**
  - `entity` (`T`) — the entity to load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of join entities to load
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads join entities for multiple property names using a custom executor for parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity to load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of join entities to load
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities for multiple property names for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads join entities for multiple property names for multiple entities, optionally in parallel.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of join entities to load
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads join entities for multiple property names for multiple entities using a custom executor.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of join entities to load
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### loadAllJoinEntities(...) -> void
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadAllJoinEntities(final T entity) throws UncheckedSQLException`
- **Summary:** Loads all join entities defined in the entity class for a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity to load all join entities for
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadAllJoinEntities(final T entity, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads all join entities for a single entity, optionally in parallel.
- **Parameters:**
  - `entity` (`T`) — the entity to load all join entities for
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadAllJoinEntities(final T entity, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads all join entities for a single entity using a custom executor.
- **Parameters:**
  - `entity` (`T`) — the entity to load all join entities for
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadAllJoinEntities(final Collection<T> entities) throws UncheckedSQLException`
- **Summary:** Loads all join entities for multiple entities in batch.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load all join entities for
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads all join entities for multiple entities, optionally in parallel.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load all join entities for
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadAllJoinEntities(final Collection<T> entities, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads all join entities for multiple entities using a custom executor.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to load all join entities for
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### loadJoinEntitiesIfNull(...) -> void
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class only if they are currently {@code null} .
- **Contract:**
  - Loads join entities of the specified class only if they are currently {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Only load orders if not already loaded userDao.loadJoinEntitiesIfNull(user, Order.class); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class with selected properties only if they are currently {@code null} .
- **Contract:**
  - Loads join entities of the specified class with selected properties only if they are currently {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getPartiallyLoadedUser(); // Load profile with specific fields if not already loaded userDao.loadJoinEntitiesIfNull( user, UserProfile.class, Arrays.asList("bio", "avatarUrl", "preferences") ); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class for multiple entities only where they are {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities of the specified class with selected properties for multiple entities only where they are {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load join entities for
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property only if it is currently {@code null} .
- **Contract:**
  - Loads join entities for a specific property only if it is currently {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getUser(); // Only load profile if user.getProfile() is null userDao.loadJoinEntitiesIfNull(user, "profile"); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load join entities for
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property with selected fields only if the property is {@code null} .
- **Contract:**
  - Loads join entities for a specific property with selected fields only if the property is {@code null} .
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getUser(); // Load addresses with specific fields if not already loaded userDao.loadJoinEntitiesIfNull( user, "addresses", Arrays.asList("street", "city", "postalCode") ); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load join entities for
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property for multiple entities only where the property is {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load join entities for
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException`
- **Summary:** Loads join entities for a specific property with selected fields for multiple entities only where {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load join entities for
  - `joinEntityPropName` (`String`) — the property name of the join entities to load
  - `selectPropNames` (`Collection<String>`) — the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames) throws UncheckedSQLException`
- **Summary:** Loads multiple join properties only if they are {@code null} for a single entity.
- **Contract:**
  - Loads multiple join properties only if they are {@code null} for a single entity.
  - <p> <b> Usage Examples: </b> </p> <pre> {@code User user = getPartialUser(); // Load multiple properties if not already loaded userDao.loadJoinEntitiesIfNull( user, Arrays.asList("orders", "profile", "preferences") ); } </pre>
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads multiple join properties only if they are {@code null} , optionally in parallel.
- **Contract:**
  - Loads multiple join properties only if they are {@code null} , optionally in parallel.
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads multiple join properties only if they are {@code null} using a custom executor.
- **Contract:**
  - Loads multiple join properties only if they are {@code null} using a custom executor.
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UncheckedSQLException`
- **Summary:** Loads multiple join properties for multiple entities only where they are {@code null} .
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads multiple join properties for multiple entities only where {@code null} , optionally in parallel.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads multiple join properties for multiple entities only where {@code null} using a custom executor.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load join entities for
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to load
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadJoinEntitiesIfNull(final T entity) throws UncheckedSQLException`
- **Summary:** Loads all join entities only if they are {@code null} for a single entity.
- **Contract:**
  - Loads all join entities only if they are {@code null} for a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load all join entities for
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntitiesIfNull(final T entity, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads all join entities only if they are {@code null} , optionally in parallel.
- **Contract:**
  - Loads all join entities only if they are {@code null} , optionally in parallel.
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load all join entities for
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntitiesIfNull(final T entity, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads all join entities only if they are {@code null} using a custom executor.
- **Contract:**
  - Loads all join entities only if they are {@code null} using a custom executor.
- **Parameters:**
  - `entity` (`T`) — the entity to conditionally load all join entities for
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default void loadJoinEntitiesIfNull(final Collection<T> entities) throws UncheckedSQLException`
- **Summary:** Loads all join entities only if they are {@code null} for multiple entities.
- **Contract:**
  - Loads all join entities only if they are {@code null} for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load all join entities for
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Loads all join entities only if they are {@code null} for multiple entities, optionally in parallel.
- **Contract:**
  - Loads all join entities only if they are {@code null} for multiple entities, optionally in parallel.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load all join entities for
  - `inParallel` (`boolean`) — if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Executor executor) throws UncheckedSQLException`
- **Summary:** Loads all join entities only if they are {@code null} for multiple entities using a custom executor.
- **Contract:**
  - Loads all join entities only if they are {@code null} for multiple entities using a custom executor.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities to conditionally load all join entities for
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### deleteJoinEntities(...) -> int
- **Signature:** `@SuppressWarnings("deprecation") @Override default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws UncheckedSQLException`
- **Summary:** Deletes all join entities of the specified class related to the given entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityClass` (`Class<?>`) — the class of join entities to delete
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UncheckedSQLException`
- **Summary:** Deletes all join entities of the specified class for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityClass` (`Class<?>`) — the class of join entities to delete
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override int deleteJoinEntities(final T entity, final String joinEntityPropName) throws UncheckedSQLException`
- **Summary:** Deletes join entities for a specific property name of a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted. Must not be {@code null}
  - `joinEntityPropName` (`String`) — the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
- **Returns:** the total count of deleted records. Returns 0 if no matching records were found
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs (wraps {@link java.sql.SQLException} )
- **Signature:** `@Override int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UncheckedSQLException`
- **Summary:** Deletes join entities for a specific property name for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted. Can be empty but not {@code null} . If empty, this method returns 0 immediately
  - `joinEntityPropName` (`String`) — the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}
- **Returns:** the total count of deleted records across all parent entities. Returns 0 if no matching records were found or if {@code entities} is empty
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs (wraps {@link java.sql.SQLException} )
- **Performance:** </p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, executes O(1) or O(N/batch_size) DELETE statements instead of O(N) </li> <li> Much more efficient than deleting join entities one parent at a time </li> <li> The actual number of deleted records may be less than or greater than the number of parent entities </li> </ul> <p> Important notes: </p> <ul> <li> This operation does NOT modify the in-memory join properties of the entities </li> <li> All deletions are permanent unless executed within a transaction </li> <li> For transactional deletion of multiple properties, use {@link #deleteJoinEntities(Collection, Collection)} </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = getDeactivatedUsers(); // Delete all payment methods for these users int totalDeleted = userDao.deleteJoinEntities(users, "paymentMethods"); // Use in stream context int deletedOrders = userDao.list(Filters.eq("status", "INACTIVE")) .stream() .collect(Collectors.collectingAndThen( Collectors.toList(), list -> userDao.deleteJoinEntities(list, "orders") )); } </pre>
- **Signature:** `@Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UncheckedSQLException`
- **Summary:** Deletes join entities for multiple property names of a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException`
- **Summary:** Deletes join entities for multiple property names of a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Deletes join entities for multiple property names of a single entity in parallel (deprecated).
- **Parameters:**
  - `entity` (`T`) — the entity whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UncheckedSQLException`
- **Summary:** Deletes join entities for multiple property names for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Deletes join entities for multiple property names for multiple entities in parallel (deprecated).
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException`
- **Summary:** Deletes join entities for multiple property names for multiple entities using a custom executor (deprecated).
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the property names of the join entities to delete
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
##### deleteAllJoinEntities(...) -> int
- **Signature:** `@SuppressWarnings("deprecation") @Override default int deleteAllJoinEntities(final T entity) throws UncheckedSQLException`
- **Summary:** Deletes all join entities for a single entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose all join entities should be deleted
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Deletes all join entities for a single entity, optionally in parallel (deprecated).
- **Parameters:**
  - `entity` (`T`) — the entity whose all join entities should be deleted
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteAllJoinEntities(final T entity, final Executor executor) throws UncheckedSQLException`
- **Summary:** Deletes all join entities for a single entity using a custom executor (deprecated).
- **Parameters:**
  - `entity` (`T`) — the entity whose all join entities should be deleted
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@SuppressWarnings("deprecation") @Override default int deleteAllJoinEntities(final Collection<T> entities) throws UncheckedSQLException`
- **Summary:** Deletes all join entities for multiple entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all join entities should be deleted
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UncheckedSQLException`
- **Summary:** Deletes all join entities for multiple entities, optionally in parallel (deprecated).
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all join entities should be deleted
  - `inParallel` (`boolean`) — if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs
- **Signature:** `@Beta @Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws UncheckedSQLException`
- **Summary:** Deletes all join entities for multiple entities using a custom executor (deprecated).
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all join entities should be deleted
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** the total count of deleted records
- **Throws:**
  - `com.landawn.abacus.exception.UncheckedSQLException` — if a database access error occurs

### Interface UncheckedNoUpdateCrudDao (com.landawn.abacus.jdbc.dao.UncheckedNoUpdateCrudDao)
A specialized CRUD DAO interface that disables update and delete operations while allowing read and insert operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### update(...) -> int
- **Signature:** `@Deprecated @Override default int update(final T entityToUpdate) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entityToUpdate` (`T`) — The entity to update (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entityToUpdate` (`T`) — The entity containing updated values (operation will fail)
  - `propNamesToUpdate` (`Collection<String>`) — Collection of property names to update (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
- **Signature:** `@Override @Deprecated default int update(final String propName, final Object propValue, final ID id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `propName` (`String`) — The name of the property to update (operation will fail)
  - `propValue` (`Object`) — The new value for the property (operation will fail)
  - `id` (`ID`) — The ID of the entity to update (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final Map<String, Object> updateProps, final ID id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — Map of property names to their new values (operation will fail)
  - `id` (`ID`) — The ID of the entity to update (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
##### batchUpdate(...) -> int
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to update (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to update (operation will fail)
  - `batchSize` (`int`) — The batch size for the operation (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Contract:**
  - Consider using a different DAO type if update operations are required for your use case.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to update (operation will fail)
  - `propNamesToUpdate` (`Collection<String>`) — Properties to update in each entity (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to update (operation will fail)
  - `propNamesToUpdate` (`Collection<String>`) — Properties to update in each entity (operation will fail)
  - `batchSize` (`int`) — The batch size for the operation (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as update operations are not supported
##### upsert(...) -> T
- **Signature:** `@Deprecated @Override default T upsert(final T entity) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entity` (`T`) — The entity to insert or update (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as upsert operations are not supported
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entity` (`T`) — The entity to insert or update (operation will fail)
  - `uniquePropNamesForQuery` (`List<String>`) — Property names used to check for existing records (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as upsert operations are not supported
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entity` (`T`) — The entity to insert or update (operation will fail)
  - `cond` (`Condition`) — Condition to check for existing records (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as upsert operations are not supported
##### batchUpsert(...) -> List<T>
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to upsert (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as batch upsert operations are not supported
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to upsert (operation will fail)
  - `batchSize` (`int`) — The batch size for the operation (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as batch upsert operations are not supported
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to upsert (operation will fail)
  - `uniquePropNamesForQuery` (`List<String>`) — Property names for conflict detection (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as batch upsert operations are not supported
- **Signature:** `@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — Collection of entities to upsert (operation will fail)
  - `uniquePropNamesForQuery` (`List<String>`) — Property names for conflict detection (operation will fail)
  - `batchSize` (`int`) — The batch size for the operation (operation will fail)
- **Returns:** Never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — Always thrown as batch upsert operations are not supported
##### delete(...) -> int
- **Signature:** `@Deprecated @Override default int delete(final T entity) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to delete (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported
##### deleteById(...) -> int
- **Signature:** `@Deprecated @Override default int deleteById(final ID id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `id` (`ID`) — the ID of the entity to delete (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported
##### batchDelete(...) -> int
- **Signature:** `@Deprecated @Override default int batchDelete(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — collection of entities to delete (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported
- **Signature:** `@Deprecated @Override default int batchDelete(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — collection of entities to delete (operation will fail)
  - `batchSize` (`int`) — the batch size for the operation (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported
##### batchDeleteByIds(...) -> int
- **Signature:** `@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — collection of IDs to delete (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported
- **Signature:** `@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `ids` (`Collection<? extends ID>`) — collection of IDs to delete (operation will fail)
  - `batchSize` (`int`) — the batch size for the operation (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported

### Interface UncheckedNoUpdateCrudDaoL (com.landawn.abacus.jdbc.dao.UncheckedNoUpdateCrudDaoL)
A no-update CRUD DAO interface that uses {@code Long} as the ID type with unchecked exception handling.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### update(...) -> int
- **Signature:** `@Deprecated @Override default int update(final String propName, final Object propValue, final long id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `propName` (`String`) — the property name to update (operation will fail)
  - `propValue` (`Object`) — the new value (operation will fail)
  - `id` (`long`) — the entity ID as primitive long (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final Map<String, Object> updateProps, final long id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — the properties to update (operation will fail)
  - `id` (`long`) — the entity ID as primitive long (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
##### deleteById(...) -> int
- **Signature:** `@Deprecated @Override default int deleteById(final long id) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a no-update DAO.
- **Parameters:**
  - `id` (`long`) — the entity ID as primitive long (operation will fail)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported

### Interface UncheckedNoUpdateDao (com.landawn.abacus.jdbc.dao.UncheckedNoUpdateDao)
Interface for an unchecked Data Access Object (DAO) that disables update and delete operations while allowing read and insert operations.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### update(...) -> int
- **Signature:** `@Override @Deprecated default int update(final String propName, final Object propValue, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `propName` (`String`) — the property name to update (ignored)
  - `propValue` (`Object`) — the new value (ignored)
  - `cond` (`Condition`) — the condition to match records (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final Map<String, Object> updateProps, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `updateProps` (`Map<String, Object>`) — the properties to update (ignored)
  - `cond` (`Condition`) — the condition to match records (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final T entity, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity containing values to update (ignored)
  - `cond` (`Condition`) — the condition to match records (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity containing values to update (ignored)
  - `propNamesToUpdate` (`Collection<String>`) — the properties to update (ignored)
  - `cond` (`Condition`) — the condition to match records (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
##### upsert(...) -> T
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to upsert (ignored)
  - `uniquePropNamesForQuery` (`List<String>`) — the unique properties for query (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
- **Signature:** `@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `entity` (`T`) — the entity to upsert (ignored)
  - `cond` (`Condition`) — the condition to verify existence (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as update operations are not supported
##### delete(...) -> int
- **Signature:** `@Deprecated @Override default int delete(final Condition cond) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in no-update DAO.
- **Parameters:**
  - `cond` (`Condition`) — the condition to match records to delete (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as delete operations are not supported

### Interface UncheckedReadOnlyCrudDao (com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudDao)
A read-only CRUD DAO interface that provides only query operations without any insert, update, or delete capabilities.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### insert(...) -> ID
- **Signature:** `@Deprecated @Override default ID insert(final T entityToInsert) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a read-only DAO.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a read-only DAO.
- **Parameters:**
  - `entityToInsert` (`T`) — the entity to insert (ignored)
  - `propNamesToInsert` (`Collection<String>`) — the properties to insert (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default ID insert(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in a read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL (ignored)
  - `entityToSave` (`T`) — the entity to save (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
##### batchInsert(...) -> List<ID>
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the entities to insert (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the entities to insert (ignored)
  - `batchSize` (`int`) — the batch size (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the entities to insert (ignored)
  - `propNamesToInsert` (`Collection<String>`) — the properties to insert (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entities` (`Collection<? extends T>`) — the entities to insert (ignored)
  - `propNamesToInsert` (`Collection<String>`) — the properties to insert (ignored)
  - `batchSize` (`int`) — the batch size (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL (ignored)
  - `entities` (`Collection<? extends T>`) — the entities to insert (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported
- **Signature:** `@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL (ignored)
  - `entities` (`Collection<? extends T>`) — the entities to insert (ignored)
  - `batchSize` (`int`) — the batch size (ignored)
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as insert operations are not supported

### Interface UncheckedReadOnlyCrudDaoL (com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudDaoL)
A read-only CRUD DAO interface that uses {@code Long} as the ID type with unchecked exception handling.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Interface UncheckedReadOnlyCrudJoinEntityHelper (com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudJoinEntityHelper)
A specialized interface that combines read-only operations with join entity support for CRUD DAOs with unchecked exceptions.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Interface UncheckedReadOnlyCrudJoinEntityHelperL (com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudJoinEntityHelperL)
A read-only CRUD DAO interface with join entity helper capabilities that uses primitive {@code long} for ID operations and throws unchecked exceptions.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
- (none)

### Interface UncheckedReadOnlyDao (com.landawn.abacus.jdbc.dao.UncheckedReadOnlyDao)
A read-only DAO interface that provides only query operations without any write capabilities.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### save(...) -> void
- **Signature:** `@Deprecated @Override default void save(final T entityToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to save (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void save(final T entityToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entityToSave` (`T`) — the entity to save (ignored)
  - `propNamesToSave` (`Collection<String>`) — the properties to save (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void save(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL (ignored)
  - `entityToSave` (`T`) — the entity to save (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
##### batchSave(...) -> void
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the entities to save (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the entities to save (ignored)
  - `batchSize` (`int`) — the batch size (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the entities to save (ignored)
  - `propNamesToSave` (`Collection<String>`) — the properties to save (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `entitiesToSave` (`Collection<? extends T>`) — the entities to save (ignored)
  - `propNamesToSave` (`Collection<String>`) — the properties to save (ignored)
  - `batchSize` (`int`) — the batch size (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL (ignored)
  - `entitiesToSave` (`Collection<? extends T>`) — the entities to save (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported
- **Signature:** `@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException`
- **Summary:** This operation is not supported in read-only DAO.
- **Parameters:**
  - `namedInsertSql` (`String`) — the named insert SQL (ignored)
  - `entitiesToSave` (`Collection<? extends T>`) — the entities to save (ignored)
  - `batchSize` (`int`) — the batch size (ignored)
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as save operations are not supported

### Interface UncheckedReadOnlyJoinEntityHelper (com.landawn.abacus.jdbc.dao.UncheckedReadOnlyJoinEntityHelper)
A read-only interface for managing join entity relationships in database operations without checked exceptions.

**Thread-safety:** unspecified
**Nullability:** unspecified

#### Public Constructors
- (none)

#### Public Static Methods
- (none)

#### Public Instance Methods
##### deleteJoinEntities(...) -> int
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws UnsupportedOperationException`
- **Summary:** Attempts to delete join entities of a specific class related to the given entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose related join entities should be deleted
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UnsupportedOperationException`
- **Summary:** Attempts to delete join entities of a specific class related to the given collection of entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose related join entities should be deleted
  - `joinEntityClass` (`Class<?>`) — the class of the join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final String joinEntityPropName) throws UnsupportedOperationException`
- **Summary:** Attempts to delete join entities identified by property name related to the given entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose related join entities should be deleted
  - `joinEntityPropName` (`String`) — the property name identifying the join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UnsupportedOperationException`
- **Summary:** Attempts to delete join entities identified by property name related to the given collection of entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose related join entities should be deleted
  - `joinEntityPropName` (`String`) — the property name identifying the join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException`
- **Summary:** Attempts to delete multiple types of join entities identified by property names related to the given entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose related join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names identifying the join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** Attempts to delete multiple types of join entities with optional parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity whose related join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names identifying the join entities to delete
  - `inParallel` (`boolean`) — whether to execute the deletions in parallel
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException`
- **Summary:** Attempts to delete multiple types of join entities using a custom executor.
- **Parameters:**
  - `entity` (`T`) — the entity whose related join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names identifying the join entities to delete
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException`
- **Summary:** Attempts to delete multiple types of join entities for a collection of entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose related join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names identifying the join entities to delete
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** Attempts to delete multiple types of join entities for a collection of entities with optional parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose related join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names identifying the join entities to delete
  - `inParallel` (`boolean`) — whether to execute the deletions in parallel
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException`
- **Summary:** Attempts to delete multiple types of join entities for a collection of entities using a custom executor.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose related join entities should be deleted
  - `joinEntityPropNames` (`Collection<String>`) — the collection of property names identifying the join entities to delete
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
##### deleteAllJoinEntities(...) -> int
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final T entity) throws UnsupportedOperationException`
- **Summary:** Attempts to delete all join entities related to the given entity.
- **Parameters:**
  - `entity` (`T`) — the entity whose all related join entities should be deleted
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** Attempts to delete all join entities related to the given entity with optional parallel execution.
- **Parameters:**
  - `entity` (`T`) — the entity whose all related join entities should be deleted
  - `inParallel` (`boolean`) — whether to execute the deletions in parallel
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final T entity, final Executor executor) throws UnsupportedOperationException`
- **Summary:** Attempts to delete all join entities related to the given entity using a custom executor.
- **Parameters:**
  - `entity` (`T`) — the entity whose all related join entities should be deleted
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities) throws UnsupportedOperationException`
- **Summary:** Attempts to delete all join entities related to the given collection of entities.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all related join entities should be deleted
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UnsupportedOperationException`
- **Summary:** Attempts to delete all join entities related to the given collection of entities with optional parallel execution.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all related join entities should be deleted
  - `inParallel` (`boolean`) — whether to execute the deletions in parallel
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface
- **Signature:** `@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws UnsupportedOperationException`
- **Summary:** Attempts to delete all join entities related to the given collection of entities using a custom executor.
- **Parameters:**
  - `entities` (`Collection<T>`) — the collection of entities whose all related join entities should be deleted
  - `executor` (`Executor`) — the {@code Executor} to use for parallel execution
- **Returns:** never returns normally
- **Throws:**
  - `java.lang.UnsupportedOperationException` — always thrown as this is a read-only interface

