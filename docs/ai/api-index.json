{
  "library": {
    "name": "abacus-jdbc",
    "version": "4.3.1",
    "generated_at": "2026-02-08",
    "java_target": "17",
    "source": {
      "git_sha": "unknown"
    }
  },
  "packages": [
    {
      "name": "com.landawn.abacus.jdbc",
      "types": [
        {
          "fqn": "com.landawn.abacus.jdbc.AbstractQuery",
          "name": "AbstractQuery",
          "kind": "class",
          "modifiers": [
            "public",
            "abstract"
          ],
          "javadoc_summary": "Abstract base class for JDBC query operations that provides a fluent API for executing SQL queries and updates with PreparedStatement.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "Stmt",
              "bounds": [
                "PreparedStatement"
              ]
            },
            {
              "name": "This",
              "bounds": [
                "AbstractQuery<Stmt, This>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "closeAfterExecution",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This closeAfterExecution(final boolean closeAfterExecution) throws IllegalStateException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "closeAfterExecution",
                  "type": "boolean",
                  "javadoc": "If {@code true} , the statement will be closed after execution. Default is {@code true} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if the query is already closed"
                }
              ],
              "javadoc_summary": "Sets whether the PreparedStatement should be closed after execution.",
              "contract": [
                "Sets whether the PreparedStatement should be closed after execution.",
                "<p> Set to {@code false} if you want to reuse the statement for multiple executions, but ensure you manually close it when done."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "onClose",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"hiding\") public This onClose(final Runnable closeHandler) throws IllegalArgumentException, IllegalStateException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "closeHandler",
                  "type": "Runnable",
                  "javadoc": "A task to execute after this {@code Query} is closed",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if closeHandler is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is already closed"
                }
              ],
              "javadoc_summary": "Registers a callback to be executed when this query is closed.",
              "contract": [
                "Registers a callback to be executed when this query is closed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNull(final int parameterIndex, final int sqlType) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set to {@code null} , starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a SQL NULL value for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNull(final int parameterIndex, final int sqlType, final String typeName) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set to {@code null} , starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "typeName",
                  "type": "String",
                  "javadoc": "the fully-qualified name of an SQL user-defined type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a SQL NULL value for the specified parameter with a type name.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBoolean(final int parameterIndex, final boolean x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "boolean",
                  "javadoc": "the boolean value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a boolean parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBoolean(final int parameterIndex, final Boolean x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Boolean",
                  "javadoc": "the Boolean value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Boolean parameter value, handling {@code null} values.",
              "contract": [
                "If the value is {@code null} , sets the parameter to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBoolean(final int parameterIndex, final Boolean x, final boolean defaultValueForNull) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Boolean",
                  "javadoc": "the Boolean value to set, or {@code null} to use the default value",
                  "nullability": "unspecified"
                },
                {
                  "name": "defaultValueForNull",
                  "type": "boolean",
                  "javadoc": "the boolean value to use if {@code x} is {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Boolean parameter value with a default value for {@code null} .",
              "contract": [
                "If the value is {@code null} , uses the specified default value instead of SQL NULL.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setBoolean(1, nullableBoolean, false); // use false if null } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setByte(final int parameterIndex, final byte x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "byte",
                  "javadoc": "the byte value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a byte parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setByte(final int parameterIndex, final Byte x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Byte",
                  "javadoc": "the Byte value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Byte parameter value, handling {@code null} values.",
              "contract": [
                "If the value is {@code null} , sets the parameter to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setByte(final int parameterIndex, final Byte x, final byte defaultValueForNull) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Byte",
                  "javadoc": "the Byte value to set, or {@code null} to use the default value",
                  "nullability": "unspecified"
                },
                {
                  "name": "defaultValueForNull",
                  "type": "byte",
                  "javadoc": "the byte value to use if {@code x} is {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Byte parameter value with a default value for {@code null} .",
              "contract": [
                "If the value is {@code null} , uses the specified default value instead of SQL NULL.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setByte(1, nullableByte, (byte)0); // use 0 if null } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setShort(final int parameterIndex, final short x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "short",
                  "javadoc": "the short value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a short parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setShort(final int parameterIndex, final Short x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Short",
                  "javadoc": "the Short value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Short parameter value, handling {@code null} values.",
              "contract": [
                "If the value is {@code null} , sets the parameter to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setShort(final int parameterIndex, final Short x, final short defaultValueForNull) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Short",
                  "javadoc": "the Short value to set, or {@code null} to use the default value",
                  "nullability": "unspecified"
                },
                {
                  "name": "defaultValueForNull",
                  "type": "short",
                  "javadoc": "the short value to use if {@code x} is {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Short parameter value with a default value for {@code null} .",
              "contract": [
                "If the value is {@code null} , uses the specified default value instead of SQL NULL.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setShort(1, nullableShort, (short)0); // use 0 if null } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setInt(final int parameterIndex, final int x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "int",
                  "javadoc": "the int value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an int parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setInt(final int parameterIndex, final Integer x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Integer",
                  "javadoc": "the Integer value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Integer parameter value, handling {@code null} values.",
              "contract": [
                "If the value is {@code null} , sets the parameter to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setInt(final int parameterIndex, final Integer x, final int defaultValueForNull) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Integer",
                  "javadoc": "the Integer value to set, or {@code null} to use the default value",
                  "nullability": "unspecified"
                },
                {
                  "name": "defaultValueForNull",
                  "type": "int",
                  "javadoc": "the int value to use if {@code x} is {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Integer parameter value with a default value for {@code null} .",
              "contract": [
                "If the value is {@code null} , uses the specified default value instead of SQL NULL.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setInt(1, nullableCount, 0); // use 0 if null } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @Beta public This setInt(final int parameterIndex, final char x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "char",
                  "javadoc": "the char value to set as an integer",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Generally, {@code char} should be saved as {@code String} in the database",
                "for_removal": false
              },
              "javadoc_summary": "Sets a char parameter value as an integer.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#setString(int, char)"
              ]
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @Beta public This setInt(final int parameterIndex, final Character x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Character",
                  "javadoc": "the Character value to set as an integer, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Generally, {@code char} should be saved as {@code String} in the database",
                "for_removal": false
              },
              "javadoc_summary": "Sets a Character parameter value as an integer, handling {@code null} values.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#setString(int, Character)"
              ]
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setLong(final int parameterIndex, final long x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "long",
                  "javadoc": "the long value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a long parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setLong(final int parameterIndex, final Long x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Long",
                  "javadoc": "the Long value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Long parameter value, handling {@code null} values.",
              "contract": [
                "If the value is {@code null} , sets the parameter to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setLong(final int parameterIndex, final Long x, final long defaultValueForNull) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Long",
                  "javadoc": "the Long value to set, or {@code null} to use the default value",
                  "nullability": "unspecified"
                },
                {
                  "name": "defaultValueForNull",
                  "type": "long",
                  "javadoc": "the long value to use if {@code x} is {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Long parameter value with a default value for {@code null} .",
              "contract": [
                "If the value is {@code null} , uses the specified default value instead of SQL NULL.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setLong(1, nullableId, -1L); // use -1 if null } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setLong(final int parameterIndex, final BigInteger x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger parameter value as a long.",
              "contract": [
                "The BigInteger must be within the range of a long value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setFloat(final int parameterIndex, final float x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "float",
                  "javadoc": "the float value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a float parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setFloat(final int parameterIndex, final Float x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Float",
                  "javadoc": "the Float value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Float parameter value, handling {@code null} values.",
              "contract": [
                "If the value is {@code null} , sets the parameter to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setFloat(final int parameterIndex, final Float x, final float defaultValueForNull) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Float",
                  "javadoc": "the Float value to set, or {@code null} to use the default value",
                  "nullability": "unspecified"
                },
                {
                  "name": "defaultValueForNull",
                  "type": "float",
                  "javadoc": "the float value to use if {@code x} is {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Float parameter value with a default value for {@code null} .",
              "contract": [
                "If the value is {@code null} , uses the specified default value instead of SQL NULL.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setFloat(1, nullableRating, 0.0f); // use 0.0 if null } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setDouble(final int parameterIndex, final double x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "double",
                  "javadoc": "the double value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a double parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setDouble(final int parameterIndex, final Double x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Double",
                  "javadoc": "the Double value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Double parameter value, handling {@code null} values.",
              "contract": [
                "If the value is {@code null} , sets the parameter to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setDouble(final int parameterIndex, final Double x, final double defaultValueForNull) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Double",
                  "javadoc": "the Double value to set, or {@code null} to use the default value",
                  "nullability": "unspecified"
                },
                {
                  "name": "defaultValueForNull",
                  "type": "double",
                  "javadoc": "the double value to use if {@code x} is {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Double parameter value with a default value for {@code null} .",
              "contract": [
                "If the value is {@code null} , uses the specified default value instead of SQL NULL.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setDouble(1, nullablePrice, 0.0); // use 0.0 if null } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBigDecimal(final int parameterIndex, final BigDecimal x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigDecimal",
                  "javadoc": "the BigDecimal value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigDecimal parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBigDecimal(final int parameterIndex, final BigInteger x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger parameter value as a BigDecimal.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigIntegerAsString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setBigIntegerAsString(final int parameterIndex, final BigInteger x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger parameter value as a String.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#setString(int, BigInteger)"
              ]
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setString(final int parameterIndex, final String x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "String",
                  "javadoc": "the String value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a String parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setString(final int parameterIndex, final CharSequence x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "CharSequence",
                  "javadoc": "the CharSequence value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a CharSequence parameter value as a String.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setString(final int parameterIndex, final char x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "char",
                  "javadoc": "the char value to set as a String",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a char parameter value as a String.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setString(final int parameterIndex, final Character x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Character",
                  "javadoc": "the Character value to set as a String, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Character parameter value as a String, handling {@code null} values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setString(final int parameterIndex, final BigInteger x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set as a String, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger parameter value as a String.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#setBigIntegerAsString(int, BigInteger)"
              ]
            },
            {
              "name": "setNString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNString(final int parameterIndex, final String x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "String",
                  "javadoc": "the String value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a national character set String (NCHAR, NVARCHAR, LONGNVARCHAR) parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNString(final int parameterIndex, final CharSequence x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "CharSequence",
                  "javadoc": "the CharSequence value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a national character set CharSequence (NCHAR, NVARCHAR, LONGNVARCHAR) parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setDate(final int parameterIndex, final java.sql.Date x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Date",
                  "javadoc": "the Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.sql.Date parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setDate(final int parameterIndex, final java.util.Date x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.util.Date parameter value as a SQL Date.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setDate(final int parameterIndex, final java.sql.Date x, final Calendar cal) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Date",
                  "javadoc": "the Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "cal",
                  "type": "Calendar",
                  "javadoc": "the Calendar object to use for timezone conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a SQL Date parameter value using a Calendar for timezone conversion.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setDate(final int parameterIndex, final LocalDate x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalDate",
                  "javadoc": "the LocalDate value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a LocalDate parameter value as a SQL Date.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTime(final int parameterIndex, final java.sql.Time x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Time",
                  "javadoc": "the Time value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.sql.Time parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTime(final int parameterIndex, final java.util.Date x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the Date value to set as Time, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.util.Date parameter value as a SQL Time.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTime(final int parameterIndex, final java.sql.Time x, final Calendar cal) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Time",
                  "javadoc": "the Time value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "cal",
                  "type": "Calendar",
                  "javadoc": "the Calendar object to use for timezone conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a SQL Time parameter value using a Calendar for timezone conversion.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTime(final int parameterIndex, final LocalTime x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalTime",
                  "javadoc": "the LocalTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a LocalTime parameter value as a SQL Time.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTimestamp(final int parameterIndex, final java.sql.Timestamp x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Timestamp",
                  "javadoc": "the Timestamp value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.sql.Timestamp parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTimestamp(final int parameterIndex, final java.util.Date x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the Date value to set as Timestamp, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.util.Date parameter value as a SQL Timestamp.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTimestamp(final int parameterIndex, final java.sql.Timestamp x, final Calendar cal) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Timestamp",
                  "javadoc": "the Timestamp value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "cal",
                  "type": "Calendar",
                  "javadoc": "the Calendar object to use for timezone conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a SQL Timestamp parameter value using a Calendar for timezone conversion.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTimestamp(final int parameterIndex, final LocalDateTime x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalDateTime",
                  "javadoc": "the LocalDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a LocalDateTime parameter value as a SQL Timestamp.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTimestamp(final int parameterIndex, final ZonedDateTime x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "ZonedDateTime",
                  "javadoc": "the ZonedDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a ZonedDateTime parameter value as a SQL Timestamp.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTimestamp(final int parameterIndex, final OffsetDateTime x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "OffsetDateTime",
                  "javadoc": "the OffsetDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an OffsetDateTime parameter value as a SQL Timestamp.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setTimestamp(final int parameterIndex, final Instant x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Instant",
                  "javadoc": "the Instant value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Instant parameter value as a SQL Timestamp.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBytes(final int parameterIndex, final byte[] x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "byte[]",
                  "javadoc": "the byte array to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a byte array parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setAsciiStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setAsciiStream(final int parameterIndex, final InputStream inputStream) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing ASCII data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an ASCII stream parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setAsciiStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setAsciiStream(final int parameterIndex, final InputStream inputStream, final int length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing ASCII data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "int",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an ASCII stream parameter value with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setAsciiStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setAsciiStream(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing ASCII data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an ASCII stream parameter value with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBinaryStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBinaryStream(final int parameterIndex, final InputStream inputStream) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing binary data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a binary stream parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBinaryStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBinaryStream(final int parameterIndex, final InputStream inputStream, final int length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing binary data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "int",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a binary stream parameter value with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBinaryStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBinaryStream(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing binary data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a binary stream parameter value with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setCharacterStream(final int parameterIndex, final Reader reader) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing character data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a character stream parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setCharacterStream(final int parameterIndex, final Reader reader, final int length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing character data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "int",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a character stream parameter value with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setCharacterStream(final int parameterIndex, final Reader reader, final long length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing character data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a character stream parameter value with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNCharacterStream(final int parameterIndex, final Reader reader) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing national character data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a national character stream parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNCharacterStream(final int parameterIndex, final Reader reader, final long length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing national character data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a national character stream parameter value with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBlob(final int parameterIndex, final java.sql.Blob x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Blob",
                  "javadoc": "the Blob object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Blob parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBlob(final int parameterIndex, final InputStream inputStream) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing the data for the Blob",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Blob parameter value from an InputStream.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setBlob(final int parameterIndex, final InputStream inputStream, final long length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the input stream containing the data for the Blob",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Blob parameter value from an InputStream with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setClob(final int parameterIndex, final java.sql.Clob x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Clob",
                  "javadoc": "the Clob object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Clob parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setClob(final int parameterIndex, final Reader reader) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing the data for the Clob",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Clob parameter value from a Reader.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setClob(final int parameterIndex, final Reader reader, final long length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing the data for the Clob",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Clob parameter value from a Reader with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNClob(final int parameterIndex, final java.sql.NClob x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.NClob",
                  "javadoc": "the NClob object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an NClob parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNClob(final int parameterIndex, final Reader reader) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing the national character data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an NClob parameter value from a Reader.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setNClob(final int parameterIndex, final Reader reader, final long length) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the reader containing the national character data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an NClob parameter value from a Reader with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setURL",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setURL(final int parameterIndex, final URL x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "URL",
                  "javadoc": "the URL object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a URL parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setArray",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setArray(final int parameterIndex, final java.sql.Array x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Array",
                  "javadoc": "the Array object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Array parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setSQLXML",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setSQLXML(final int parameterIndex, final java.sql.SQLXML x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.SQLXML",
                  "javadoc": "the SQLXML object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a SQLXML parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setRef",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setRef(final int parameterIndex, final java.sql.Ref x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Ref",
                  "javadoc": "the Ref object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Ref parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setRowId",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setRowId(final int parameterIndex, final java.sql.RowId x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.RowId",
                  "javadoc": "the RowId object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a RowId parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setObject(final int parameterIndex, final Object x) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Object parameter value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setObject(final int parameterIndex, final Object x, final int sqlType) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type to use (from {@link java.sql.Types} )",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Object parameter value with a specified SQL type.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setObject(final int parameterIndex, final Object x, final int sqlType, final int scaleOrLength) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type to use (from {@link java.sql.Types} )",
                  "nullability": "unspecified"
                },
                {
                  "name": "scaleOrLength",
                  "type": "int",
                  "javadoc": "For numeric types, the number of decimal places; for strings, the length",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Object parameter value with a specified SQL type and scale or length.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setObject(final int parameterIndex, final Object x, final SQLType sqlType) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type to use",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Object parameter value with a specified SQL type.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setObject(final int parameterIndex, final Object x, final SQLType sqlType, final int scaleOrLength) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "scaleOrLength",
                  "type": "int",
                  "javadoc": "For numeric types, the number of decimal places; for strings, the length",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Object parameter value with a specified SQL type and scale or length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> This setObject(final int parameterIndex, final T x, final Type<T> type) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter to set, starting from 1",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "T",
                  "javadoc": "the object to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Type<T>",
                  "javadoc": "the Type handler for custom serialization",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if type is invalid"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an Object parameter value using a custom Type handler.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final String param1, final String param2) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "String",
                  "javadoc": "the first String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "String",
                  "javadoc": "the second String parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets two String parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final String param1, final String param2, final String param3) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "String",
                  "javadoc": "the first String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "String",
                  "javadoc": "the second String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "String",
                  "javadoc": "the third String parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets three String parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final String param1, final String param2, final String param3, final String param4) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "String",
                  "javadoc": "the first String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "String",
                  "javadoc": "the second String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "String",
                  "javadoc": "the third String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "String",
                  "javadoc": "the fourth String parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets four String parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final String param1, final String param2, final String param3, final String param4, final String param5) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "String",
                  "javadoc": "the first String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "String",
                  "javadoc": "the second String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "String",
                  "javadoc": "the third String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "String",
                  "javadoc": "the fourth String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "String",
                  "javadoc": "the fifth String parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets five String parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final String param1, final String param2, final String param3, final String param4, final String param5, final String param6) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "String",
                  "javadoc": "the first String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "String",
                  "javadoc": "the second String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "String",
                  "javadoc": "the third String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "String",
                  "javadoc": "the fourth String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "String",
                  "javadoc": "the fifth String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param6",
                  "type": "String",
                  "javadoc": "the sixth String parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets six String parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final String param1, final String param2, final String param3, final String param4, final String param5, final String param6, final String param7) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "String",
                  "javadoc": "the first String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "String",
                  "javadoc": "the second String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "String",
                  "javadoc": "the third String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "String",
                  "javadoc": "the fourth String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "String",
                  "javadoc": "the fifth String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param6",
                  "type": "String",
                  "javadoc": "the sixth String parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param7",
                  "type": "String",
                  "javadoc": "the seventh String parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets seven String parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Object param1, final Object param2, final Object param3) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "Object",
                  "javadoc": "the first parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "Object",
                  "javadoc": "the second parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "Object",
                  "javadoc": "the third parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets three Object parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "Object",
                  "javadoc": "the first parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "Object",
                  "javadoc": "the second parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "Object",
                  "javadoc": "the third parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "Object",
                  "javadoc": "the fourth parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets four Object parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "Object",
                  "javadoc": "the first parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "Object",
                  "javadoc": "the second parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "Object",
                  "javadoc": "the third parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "Object",
                  "javadoc": "the fourth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "Object",
                  "javadoc": "the fifth parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets five Object parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "Object",
                  "javadoc": "the first parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "Object",
                  "javadoc": "the second parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "Object",
                  "javadoc": "the third parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "Object",
                  "javadoc": "the fourth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "Object",
                  "javadoc": "the fifth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param6",
                  "type": "Object",
                  "javadoc": "the sixth parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets six Object parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6, final Object param7) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "Object",
                  "javadoc": "the first parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "Object",
                  "javadoc": "the second parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "Object",
                  "javadoc": "the third parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "Object",
                  "javadoc": "the fourth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "Object",
                  "javadoc": "the fifth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param6",
                  "type": "Object",
                  "javadoc": "the sixth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param7",
                  "type": "Object",
                  "javadoc": "the seventh parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets seven Object parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6, final Object param7, final Object param8) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "Object",
                  "javadoc": "the first parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "Object",
                  "javadoc": "the second parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "Object",
                  "javadoc": "the third parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "Object",
                  "javadoc": "the fourth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "Object",
                  "javadoc": "the fifth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param6",
                  "type": "Object",
                  "javadoc": "the sixth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param7",
                  "type": "Object",
                  "javadoc": "the seventh parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param8",
                  "type": "Object",
                  "javadoc": "the eighth parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets eight Object parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Object param1, final Object param2, final Object param3, final Object param4, final Object param5, final Object param6, final Object param7, final Object param8, final Object param9) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "param1",
                  "type": "Object",
                  "javadoc": "the first parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param2",
                  "type": "Object",
                  "javadoc": "the second parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param3",
                  "type": "Object",
                  "javadoc": "the third parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param4",
                  "type": "Object",
                  "javadoc": "the fourth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param5",
                  "type": "Object",
                  "javadoc": "the fifth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param6",
                  "type": "Object",
                  "javadoc": "the sixth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param7",
                  "type": "Object",
                  "javadoc": "the seventh parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param8",
                  "type": "Object",
                  "javadoc": "the eighth parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "param9",
                  "type": "Object",
                  "javadoc": "the ninth parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if any parameter is invalid"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets nine Object parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final int[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameters",
                  "type": "int[]",
                  "javadoc": "the array of int values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple int parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final long[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameters",
                  "type": "long[]",
                  "javadoc": "the array of long values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple long parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final String[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameters",
                  "type": "String[]",
                  "javadoc": "the array of String values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple String parameters starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> This setParameters(final T[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameters",
                  "type": "T[]",
                  "javadoc": "the array of values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple parameters of the same type starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Collection<?> parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameters",
                  "type": "Collection<?>",
                  "javadoc": "the collection of values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple parameters from a Collection starting from index 1.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> This setParameters(final Collection<? extends T> parameters, final Class<T> type) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameters",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of values to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Class<T>",
                  "javadoc": "the class type of the parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters or type is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple parameters from a typed Collection starting from index 1.",
              "contract": [
                "This method ensures type safety when setting parameters."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParameters(final Jdbc.ParametersSetter<? super Stmt> parametersSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parametersSetter",
                  "type": "Jdbc.ParametersSetter<? super Stmt>",
                  "javadoc": "the function to set parameters on the PreparedStatement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parametersSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets parameters using a custom ParametersSetter.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.setParameters(stmt -> { stmt.setString(1, user.getName()); stmt.setInt(2, user.getAge()); if (user.getEmail() != null) { stmt.setString(3, user.getEmail()); } else { stmt.setNull(3, Types.VARCHAR); } }).list(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> This setParameters(final T parameters, final Jdbc.BiParametersSetter<? super Stmt, ? super T> parametersSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameters",
                  "type": "T",
                  "javadoc": "the additional data to use when setting parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "parametersSetter",
                  "type": "Jdbc.BiParametersSetter<? super Stmt, ? super T>",
                  "javadoc": "the function to set parameters on the PreparedStatement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parametersSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets parameters using a BiParametersSetter with additional context.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParametersFrom",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParametersFrom(int startParameterIndex, final int[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "startParameterIndex",
                  "type": "int",
                  "javadoc": "the starting parameter index (1-based)",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "int[]",
                  "javadoc": "the array of int values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple int parameters starting from the specified index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParametersFrom",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParametersFrom(int startParameterIndex, final long[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "startParameterIndex",
                  "type": "int",
                  "javadoc": "the starting parameter index (1-based)",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "long[]",
                  "javadoc": "the array of long values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple long parameters starting from the specified index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParametersFrom",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParametersFrom(int startParameterIndex, final String[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "startParameterIndex",
                  "type": "int",
                  "javadoc": "the starting parameter index (1-based)",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "String[]",
                  "javadoc": "the array of String values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple String parameters starting from the specified index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParametersFrom",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> This setParametersFrom(int startParameterIndex, final T[] parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "startParameterIndex",
                  "type": "int",
                  "javadoc": "the starting parameter index (1-based)",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "T[]",
                  "javadoc": "the array of values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple parameters of the same type starting from the specified index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParametersFrom",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setParametersFrom(int startParameterIndex, final Collection<?> parameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "startParameterIndex",
                  "type": "int",
                  "javadoc": "the starting parameter index (1-based)",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Collection<?>",
                  "javadoc": "the collection of values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple parameters from a Collection starting from the specified index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParametersFrom",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> This setParametersFrom(int startParameterIndex, final Collection<? extends T> parameters, final Class<T> type) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "startParameterIndex",
                  "type": "int",
                  "javadoc": "the starting parameter index (1-based)",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of values to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Class<T>",
                  "javadoc": "the class type of the parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters or type is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple parameters from a typed Collection starting from the specified index.",
              "contract": [
                "This method ensures type safety when setting parameters."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "settParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This settParameters(final Jdbc.ParametersSetter<? super This> parametersSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parametersSetter",
                  "type": "Jdbc.ParametersSetter<? super This>",
                  "javadoc": "the function to set parameters on this query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parametersSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets parameters using a custom ParametersSetter that operates on this query instance.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "settParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T> This settParameters(final T parameters, final Jdbc.BiParametersSetter<? super This, ? super T> parametersSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameters",
                  "type": "T",
                  "javadoc": "the additional data to use when setting parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "parametersSetter",
                  "type": "Jdbc.BiParametersSetter<? super This, ? super T>",
                  "javadoc": "the function to set parameters on this query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parametersSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets parameters using a BiParametersSetter that operates on this query instance with additional context.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code UserFilter filter = getUserFilter(); query.settParameters(filter, (q, f) -> { q.setString(1, f.getName()); if (f.getMinAge() != null) { q.setInt(2, f.getMinAge()); } else { q.setNull(2, Types.INTEGER); } }).list(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNullForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setNullForIndices(final int sqlType, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type to set, as defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set to NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same SQL NULL value to multiple parameter positions.",
              "contract": [
                "Useful when multiple parameters should be NULL with the same SQL type."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setBooleanForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setBooleanForIndices(final Boolean parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "Boolean",
                  "javadoc": "the Boolean value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Boolean value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setIntForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setIntForIndices(final Integer parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "Integer",
                  "javadoc": "the Integer value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Integer value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLongForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setLongForIndices(final Long parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "Long",
                  "javadoc": "the Long value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Long value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDoubleForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setDoubleForIndices(final Double parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "Double",
                  "javadoc": "the Double value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Double value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setStringForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setStringForIndices(final String parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "String",
                  "javadoc": "the String value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same String value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDateForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setDateForIndices(final java.sql.Date parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "java.sql.Date",
                  "javadoc": "the Date value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Date value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDateForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setDateForIndices(final java.util.Date parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "java.util.Date",
                  "javadoc": "the Date value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same java.util.Date value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimeForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setTimeForIndices(final java.sql.Time parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "java.sql.Time",
                  "javadoc": "the Time value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Time value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimeForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setTimeForIndices(final java.util.Date parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "java.util.Date",
                  "javadoc": "the Date value to set as Time",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same java.util.Date value as Time to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestampForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setTimestampForIndices(final java.sql.Timestamp parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "java.sql.Timestamp",
                  "javadoc": "the Timestamp value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Timestamp value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestampForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setTimestampForIndices(final java.util.Date parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "java.util.Date",
                  "javadoc": "the Date value to set as Timestamp",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same java.util.Date value as Timestamp to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObjectForIndices",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This setObjectForIndices(final Object parameterValue, final int... parameterIndices) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "parameterValue",
                  "type": "Object",
                  "javadoc": "the Object value to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterIndices",
                  "type": "int[]",
                  "javadoc": "the parameter positions to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the same Object value to multiple parameter positions.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This addBatchParameters(final Collection<?> batchParameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Collection<?>",
                  "javadoc": "Collection where each element is a collection of parameters for one batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if batchParameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of parameters for batch execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T> This addBatchParameters(final Collection<? extends T> batchParameters, final Class<T> type) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Class<T>",
                  "javadoc": "the class type of the parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If batchParameters or type is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of typed parameters for batch execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @SuppressWarnings(\"rawtypes\") public This addBatchParameters(final Iterator<?> batchParameters) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Iterator<?>",
                  "javadoc": "Iterator over parameter sets",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if batchParameters is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of parameters for batch execution using an iterator.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T> This addBatchParameters(final Iterator<? extends T> batchParameters, final Class<T> type) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Iterator<? extends T>",
                  "javadoc": "Iterator over parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Class<T>",
                  "javadoc": "the class type of the parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If batchParameters or type is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of typed parameters for batch execution using an iterator.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T> This addBatchParameters(final Collection<? extends T> batchParameters, final Jdbc.BiParametersSetter<? super This, ? super T> parametersSetter) throws SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of parameter objects",
                  "nullability": "unspecified"
                },
                {
                  "name": "parametersSetter",
                  "type": "Jdbc.BiParametersSetter<? super This, ? super T>",
                  "javadoc": "Function to set parameters for each object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of parameters for batch execution using a custom parameter setter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T> This addBatchParameters(final Iterator<? extends T> batchParameters, final Jdbc.BiParametersSetter<? super This, ? super T> parametersSetter) throws SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Iterator<? extends T>",
                  "javadoc": "Iterator over parameter objects",
                  "nullability": "unspecified"
                },
                {
                  "name": "parametersSetter",
                  "type": "Jdbc.BiParametersSetter<? super This, ? super T>",
                  "javadoc": "Function to set parameters for each object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of parameters for batch execution using a custom parameter setter and iterator.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T> This addBatchParameters(final Collection<? extends T> batchParameters, final Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException> parametersSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of parameter objects",
                  "nullability": "unspecified"
                },
                {
                  "name": "parametersSetter",
                  "type": "Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException>",
                  "javadoc": "Function to set parameters with access to query and statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If batchParameters or parametersSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of parameters for batch execution using a TriConsumer parameter setter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T> This addBatchParameters(final Iterator<? extends T> batchParameters, final Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException> parametersSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Iterator<? extends T>",
                  "javadoc": "Iterator over parameter objects",
                  "nullability": "unspecified"
                },
                {
                  "name": "parametersSetter",
                  "type": "Throwables.TriConsumer<? super This, ? super Stmt, ? super T, ? extends SQLException>",
                  "javadoc": "Function to set parameters with access to query and statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If batchParameters or parametersSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Adds multiple sets of parameters for batch execution using a TriConsumer parameter setter and iterator.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This addBatch() throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed statement"
                }
              ],
              "javadoc_summary": "Adds the current set of parameters to this statement's batch of commands.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.PreparedStatement#addBatch()"
              ]
            },
            {
              "name": "setFetchDirection",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setFetchDirection(final FetchDirection direction) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "direction",
                  "type": "FetchDirection",
                  "javadoc": "One of {@code ResultSet.FETCH_FORWARD} , {@code ResultSet.FETCH_REVERSE} , or {@code ResultSet.FETCH_UNKNOWN}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the direction for fetching rows from database tables.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Statement#setFetchDirection(int)"
              ]
            },
            {
              "name": "setFetchDirectionToForward",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setFetchDirectionToForward() throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the fetch direction to FORWARD.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#setFetchDirection(FetchDirection)"
              ]
            },
            {
              "name": "setFetchSize",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setFetchSize(final int fetchSize) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "fetchSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch. Use 0 to let the JDBC driver choose.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the number of rows that should be fetched from the database when more rows are needed.",
              "contract": [
                "Sets the number of rows that should be fetched from the database when more rows are needed."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Statement#setFetchSize(int)"
              ]
            },
            {
              "name": "setMaxFieldSize",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setMaxFieldSize(final int max) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "max",
                  "type": "int",
                  "javadoc": "the new column size limit in bytes; zero means there is no limit",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the maximum number of bytes that can be returned for character and binary column values.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Statement#setMaxFieldSize(int)"
              ]
            },
            {
              "name": "setMaxRows",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setMaxRows(final int max) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "max",
                  "type": "int",
                  "javadoc": "the new max rows limit; zero means there is no limit",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the maximum number of rows that this query can return.",
              "contract": [
                "If the limit is exceeded, the excess rows are silently dropped."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Statement#setMaxRows(int)"
              ]
            },
            {
              "name": "setLargeMaxRows",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setLargeMaxRows(final long max) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "max",
                  "type": "long",
                  "javadoc": "the new max rows limit; zero means there is no limit",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the maximum number of rows that this query can return (for large row counts).",
              "contract": [
                "If the limit is exceeded, the excess rows are silently dropped."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Statement#setLargeMaxRows(long)"
              ]
            },
            {
              "name": "setQueryTimeout",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public This setQueryTimeout(final int seconds) throws SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "seconds",
                  "type": "int",
                  "javadoc": "the new query timeout limit in seconds; zero means there is no limit",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the number of seconds the driver will wait for a Statement to execute.",
              "contract": [
                "If the limit is exceeded, a SQLException is thrown."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Statement#setQueryTimeout(int)"
              ]
            },
            {
              "name": "configStmt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This configStmt(final Throwables.Consumer<? super Stmt, ? extends SQLException> stmtSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "stmtSetter",
                  "type": "Throwables.Consumer<? super Stmt, ? extends SQLException>",
                  "javadoc": "the function to configure the statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If stmtSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Configures this statement using a custom configuration function.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "configStmt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public This configStmt(final Throwables.BiConsumer<? super This, ? super Stmt, ? extends SQLException> stmtSetter) throws IllegalArgumentException, SQLException",
              "return_type": "This",
              "type_params": [],
              "params": [
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super This, ? super Stmt, ? extends SQLException>",
                  "javadoc": "the function to configure the statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If stmtSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Configures this statement using a BiConsumer that has access to both the query and statement.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalBoolean queryForBoolean() throws IllegalStateException, SQLException",
              "return_type": "OptionalBoolean",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a boolean value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalBoolean} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForChar",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalChar queryForChar() throws IllegalStateException, SQLException",
              "return_type": "OptionalChar",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a char value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalChar} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalByte queryForByte() throws IllegalStateException, SQLException",
              "return_type": "OptionalByte",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a byte value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalByte} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalShort queryForShort() throws IllegalStateException, SQLException",
              "return_type": "OptionalShort",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a short value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalShort} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalInt queryForInt() throws IllegalStateException, SQLException",
              "return_type": "OptionalInt",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as an int value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalInt} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalLong queryForLong() throws IllegalStateException, SQLException",
              "return_type": "OptionalLong",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a long value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalLong} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalFloat queryForFloat() throws IllegalStateException, SQLException",
              "return_type": "OptionalFloat",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a float value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalFloat} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public OptionalDouble queryForDouble() throws IllegalStateException, SQLException",
              "return_type": "OptionalDouble",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a double value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@code OptionalDouble} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Nullable<String> queryForString() throws IllegalStateException, SQLException",
              "return_type": "Nullable<String>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a string value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<String>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBigInteger",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public Nullable<BigInteger> queryForBigInteger() throws IllegalStateException, SQLException",
              "return_type": "Nullable<BigInteger>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a BigInteger value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<BigInteger>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public Nullable<BigDecimal> queryForBigDecimal() throws IllegalStateException, SQLException",
              "return_type": "Nullable<BigDecimal>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a BigDecimal value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<BigDecimal>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Nullable<java.sql.Date> queryForDate() throws IllegalStateException, SQLException",
              "return_type": "Nullable<java.sql.Date>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a Date value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<java.sql.Date>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Nullable<java.sql.Time> queryForTime() throws IllegalStateException, SQLException",
              "return_type": "Nullable<java.sql.Time>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a Time value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<java.sql.Time>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Nullable<java.sql.Timestamp> queryForTimestamp() throws IllegalStateException, SQLException",
              "return_type": "Nullable<java.sql.Timestamp>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a Timestamp value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<java.sql.Timestamp>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Nullable<byte[]> queryForBytes() throws IllegalStateException, SQLException",
              "return_type": "Nullable<byte[]>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as a byte[] value.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<byte[]>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Nullable<V> queryForSingleResult(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the desired result type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes this query and returns the first column of the first row as the specified type.",
              "contract": [
                "<p> If the query produces no rows, an empty {@link Nullable<V>} is returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Nullable<V> queryForSingleResult(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Type<? extends V>",
                  "javadoc": "the Type handler for converting the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the query and returns the first value from the result set using a custom Type handler.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Optional<V> queryForSingleNonNull(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException, NullPointerException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the desired result type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.NullPointerException",
                  "condition": "if a null value is encountered in the result set"
                }
              ],
              "javadoc_summary": "Executes the query and returns the first non-null value from the result set as the specified type.",
              "contract": [
                "<br/> If the value encountered in the first row/column is null, a NullPointerException is thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Optional<V> queryForSingleNonNull(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, SQLException, NullPointerException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Type<? extends V>",
                  "javadoc": "the Type handler for converting the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.NullPointerException",
                  "condition": "if a null value is encountered in the result set"
                }
              ],
              "javadoc_summary": "Executes the query and returns the first non-null value from the result set using a custom Type handler.",
              "contract": [
                "<br/> If the value encountered in the first row/column is null, a NullPointerException is thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Nullable<V> queryForUniqueResult(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the desired result type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If more than one row is found"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the query and returns the unique result value from the result set as the specified type.",
              "contract": [
                "Throws DuplicatedResultException if more than one row is found.",
                "// Throws exception if multiple users have the same email } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Nullable<V> queryForUniqueResult(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Type<? extends V>",
                  "javadoc": "the Type handler for converting the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If more than one row is found"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the query and returns the unique result value from the result set using a custom Type handler.",
              "contract": [
                "Throws DuplicatedResultException if more than one row is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Optional<V> queryForUniqueNonNull(final Class<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException, NullPointerException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the desired result type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If more than one row is found"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.NullPointerException",
                  "condition": "if a null value is encountered in the result set"
                }
              ],
              "javadoc_summary": "Executes the query and returns the unique non-null result value as the specified type.",
              "contract": [
                "<br/> If more than one row is found, a DuplicatedResultException is thrown.",
                "If the value encountered in the first row/column is null, a NullPointerException is thrown.",
                "// Throws exception if multiple sessions exist for the token } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <V> Optional<V> queryForUniqueNonNull(final Type<? extends V> targetValueType) throws IllegalArgumentException, IllegalStateException, DuplicatedResultException, SQLException, NullPointerException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetValueType",
                  "type": "Type<? extends V>",
                  "javadoc": "the Type handler for converting the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetValueType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If more than one row is found"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.NullPointerException",
                  "condition": "if a null value is encountered in the result set"
                }
              ],
              "javadoc_summary": "Executes the query and returns the unique non-null result value using a custom Type handler.",
              "contract": [
                "<br/> If more than one row is found, a DuplicatedResultException is thrown.",
                "If the value encountered in the first row/column is null, a NullPointerException is thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Dataset query() throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the first {@code ResultSet} and converts it to a {@code Dataset} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "Dataset"
              ]
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Dataset query(final Class<?> entityClassForExtractor) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "entityClassForExtractor",
                  "type": "Class<?>",
                  "javadoc": "the class used to provide metadata for mapping columns in the result set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the first {@code ResultSet} and maps it to a {@code Dataset} using the specified entity class.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.ResultExtractor#toDataset(Class)"
              ]
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> R query(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "the extractor used to process the {@code ResultSet} and produce the result. The ResultSet will be automatically closed after this call.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the query and extracts the result using the provided {@code ResultExtractor} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> R query(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "the extractor that receives both ResultSet and column labels. The ResultSet will be automatically closed after this call.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the query and extracts the result using the provided {@code BiResultExtractor} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query2Resultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R1, R2> Tuple2<R1, R2> query2Resultsets(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<R1, R2>",
              "type_params": [
                {
                  "name": "R1",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R2",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor1",
                  "type": "Jdbc.BiResultExtractor<? extends R1>",
                  "javadoc": "the extractor for the first {@code ResultSet} . ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor2",
                  "type": "Jdbc.BiResultExtractor<? extends R2>",
                  "javadoc": "the extractor for the second {@code ResultSet} . ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any of the provided extractors is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves at most two {@code ResultSets} from a stored procedure or multi-result query.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query3Resultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R1, R2, R3> Tuple3<R1, R2, R3> query3Resultsets(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2, final Jdbc.BiResultExtractor<? extends R3> resultExtractor3) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple3<R1, R2, R3>",
              "type_params": [
                {
                  "name": "R1",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R2",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R3",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor1",
                  "type": "Jdbc.BiResultExtractor<? extends R1>",
                  "javadoc": "the extractor for the first {@code ResultSet} . ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor2",
                  "type": "Jdbc.BiResultExtractor<? extends R2>",
                  "javadoc": "the extractor for the second {@code ResultSet} . ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor3",
                  "type": "Jdbc.BiResultExtractor<? extends R3>",
                  "javadoc": "the extractor for the third {@code ResultSet} . ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any of the provided extractors is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves at most three {@code ResultSets} from a stored procedure or multi-result query.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public List<Dataset> queryAllResultsets() throws SQLException",
              "return_type": "List<Dataset>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves all {@code ResultSets} and converts them to a list of {@code Dataset} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#queryAllResultsets(ResultExtractor)",
                "#streamAllResultsets()"
              ]
            },
            {
              "name": "queryAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> List<R> queryAllResultsets(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "the extractor to process each {@code ResultSet} . Each ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves all {@code ResultSets} and processes them with the specified {@code ResultExtractor} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#streamAllResultsets(ResultExtractor)"
              ]
            },
            {
              "name": "queryAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> List<R> queryAllResultsets(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "the extractor that receives ResultSet and column labels. Each ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves all {@code ResultSets} and processes them with the specified {@code BiResultExtractor} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#streamAllResultsets(BiResultExtractor)"
              ]
            },
            {
              "name": "queryThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R, E extends Exception> R queryThenApply(final Throwables.Function<? super Dataset, ? extends R, E> func) throws SQLException, E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "func",
                  "type": "Throwables.Function<? super Dataset, ? extends R, E>",
                  "javadoc": "the function to apply to the {@code Dataset} resulting from the query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the function throws an exception"
                }
              ],
              "javadoc_summary": "Executes a query and applies a function to the resulting {@code Dataset} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R, E extends Exception> R queryThenApply(final Class<?> entityClassForExtractor, final Throwables.Function<? super Dataset, ? extends R, E> func) throws SQLException, E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "entityClassForExtractor",
                  "type": "Class<?>",
                  "javadoc": "the class used to provide metadata for column mapping",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super Dataset, ? extends R, E>",
                  "javadoc": "the function to apply to the {@code Dataset} resulting from the query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the function throws an exception"
                }
              ],
              "javadoc_summary": "Executes a query and applies a function to the resulting {@code Dataset} , using the specified entity class.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.ResultExtractor#toDataset(Class)"
              ]
            },
            {
              "name": "queryThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <E extends Exception> void queryThenAccept(final Throwables.Consumer<? super Dataset, E> action) throws SQLException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "action",
                  "type": "Throwables.Consumer<? super Dataset, E>",
                  "javadoc": "the consumer action to apply to the {@code Dataset} resulting from the query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the consumer action throws an exception"
                }
              ],
              "javadoc_summary": "Executes a query and applies a consumer action to the resulting {@code Dataset} .",
              "contract": [
                "<p> This method is useful when you need to perform side effects with the query results without returning a value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <E extends Exception> void queryThenAccept(final Class<?> entityClassForExtractor, final Throwables.Consumer<? super Dataset, E> action) throws SQLException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "entityClassForExtractor",
                  "type": "Class<?>",
                  "javadoc": "the class used to provide metadata for column mapping",
                  "nullability": "unspecified"
                },
                {
                  "name": "action",
                  "type": "Throwables.Consumer<? super Dataset, E>",
                  "javadoc": "the consumer action to apply to the {@code Dataset} resulting from the query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the consumer action throws an exception"
                }
              ],
              "javadoc_summary": "Executes a query and applies a consumer action to the resulting {@code Dataset} , using the specified entity class.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.ResultExtractor#toDataset(Class)"
              ]
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Optional<Map<String, Object>> findOnlyOne() throws DuplicatedResultException, SQLException",
              "return_type": "Optional<Map<String, Object>>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns an {@code Optional} containing a map of column names to values if exactly one record is found.",
              "contract": [
                "Executes a query and returns an {@code Optional} containing a map of column names to values if exactly one record is found.",
                "If no rows or multiple rows are found, it throws an appropriate exception."
              ],
              "examples": [],
              "see_also": [
                "#queryForUniqueResult(Class)",
                "#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Optional<T> findOnlyOne(final Class<? extends T> targetType) throws NullPointerException, DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map the result row to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns an {@code Optional} containing a single result of the specified type if exactly one record is found.",
              "contract": [
                "Executes a query and returns an {@code Optional} containing a single result of the specified type if exactly one record is found."
              ],
              "examples": [],
              "see_also": [
                "#queryForUniqueResult(Class)",
                "#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Optional<T> findOnlyOne(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} used to map the result set to the result object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code RowMapper} if exactly one record is found.",
              "contract": [
                "Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code RowMapper} if exactly one record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Optional<T> findOnlyOne(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} used to map the result set to the result object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code BiRowMapper} if exactly one record is found.",
              "contract": [
                "Executes a query and returns an {@code Optional} containing a single result extracted by the specified {@code BiRowMapper} if exactly one record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOneOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Map<String, Object> findOnlyOneOrNull() throws DuplicatedResultException, SQLException",
              "return_type": "Map<String, Object>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns a single result as a {@code Map<String, Object>} if exactly one record is found.",
              "contract": [
                "Executes a query and returns a single result as a {@code Map<String, Object>} if exactly one record is found.",
                "<p> Similar to {@link #findOnlyOne()} , but returns {@code null} instead of an empty Optional when no record is found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Map<String, Object> user = preparedQuery .setLong(1, userId) .findOnlyOneOrNull(); if (user != null) { System.out.println(\"Found user: \" + user.get(\"name\")); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOneOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T findOnlyOneOrNull(final Class<? extends T> targetType) throws NullPointerException, DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map the result row to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns a single result of the specified type if exactly one record is found.",
              "contract": [
                "Executes a query and returns a single result of the specified type if exactly one record is found.",
                "<p> Similar to {@link #findOnlyOne(Class)} , but returns {@code null} instead of an empty Optional when no record is found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code User user = preparedQuery .setString(1, email) .findOnlyOneOrNull(User.class); if (user == null) { throw new NotFoundException(\"User not found\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOneOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T findOnlyOneOrNull(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} used to map the result set to the result object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns a single result extracted by the specified {@code RowMapper} if exactly one record is found.",
              "contract": [
                "Executes a query and returns a single result extracted by the specified {@code RowMapper} if exactly one record is found.",
                "<p> Similar to {@link #findOnlyOne(Jdbc.RowMapper)} , but returns {@code null} instead of an empty Optional when no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOneOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T findOnlyOneOrNull(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} used to map the result set to the result object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "If the query finds more than one record"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns a single result extracted by the specified {@code BiRowMapper} if exactly one record is found.",
              "contract": [
                "Executes a query and returns a single result extracted by the specified {@code BiRowMapper} if exactly one record is found.",
                "<p> Similar to {@link #findOnlyOne(BiRowMapper)} , but returns {@code null} instead of an empty Optional when no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Optional<Map<String, Object>> findFirst() throws SQLException",
              "return_type": "Optional<Map<String, Object>>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result as an {@code Optional} containing a {@code Map<String, Object>} .",
              "contract": [
                "<p> Unlike {@link #findOnlyOne()} , this method doesn't throw an exception if multiple rows are found; it simply returns the first row."
              ],
              "examples": [],
              "see_also": [
                "#queryForUniqueResult(Class)",
                "#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Optional<T> findFirst(final Class<? extends T> targetType) throws NullPointerException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map the result row to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result as an {@code Optional} containing an object of the specified type.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#queryForUniqueResult(Class)",
                "#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Optional<T> findFirst(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result as an {@code Optional} containing an object extracted by the specified {@code RowMapper} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public <T> Optional<T> findFirst(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the {@code RowFilter} used to filter the rows in the result set",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@code stream(RowFilter, RowMapper).first()} instead",
                "for_removal": false
              },
              "javadoc_summary": "Executes a query with the specified {@code RowFilter} and {@code RowMapper} , and returns the first matching result as an {@code Optional} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Optional<T> findFirst(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result as an {@code Optional} containing an object extracted by the specified {@code BiRowMapper} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public <T> Optional<T> findFirst(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the {@code BiRowFilter} used to filter the rows in the result set",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@code stream(BiRowFilter, BiRowMapper).first()} instead",
                "for_removal": false
              },
              "javadoc_summary": "Executes a query with the specified {@code BiRowFilter} and {@code BiRowMapper} , and returns the first matching result as an {@code Optional} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirstOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Map<String, Object> findFirstOrNull() throws SQLException",
              "return_type": "Map<String, Object>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result as a {@code Map<String, Object>} .",
              "contract": [
                "<p> Similar to {@link #findFirst()} , but returns {@code null} instead of an empty Optional when no result is found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Map<String, Object> firstRow = preparedQuery.findFirstOrNull(); if (firstRow != null) { System.out.println(\"Found: \" + firstRow); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirstOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T findFirstOrNull(final Class<? extends T> targetType) throws NullPointerException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map the result row to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result of the specified type.",
              "contract": [
                "<p> Similar to {@link #findFirst(Class)} , but returns {@code null} instead of an empty Optional when no result is found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code User firstUser = preparedQuery .setString(1, \"active\") .findFirstOrNull(User.class); if (firstUser != null) { processUser(firstUser); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirstOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T findFirstOrNull(final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result extracted by the specified {@code RowMapper} .",
              "contract": [
                "<p> Similar to {@link #findFirst(RowMapper)} , but returns {@code null} instead of an empty Optional when no result is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirstOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public <T> T findFirstOrNull(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the {@code RowFilter} used to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@code stream(RowFilter, RowMapper).first()} instead",
                "for_removal": false
              },
              "javadoc_summary": "Executes a query with filtering and returns the first matching result extracted by the specified {@code RowMapper} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirstOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T findFirstOrNull(final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the first result extracted by the specified {@code BiRowMapper} .",
              "contract": [
                "<p> Similar to {@link #findFirst(BiRowMapper)} , but returns {@code null} instead of an empty Optional when no result is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirstOrNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public <T> T findFirstOrNull(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws NullPointerException, SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the {@code BiRowFilter} used to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} used to map the result set to an object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.NullPointerException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@code stream(BiRowFilter, BiRowMapper).first()} instead",
                "for_removal": false
              },
              "javadoc_summary": "Executes a query with filtering and returns the first matching result extracted by the specified {@code BiRowMapper} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public List<Map<String, Object>> list() throws SQLException",
              "return_type": "List<Map<String, Object>>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all rows in the first {@code ResultSet} as maps of column names to values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<T> list(final Class<? extends T> targetType) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the type to map the rows to. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or mapping fails"
                }
              ],
              "javadoc_summary": "Lists the rows in the first ResultSet and maps them to the specified target type.",
              "contract": [
                "<p> <b> Mapping Rules: </b> </p> <ul> <li> Column names are matched to field/property names (case-insensitive) </li> <li> Underscores in column names are converted to camelCase (e.g., user_name \\u2192 userName) </li> <li> The target class must have a no-argument constructor </li> <li> Fields can be set via public fields or setter methods </li> <li> Type conversion is automatic for common types </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Define a simple entity class public class User { private Long id; private String name; private int age; // getters and setters..."
              ],
              "examples": [],
              "see_also": [
                "#list(Jdbc.RowMapper)",
                "#stream(Class)",
                "Jdbc.BiRowMapper#to(Class)"
              ]
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public <T> List<T> list(final Class<? extends T> targetType, final int maxResult) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the type to map the rows to",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxResult",
                  "type": "int",
                  "javadoc": "the maximum number of results to return",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "The result size should be limited in database server side by SQL scripts (e.g., LIMIT clause). Use SQL's LIMIT/TOP/ROWNUM instead for better performance.",
                "for_removal": false
              },
              "javadoc_summary": "Lists the rows in the first ResultSet and maps them to the specified target type with a maximum result limit.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") public <T> List<T> list(final Jdbc.RowMapper<? extends T> rowMapper) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the row mapper to map each row of the ResultSet to an object. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the row mapper throws an exception"
                }
              ],
              "javadoc_summary": "Lists the rows in the first ResultSet using the provided row mapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.RowMapper",
                "#list(Jdbc.BiRowMapper)"
              ]
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public <T> List<T> list(final Jdbc.RowMapper<? extends T> rowMapper, final int maxResult) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the row mapper to map each row to an object",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxResult",
                  "type": "int",
                  "javadoc": "the maximum number of results to return",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "The result size should be limited in database server side by SQL scripts (e.g., LIMIT clause). Use SQL's LIMIT/TOP/ROWNUM instead for better performance.",
                "for_removal": false
              },
              "javadoc_summary": "Lists the rows in the first ResultSet using the provided row mapper with a maximum result limit.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<T> list(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to apply to each row of the ResultSet. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the row mapper to map each row of the ResultSet to an object. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists the rows in the first ResultSet that match the specified row filter and maps them using the provided row mapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.RowFilter",
                "Jdbc.RowMapper"
              ]
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<T> list(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper, int maxResult) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to apply to each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the row mapper to map filtered rows to objects. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxResult",
                  "type": "int",
                  "javadoc": "the maximum number of results to return. Must be non-negative.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowMapper is {@code null} , or maxResult is negative"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists the rows in the first ResultSet that match the specified row filter and maps them using the provided row mapper, with a maximum result limit.",
              "contract": [
                "Processing stops when either the ResultSet is exhausted or maxResult mapped objects have been created."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") public <T> List<T> list(final Jdbc.BiRowMapper<? extends T> rowMapper) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to map each row. Receives ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists the rows in the first ResultSet and maps them using the provided BiRowMapper.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Map with access to column labels List<Map<String, Object>> results = preparedQuery .list((rs, columnLabels) -> { Map<String, Object> row = new HashMap<>(); for (String label : columnLabels) { row.put(label.toLowerCase(), rs.getObject(label)); } return row; }); // Dynamic mapping based on available columns List<FlexibleDTO> dtos = query .list((rs, columnLabels) -> { FlexibleDTO dto = new FlexibleDTO(); if (columnLabels.contains(\"name\")) { dto.setName(rs.getString(\"name\")); } if (columnLabels.contains(\"description\")) { dto.setDescription(rs.getString(\"description\")); } return dto; }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Jdbc.BiRowMapper",
                "#list(Jdbc.RowMapper)"
              ]
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public <T> List<T> list(final Jdbc.BiRowMapper<? extends T> rowMapper, final int maxResult) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to map each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxResult",
                  "type": "int",
                  "javadoc": "the maximum number of results to return",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "The result size should be limited in database server side by SQL scripts (e.g., LIMIT clause). Use SQL's LIMIT/TOP/ROWNUM instead for better performance.",
                "for_removal": false
              },
              "javadoc_summary": "Lists the rows in the first ResultSet using a BiRowMapper with a maximum result limit.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<T> list(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the BiRowFilter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to map filtered rows. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists the rows in the first ResultSet that match the specified BiRowFilter and maps them using the provided BiRowMapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.BiRowFilter",
                "Jdbc.BiRowMapper"
              ]
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<T> list(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper, int maxResult) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the BiRowFilter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to map filtered rows. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxResult",
                  "type": "int",
                  "javadoc": "the maximum number of results to return. Must be non-negative.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowMapper is {@code null} , or maxResult is negative"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists the rows in the first ResultSet that match the specified BiRowFilter and maps them using the provided BiRowMapper, with a maximum result limit.",
              "contract": [
                "Processing stops when maxResult objects have been created.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Complex filtering and mapping with result limit List<OrderSummary> summaries = preparedQuery .list( (rs, labels) -> { // Only include orders with all required fields return labels.containsAll(Arrays.asList(\"id\", \"total\", \"status\")) && \"COMPLETED\".equals(rs.getString(\"status\")); }, (rs, labels) -> { OrderSummary summary = new OrderSummary(); summary.setId(rs.getLong(\"id\")); summary.setTotal(rs.getBigDecimal(\"total\")); // Include optional fields if present if (labels.contains(\"customer_name\")) { summary.setCustomerName(rs.getString(\"customer_name\")); } return summary; }, 100 // Limit to 100 results ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "listAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<List<T>> listAllResultsets(final Class<? extends T> targetType) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map each row to. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If targetType is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all the ResultSets returned by the query (typically from stored procedures).",
              "contract": [
                "<p> This method is primarily used when executing stored procedures that return multiple ResultSets."
              ],
              "examples": [],
              "see_also": [
                "#listAllResultsets(Jdbc.RowMapper)"
              ]
            },
            {
              "name": "listAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<List<T>> listAllResultsets(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the row mapper to apply to each row in all ResultSets. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all the ResultSets using the provided row mapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.RowMapper"
              ]
            },
            {
              "name": "listAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<List<T>> listAllResultsets(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to apply to each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the row mapper for filtered rows. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all the ResultSets that match the specified row filter and maps them using the provided row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "listAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<List<T>> listAllResultsets(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to apply to each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all the ResultSets and maps them using the provided BiRowMapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.BiRowMapper"
              ]
            },
            {
              "name": "listAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> List<List<T>> listAllResultsets(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "List<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the BiRowFilter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper for filtered rows. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all the ResultSets that match the specified BiRowFilter and maps them using the provided BiRowMapper.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Process multiple result sets with column-aware filtering and mapping List<List<ProcessedRecord>> results = callableQuery .listAllResultsets( (rs, labels) -> labels.contains(\"process_flag\") && rs.getBoolean(\"process_flag\"), (rs, labels) -> { ProcessedRecord record = new ProcessedRecord(); record.setId(rs.getLong(\"id\")); if (labels.contains(\"metadata\")) { record.setMetadata(rs.getString(\"metadata\")); } return record; } ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "listThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T, R, E extends Exception> R listThenApply(final Class<? extends T> targetType, final Throwables.Function<? super List<T>, ? extends R, E> func) throws SQLException, E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map each row to. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super List<T>, ? extends R, E>",
                  "javadoc": "the function to apply to the list. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the function throws an exception"
                }
              ],
              "javadoc_summary": "Retrieves query results as a list and applies the specified function to transform them.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#list(Class)",
                "#listThenAccept(Class, Throwables.Consumer)"
              ]
            },
            {
              "name": "listThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T, R, E extends Exception> R listThenApply(final Jdbc.RowMapper<? extends T> rowMapper, final Throwables.Function<? super List<T>, ? extends R, E> func) throws SQLException, E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the row mapper to use. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super List<T>, ? extends R, E>",
                  "javadoc": "the function to apply to the list. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the function throws an exception"
                }
              ],
              "javadoc_summary": "Retrieves query results using a row mapper and applies the specified function to transform them.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "listThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T, R, E extends Exception> R listThenApply(final Jdbc.BiRowMapper<? extends T> rowMapper, final Throwables.Function<? super List<T>, ? extends R, E> func) throws SQLException, E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to use. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super List<T>, ? extends R, E>",
                  "javadoc": "the function to apply to the list. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the function throws an exception"
                }
              ],
              "javadoc_summary": "Retrieves query results using a BiRowMapper and applies the specified function to transform them.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "listThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T, E extends Exception> void listThenAccept(final Class<? extends T> targetType, final Throwables.Consumer<? super List<T>, E> consumer) throws SQLException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map each row to. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "consumer",
                  "type": "Throwables.Consumer<? super List<T>, E>",
                  "javadoc": "the consumer to process the list. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Retrieves query results as a list and processes them with the specified consumer.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#list(Class)",
                "#listThenApply(Class, Throwables.Function)"
              ]
            },
            {
              "name": "listThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T, E extends Exception> void listThenAccept(final Jdbc.RowMapper<? extends T> rowMapper, final Throwables.Consumer<? super List<T>, E> consumer) throws SQLException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the RowMapper to use. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "consumer",
                  "type": "Throwables.Consumer<? super List<T>, E>",
                  "javadoc": "the consumer to process the list. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Retrieves query results using a RowMapper and processes them with the specified consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "listThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <T, E extends Exception> void listThenAccept(final Jdbc.BiRowMapper<? extends T> rowMapper, final Throwables.Consumer<? super List<T>, E> consumer) throws SQLException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to use. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "consumer",
                  "type": "Throwables.Consumer<? super List<T>, E>",
                  "javadoc": "the consumer to process the list. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "If the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Retrieves query results using a BiRowMapper and processes them with the specified consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation public Stream<Map<String, Object>> stream()",
              "return_type": "Stream<Map<String, Object>>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Streams the rows in the first ResultSet as a lazy-evaluated stream of maps.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#list()",
                "#stream(Class)",
                "Stream"
              ]
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation public <T> Stream<T> stream(final Class<? extends T> targetType)",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map each row to. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Streams the rows in the first ResultSet, mapping each row to the specified target type.",
              "contract": [
                "The query executes when a terminal operation is called on the stream."
              ],
              "examples": [],
              "see_also": [
                "#stream(Jdbc.RowMapper)",
                "#list(Class)"
              ]
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"resource\") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the RowMapper to transform each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Streams the rows in the first ResultSet using the provided RowMapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.RowMapper",
                "#stream(Jdbc.BiRowMapper)"
              ]
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"resource\") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper receiving ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Streams the rows in the first ResultSet using the provided BiRowMapper.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Stream with column-aware mapping try (Stream<FlexibleRecord> stream = preparedQuery.stream((rs, labels) -> { FlexibleRecord record = new FlexibleRecord(); for (String label : labels) { if (!label.startsWith(\"internal_\")) { // Skip internal columns record.addField(label, rs.getObject(label)); } } return record; })) { stream.forEach(record -> processRecord(record)); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Jdbc.BiRowMapper"
              ]
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"resource\") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the mapper for rows that pass the filter. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Streams the rows in the first ResultSet, filtering with RowFilter and mapping with RowMapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.RowFilter",
                "Jdbc.RowMapper"
              ]
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"resource\") @LazyEvaluation public <T> Stream<T> stream(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the BiRowFilter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper for filtered rows. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowMapper is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Streams the rows in the first ResultSet, filtering with BiRowFilter and mapping with BiRowMapper.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Advanced streaming with column-aware filtering and mapping try (Stream<Report> stream = preparedQuery.stream( (rs, labels) -> labels.contains(\"published\") && rs.getBoolean(\"published\"), (rs, labels) -> { Report report = new Report(); report.setId(rs.getLong(\"id\")); // Only set optional fields if they exist if (labels.contains(\"author\")) { report.setAuthor(rs.getString(\"author\")); } return report; } )) { stream.forEach(report -> publishReport(report)); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Jdbc.BiRowFilter",
                "Jdbc.BiRowMapper"
              ]
            },
            {
              "name": "streamAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public Stream<Dataset> streamAllResultsets()",
              "return_type": "Stream<Dataset>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Streams all ResultSets as Datasets from a stored procedure or multi-result query.",
              "contract": [
                "<p> This method is typically used when executing stored procedures that return multiple result sets."
              ],
              "examples": [],
              "see_also": [
                "#queryAllResultsets()",
                "Dataset"
              ]
            },
            {
              "name": "streamAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @SuppressWarnings(\"resource\") public <R> Stream<R> streamAllResultsets(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "the extractor used to process each ResultSet and produce a result. Must not be {@code null} . The ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Streams all ResultSets using the specified ResultExtractor to process each ResultSet.",
              "contract": [
                "<p> This method is typically used when executing stored procedures that return multiple result sets.",
                "</p> <p> <b> Important: </b> The ResultExtractor should not save or return the ResultSet reference, as it will be automatically closed after processing."
              ],
              "examples": [],
              "see_also": [
                "#queryAllResultsets(ResultExtractor)",
                "ResultExtractor"
              ]
            },
            {
              "name": "streamAllResultsets",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @SuppressWarnings(\"resource\") public <R> Stream<R> streamAllResultsets(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "the extractor used to process each ResultSet with column labels. Must not be {@code null} . The ResultSet will be closed after extraction.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Streams all ResultSets using the specified BiResultExtractor to process each ResultSet.",
              "contract": [
                "<p> This method is typically used when executing stored procedures that return multiple result sets.",
                "</p> <p> <b> Important: </b> The BiResultExtractor should not save or return the ResultSet reference, as it will be automatically closed after processing.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Extract data with column-aware processing Stream<Report> reports = callableQuery.streamAllResultsets( (rs, columnLabels) -> { List<Report> list = new ArrayList<>(); while (rs.next()) { Report report = new Report(); // Process based on available columns if (columnLabels.contains(\"status\")) { report.setStatus(rs.getString(\"status\")); } list.add(report); } return list; } ); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#queryAllResultsets(BiResultExtractor)",
                "BiResultExtractor"
              ]
            },
            {
              "name": "exists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean exists() throws IllegalStateException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if there is at least one record found by executing the query.",
              "contract": [
                "Checks if there is at least one record found by executing the query.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if user exists boolean userExists = JdbcUtil.prepareQuery(conn, \"SELECT * FROM users WHERE email = ?\") .setString(1, \"john@example.com\") .exists(); if (userExists) { // Process existing user } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#notExists()",
                "#count()"
              ]
            },
            {
              "name": "notExists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public boolean notExists() throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if there are no records found by executing the query.",
              "contract": [
                "Checks if there are no records found by executing the query.",
                "</b> While {@code !exists()} works, {@code notExists()} better expresses the intent when checking for absence of records, similar to SQL's {@code NOT EXISTS} clause.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if email is available for registration boolean emailAvailable = JdbcUtil.prepareQuery(conn, \"SELECT * FROM users WHERE email = ?\") .setString(1, \"newuser@example.com\") .notExists(); if (emailAvailable) { // Proceed with registration } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#exists()"
              ]
            },
            {
              "name": "ifExists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void ifExists(final Jdbc.RowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to process the first row if it exists. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowConsumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the given RowConsumer if a record exists in the result set.",
              "contract": [
                "Executes the given RowConsumer if a record exists in the result set.",
                "If at least one row is found, the consumer is called with the first row's ResultSet.",
                "</p> <p> <b> Note: </b> Only the first row is processed even if multiple rows exist.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process user if found JdbcUtil.prepareQuery(conn, \"SELECT * FROM users WHERE id = ?\") .setLong(1, userId) .ifExists(rs -> { String name = rs.getString(\"name\"); String email = rs.getString(\"email\"); sendWelcomeEmail(name, email); }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#ifExistsOrElse(RowConsumer, Throwables.Runnable)"
              ]
            },
            {
              "name": "ifExists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void ifExists(final Jdbc.BiRowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the consumer to process the first row with column labels if it exists. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowConsumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the given BiRowConsumer if a record exists in the result set.",
              "contract": [
                "Executes the given BiRowConsumer if a record exists in the result set.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process user with dynamic column handling JdbcUtil.prepareQuery(conn, \"SELECT * FROM users WHERE id = ?\") .setLong(1, userId) .ifExists((rs, labels) -> { User user = new User(); user.setId(rs.getLong(\"id\")); // Only process columns that exist if (labels.contains(\"middle_name\")) { user.setMiddleName(rs.getString(\"middle_name\")); } processUser(user); }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#ifExistsOrElse(BiRowConsumer, Throwables.Runnable)"
              ]
            },
            {
              "name": "ifExistsOrElse",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void ifExistsOrElse(final Jdbc.RowConsumer rowConsumer, final Throwables.Runnable<SQLException> orElseAction) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to process the first row if it exists. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "orElseAction",
                  "type": "Throwables.Runnable<SQLException>",
                  "javadoc": "the action to execute if no record exists. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowConsumer or orElseAction is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the given RowConsumer if a record exists, otherwise executes the orElseAction.",
              "contract": [
                "Executes the given RowConsumer if a record exists, otherwise executes the orElseAction.",
                "<p> This method provides a complete conditional execution pattern: process the first row if it exists, or execute an alternative action if no rows are found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "ifExistsOrElse",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void ifExistsOrElse(final Jdbc.BiRowConsumer rowConsumer, final Throwables.Runnable<SQLException> orElseAction) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the consumer to process the first row with column labels if it exists. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "orElseAction",
                  "type": "Throwables.Runnable<SQLException>",
                  "javadoc": "the action to execute if no record exists. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowConsumer or orElseAction is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the given BiRowConsumer if a record exists, otherwise executes the orElseAction.",
              "contract": [
                "Executes the given BiRowConsumer if a record exists, otherwise executes the orElseAction.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Load configuration or use defaults JdbcUtil.prepareQuery(conn, \"SELECT * FROM config WHERE app_id = ?\") .setString(1, appId) .ifExistsOrElse( (rs, labels) -> { // Load existing configuration config = new Config(); config.setAppId(rs.getString(\"app_id\")); // Handle optional columns if (labels.contains(\"custom_settings\")) { config.setCustomSettings(rs.getString(\"custom_settings\")); } }, () -> { // Create default configuration config = Config.createDefault(appId); insertDefaultConfig(config); } ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "count",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public int count() throws IllegalStateException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This method is inefficient for large result sets. Use {@code SELECT COUNT(*)} queries instead.",
                "for_removal": false
              },
              "javadoc_summary": "Counts all records returned by the query by iterating through the entire result set.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#queryForInt()",
                "#count(RowFilter)"
              ]
            },
            {
              "name": "count",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public int count(final Jdbc.RowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to apply to each row. Only rows where this returns {@code true} are counted. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Counts the number of rows that match the given row filter.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#count(BiRowFilter)",
                "#anyMatch(RowFilter)"
              ]
            },
            {
              "name": "count",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public int count(final Jdbc.BiRowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the filter to apply to each row with column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Counts the number of rows that match the given BiRowFilter.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Count rows with specific conditions based on available columns int validCount = JdbcUtil.prepareQuery(conn, \"SELECT * FROM products\") .count((rs, labels) -> { // Always check required fields if (rs.getDouble(\"price\") <= 0) return false; // Additional check only if column exists if (labels.contains(\"discontinued\")) { return !rs.getBoolean(\"discontinued\"); } return true; }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#count(RowFilter)"
              ]
            },
            {
              "name": "anyMatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean anyMatch(final Jdbc.RowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if any row in the result set matches the given row filter.",
              "contract": [
                "Checks if any row in the result set matches the given row filter.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if any order is pending boolean hasPendingOrders = JdbcUtil.prepareQuery(conn, \"SELECT * FROM orders WHERE customer_id = ?",
                "AND date >= ?\") .setLong(1, customerId) .setDate(2, startDate) .anyMatch(rs -> \"PENDING\".equals(rs.getString(\"status\"))); if (hasPendingOrders) { notifyCustomer(\"You have pending orders\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#allMatch(RowFilter)",
                "#noneMatch(RowFilter)"
              ]
            },
            {
              "name": "anyMatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean anyMatch(final Jdbc.BiRowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the filter to test each row with column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if any row in the result set matches the given BiRowFilter.",
              "contract": [
                "Checks if any row in the result set matches the given BiRowFilter.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Check if any product has invalid data considering available columns boolean hasInvalidProducts = JdbcUtil.prepareQuery(conn, \"SELECT * FROM products\") .anyMatch((rs, labels) -> { // Check price if (rs.getDouble(\"price\") < 0) return true; // Check optional validation if (labels.contains(\"min_quantity\") && rs.getInt(\"min_quantity\") < 0) { return true; } return false; }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#anyMatch(RowFilter)"
              ]
            },
            {
              "name": "allMatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean allMatch(final Jdbc.RowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if all rows in the result set match the given RowFilter.",
              "contract": [
                "Checks if all rows in the result set match the given RowFilter.",
                "<p> This method returns {@code true} only if every row in the result set satisfies the filter condition.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Verify all items in order are in stock boolean allInStock = JdbcUtil.prepareQuery(conn, \"SELECT * FROM order_items WHERE order_id = ?\") .setLong(1, orderId) .allMatch(rs -> rs.getInt(\"quantity\") <= rs.getInt(\"stock_available\")); if (allInStock) { processOrder(orderId); } else { notifyOutOfStock(orderId); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#anyMatch(RowFilter)",
                "#noneMatch(RowFilter)"
              ]
            },
            {
              "name": "allMatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean allMatch(final Jdbc.BiRowFilter rowFilter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the filter to test each row with column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if all rows in the result set match the given BiRowFilter.",
              "contract": [
                "Checks if all rows in the result set match the given BiRowFilter.",
                "It returns {@code true} only if every row satisfies the filter condition, with access to column labels for dynamic validation.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Validate all employee records have required fields boolean allValid = JdbcUtil.prepareQuery(conn, \"SELECT * FROM employees WHERE dept_id = ?\") .setInt(1, deptId) .allMatch((rs, labels) -> { // Required fields if (rs.getString(\"email\") == null) return false; if (rs.getDouble(\"salary\") <= 0) return false; // Optional validation if column exists if (labels.contains(\"hire_date\") && rs.getDate(\"hire_date\") == null) { return false; } return true; }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#allMatch(RowFilter)"
              ]
            },
            {
              "name": "noneMatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean noneMatch(final Jdbc.RowFilter rowFilter) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to test each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if no rows in the result set match the given RowFilter.",
              "contract": [
                "Checks if no rows in the result set match the given RowFilter.",
                "It returns {@code true} only if no row satisfies the filter condition.",
                "AND status = 'PENDING'\") .setLong(1, customerId) .noneMatch(rs -> rs.getDouble(\"total_amount\") > creditLimit); if (withinCreditLimit) { approveAllPendingOrders(customerId); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#anyMatch(RowFilter)",
                "#allMatch(RowFilter)"
              ]
            },
            {
              "name": "noneMatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean noneMatch(final Jdbc.BiRowFilter rowFilter) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the filter to test each row with column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if no rows in the result set match the given BiRowFilter.",
              "contract": [
                "Checks if no rows in the result set match the given BiRowFilter.",
                "It provides column-aware filtering and returns {@code true} only if no row satisfies the filter condition.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Ensure no products have conflicting data boolean noConflicts = JdbcUtil.prepareQuery(conn, \"SELECT * FROM products WHERE category_id = ?\") .setInt(1, categoryId) .noneMatch((rs, labels) -> { // Check for conflicts based on available columns if (labels.contains(\"special_price\") && labels.contains(\"discount_percent\")) { return rs.getDouble(\"special_price\") > 0 && rs.getDouble(\"discount_percent\") > 0; } return false; }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#anyMatch(BiRowFilter)"
              ]
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void forEach(final Jdbc.RowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to apply to each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowConsumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over each row in the result set and applies the given RowConsumer.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#forEach(RowFilter, RowConsumer)",
                "#forEach(BiRowConsumer)"
              ]
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void forEach(final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the filter to apply to each row. Only matching rows are processed. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to apply to each filtered row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowConsumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over each row that matches the filter and applies the given RowConsumer.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#forEach(RowConsumer)"
              ]
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void forEach(final Jdbc.BiRowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the consumer to apply to each row with column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowConsumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over each row in the result set and applies the given BiRowConsumer.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process rows with dynamic column handling JdbcUtil.prepareQuery(conn, \"SELECT * FROM products\") .forEach((rs, labels) -> { Product product = new Product(); product.setId(rs.getLong(\"id\")); product.setName(rs.getString(\"name\")); // Handle optional columns if (labels.contains(\"description\")) { product.setDescription(rs.getString(\"description\")); } if (labels.contains(\"category_name\")) { product.setCategoryName(rs.getString(\"category_name\")); } processProduct(product); }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#forEach(BiRowFilter, BiRowConsumer)"
              ]
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void forEach(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the filter to apply to each row with column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the consumer to apply to each filtered row with column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If rowFilter or rowConsumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over each row that matches the filter and applies the given BiRowConsumer.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process valid products with dynamic field handling JdbcUtil.prepareQuery(conn, \"SELECT p.*, c.name as category_name FROM products p \" + \"LEFT JOIN categories c ON p.category_id = c.id\") .forEach( (rs, labels) -> { // Filter: only active products with category return rs.getBoolean(\"active\") && labels.contains(\"category_name\") && rs.getString(\"category_name\") != null; }, (rs, labels) -> { // Process filtered rows ProductReport report = new ProductReport(); report.setProductId(rs.getLong(\"id\")); report.setProductName(rs.getString(\"name\")); report.setCategoryName(rs.getString(\"category_name\")); // Add optional data if available if (labels.contains(\"last_updated\")) { report.setLastUpdated(rs.getTimestamp(\"last_updated\")); } generateReport(report); } ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "foreach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public void foreach(final Consumer<DisposableObjArray> rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rowConsumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "the consumer to apply to each row's DisposableObjArray. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over each row and applies the given Consumer to a DisposableObjArray.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process rows with disposable arrays preparedQuery.foreach(row -> { Long id = (Long) row.get(0); String name = (String) row.get(1); Double salary = (Double) row.get(2); if (salary > 50000) { System.out.println(\"High earner: \" + name); } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "RowConsumer#oneOff(Consumer)",
                "#foreach(Class, Consumer)"
              ]
            },
            {
              "name": "foreach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public void foreach(final Class<?> entityClass, final Consumer<DisposableObjArray> rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the class used to determine proper types for column value retrieval. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "the consumer to apply to each row's DisposableObjArray. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over each row and applies the given Consumer to a DisposableObjArray, using the specified entity class to guide column retrieval.",
              "contract": [
                "} // Process with type-guided retrieval preparedQuery.foreach(User.class, row -> { Long id = (Long) row.get(0); // Retrieved as Long String name = (String) row.get(1); // Retrieved as String LocalDate birthDate = (LocalDate) row.get(2); // Retrieved as LocalDate Boolean active = (Boolean) row.get(3); // Retrieved as Boolean if (active) { sendBirthdayGreeting(id, name, birthDate); } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "RowConsumer#oneOff(Class, Consumer)"
              ]
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <ID> Optional<ID> insert() throws SQLException",
              "return_type": "Optional<ID>",
              "type_params": [
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes an INSERT statement and retrieves the auto-generated key.",
              "contract": [
                "If no key is generated or the key is a default value (null, 0, etc.), an empty Optional is returned."
              ],
              "examples": [],
              "see_also": [
                "#insert(RowMapper)",
                "#batchInsert()"
              ]
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <ID> Optional<ID> insert(final Jdbc.RowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException",
              "return_type": "Optional<ID>",
              "type_params": [
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.RowMapper<? extends ID>",
                  "javadoc": "the function to extract the key from the generated keys ResultSet. The function receives the ResultSet positioned at the generated key row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the statement fails to execute"
                }
              ],
              "javadoc_summary": "Executes an INSERT statement and retrieves the auto-generated key using a custom extractor.",
              "contract": [
                "<p> This method allows custom extraction of generated keys, useful when dealing with composite keys or non-standard key generation."
              ],
              "examples": [],
              "see_also": [
                "#insert(BiRowMapper)",
                "#insert()"
              ]
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <ID> Optional<ID> insert(final Jdbc.BiRowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException",
              "return_type": "Optional<ID>",
              "type_params": [
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.BiRowMapper<? extends ID>",
                  "javadoc": "the extractor that receives both ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes an INSERT statement and retrieves the auto-generated key using a bi-row mapper.",
              "contract": [
                "<p> This method provides access to both the ResultSet and column labels when extracting generated keys, offering more flexibility than the standard row mapper."
              ],
              "examples": [],
              "see_also": [
                "#insert(RowMapper)"
              ]
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <ID> List<ID> batchInsert() throws SQLException",
              "return_type": "List<ID>",
              "type_params": [
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a batch INSERT statement and retrieves all generated keys as Long values.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#batchInsert(RowMapper)"
              ]
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <ID> List<ID> batchInsert(final Jdbc.RowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.RowMapper<? extends ID>",
                  "javadoc": "the extractor to retrieve the auto-generated keys from each row. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a batch INSERT statement and retrieves all generated keys using a custom extractor.",
              "contract": [
                "<p> This method allows custom extraction of generated keys from batch insert operations, useful when dealing with non-numeric keys or composite keys."
              ],
              "examples": [],
              "see_also": [
                "#batchInsert()",
                "#batchInsert(BiRowMapper)"
              ]
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <ID> List<ID> batchInsert(final Jdbc.BiRowMapper<? extends ID> autoGeneratedKeyExtractor) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.BiRowMapper<? extends ID>",
                  "javadoc": "the extractor that receives both ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a batch INSERT statement and retrieves all generated keys using a bi-row mapper.",
              "contract": [
                "<p> This method provides access to both the ResultSet and column labels when extracting generated keys from batch operations."
              ],
              "examples": [],
              "see_also": [
                "#batchInsert(RowMapper)"
              ]
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public int update() throws IllegalStateException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the SQL statement is not a DML statement"
                }
              ],
              "javadoc_summary": "Executes an UPDATE, INSERT, or DELETE statement and returns the number of affected rows.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#largeUpdate()",
                "#batchUpdate()"
              ]
            },
            {
              "name": "updateAndReturnGeneratedKeys",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<Integer, List<T>> updateAndReturnGeneratedKeys(final Jdbc.RowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<Integer, List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.RowMapper<T>",
                  "javadoc": "the extractor to retrieve the auto-generated keys. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided key extractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes an UPDATE/INSERT/DELETE statement and returns both the affected row count and generated keys.",
              "contract": [
                "<p> This method is useful when you need to perform an update operation that generates keys (e.g., an INSERT with auto-generated columns or an UPDATE that triggers key generation)."
              ],
              "examples": [],
              "see_also": [
                "#updateAndReturnGeneratedKeys(BiRowMapper)",
                "#update()"
              ]
            },
            {
              "name": "updateAndReturnGeneratedKeys",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<Integer, List<T>> updateAndReturnGeneratedKeys(final Jdbc.BiRowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<Integer, List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.BiRowMapper<T>",
                  "javadoc": "the extractor that receives both ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided key extractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes an UPDATE/INSERT/DELETE statement and returns both the affected row count and generated keys using a bi-row mapper.",
              "contract": [
                "<p> This method provides access to both the ResultSet and column labels when extracting generated keys from update operations."
              ],
              "examples": [],
              "see_also": [
                "#updateAndReturnGeneratedKeys(RowMapper)"
              ]
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public int[] batchUpdate() throws IllegalStateException, SQLException",
              "return_type": "int[]",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or any command in the batch fails"
                }
              ],
              "javadoc_summary": "Executes a batch of UPDATE/INSERT/DELETE statements and returns an array of update counts.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#largeBatchUpdate()",
                "#batchUpdateAndReturnGeneratedKeys(RowMapper)"
              ]
            },
            {
              "name": "batchUpdateAndReturnGeneratedKeys",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<int[], List<T>> batchUpdateAndReturnGeneratedKeys(final Jdbc.RowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<int[], List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.RowMapper<T>",
                  "javadoc": "the extractor to retrieve the auto-generated keys. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided key extractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a batch update operation and returns both the update counts and generated keys.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#batchUpdate()",
                "#batchUpdateAndReturnGeneratedKeys(BiRowMapper)"
              ]
            },
            {
              "name": "batchUpdateAndReturnGeneratedKeys",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<int[], List<T>> batchUpdateAndReturnGeneratedKeys(final Jdbc.BiRowMapper<T> autoGeneratedKeyExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<int[], List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "autoGeneratedKeyExtractor",
                  "type": "Jdbc.BiRowMapper<T>",
                  "javadoc": "the extractor that receives both ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided key extractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a batch update operation and returns both the update counts and generated keys using a bi-row mapper.",
              "contract": [
                "<p> This method provides access to both the ResultSet and column labels when extracting generated keys from batch update operations."
              ],
              "examples": [],
              "see_also": [
                "#batchUpdateAndReturnGeneratedKeys(RowMapper)"
              ]
            },
            {
              "name": "largeUpdate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public long largeUpdate() throws IllegalStateException, SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a large update operation that may affect more rows than can be represented by an int.",
              "contract": [
                "Use this method when working with very large tables or bulk operations."
              ],
              "examples": [],
              "see_also": [
                "#update()",
                "#largeBatchUpdate()"
              ]
            },
            {
              "name": "largeBatchUpdate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public long[] largeBatchUpdate() throws IllegalStateException, SQLException",
              "return_type": "long[]",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a large batch update operation that may affect more rows than can be represented by int values.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#batchUpdate()",
                "#largeUpdate()"
              ]
            },
            {
              "name": "execute",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean execute() throws IllegalStateException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the SQL statement which may return multiple results.",
              "contract": [
                "Use this method when the SQL statement may return multiple result sets, update counts, or a combination of both.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code boolean hasResultSet = JdbcUtil.prepareQuery(conn, \"CALL complex_procedure(?)\") .setInt(1, parameter) .execute(); if (hasResultSet) { // First result is a ResultSet // Use getResultSet() to retrieve it } else { // First result is an update count // Use getUpdateCount() to retrieve it } } </pre> <p> <b> Note: </b> The underlying statement will be closed after execution unless {@link #closeAfterExecution(boolean)} has been set to {@code false} ."
              ],
              "examples": [],
              "see_also": [
                "#executeThenApply(Throwables.Function)",
                "#executeThenApply(Throwables.BiFunction)",
                "#executeThenAccept(Throwables.Consumer)",
                "#executeThenAccept(Throwables.BiConsumer)"
              ]
            },
            {
              "name": "executeThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> R executeThenApply(final Throwables.Function<? super Stmt, ? extends R, SQLException> getter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "getter",
                  "type": "Throwables.Function<? super Stmt, ? extends R, SQLException>",
                  "javadoc": "the function to apply to the PreparedStatement after execution. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided function is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the SQL statement and applies the provided function to extract a result.",
              "contract": [
                "This is useful when you need to access statement metadata or handle complex result processing.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get the first result set after execution ResultSet rs = preparedQuery.executeThenApply(stmt -> stmt.getResultSet()); // Get update count and check warnings Integer count = preparedQuery.executeThenApply(stmt -> { int updateCount = stmt.getUpdateCount(); SQLWarning warning = stmt.getWarnings(); if (warning != null) { logger.warn(\"SQL Warning: \" + warning.getMessage()); } return updateCount; }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#execute()",
                "#executeThenApply(Throwables.BiFunction)"
              ]
            },
            {
              "name": "executeThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> R executeThenApply(final Throwables.BiFunction<? super Stmt, Boolean, ? extends R, SQLException> getter) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "getter",
                  "type": "Throwables.BiFunction<? super Stmt, Boolean, ? extends R, SQLException>",
                  "javadoc": "the function to apply to the PreparedStatement. The first parameter is the executed PreparedStatement, the second parameter indicates if the first result is a ResultSet object. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided function is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the SQL statement and applies the provided bi-function to extract a result.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process result based on type Object result = preparedQuery.executeThenApply((stmt, isResultSet) -> { if (isResultSet) { return processResultSet(stmt.getResultSet()); } else { return stmt.getUpdateCount(); } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#executeThenApply(Throwables.Function)"
              ]
            },
            {
              "name": "executeThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void executeThenAccept(final Throwables.Consumer<? super Stmt, SQLException> consumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "consumer",
                  "type": "Throwables.Consumer<? super Stmt, SQLException>",
                  "javadoc": "the consumer to apply to the PreparedStatement after execution. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided consumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the SQL statement and applies the provided consumer to process the statement.",
              "contract": [
                "This is useful for side effects or when you don't need to return a value.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Process warnings after execution preparedQuery.executeThenAccept(stmt -> { SQLWarning warning = stmt.getWarnings(); while (warning != null) { logger.warn(\"SQL Warning: \" + warning.getMessage()); warning = warning.getNextWarning(); } }); // Process multiple result sets preparedQuery.executeThenAccept(stmt -> { boolean hasMoreResults = true; while (hasMoreResults) { if (stmt.getUpdateCount() != -1) { System.out.println(\"Update count: \" + stmt.getUpdateCount()); } else { try (ResultSet rs = stmt.getResultSet()) { processResultSet(rs); } } hasMoreResults = stmt.getMoreResults(); } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#execute()",
                "#executeThenAccept(Throwables.BiConsumer)"
              ]
            },
            {
              "name": "executeThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void executeThenAccept(final Throwables.BiConsumer<? super Stmt, Boolean, SQLException> consumer) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "consumer",
                  "type": "Throwables.BiConsumer<? super Stmt, Boolean, SQLException>",
                  "javadoc": "the consumer to apply to the PreparedStatement. The first parameter is the executed PreparedStatement, the second parameter indicates if the first result is a ResultSet object. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided consumer is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the SQL statement and applies the provided bi-consumer to process the statement.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code preparedQuery.executeThenAccept((stmt, isResultSet) -> { if (isResultSet) { try (ResultSet rs = stmt.getResultSet()) { while (rs.next()) { System.out.println(\"Result: \" + rs.getString(1)); } } } else { System.out.println(\"Rows affected: \" + stmt.getUpdateCount()); } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#executeThenAccept(Throwables.Consumer)"
              ]
            },
            {
              "name": "asyncCall",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super This, ? extends R, SQLException> sqlAction) throws IllegalArgumentException, IllegalStateException",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Function<? super This, ? extends R, SQLException>",
                  "javadoc": "the SQL action to be executed asynchronously. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided SQL action is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Asynchronously executes the provided SQL action using this query instance.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#asyncCall(Throwables.Function, Executor)",
                "#asyncRun(Throwables.Consumer)"
              ]
            },
            {
              "name": "asyncCall",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super This, ? extends R, SQLException> sqlAction, final Executor executor) throws IllegalArgumentException, IllegalStateException",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Function<? super This, ? extends R, SQLException>",
                  "javadoc": "the SQL action to be executed asynchronously. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for asynchronous execution. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If sqlAction or executor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Asynchronously executes the provided SQL action using this query instance with a custom executor.",
              "contract": [
                "This is useful when you want to control the thread pool used for database operations."
              ],
              "examples": [],
              "see_also": [
                "#asyncCall(Throwables.Function)"
              ]
            },
            {
              "name": "asyncRun",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super This, SQLException> sqlAction) throws IllegalArgumentException, IllegalStateException",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Consumer<? super This, SQLException>",
                  "javadoc": "the SQL action to be executed asynchronously. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided SQL action is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Asynchronously executes the provided SQL action without returning a result.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#asyncRun(Throwables.Consumer, Executor)",
                "#asyncCall(Throwables.Function)"
              ]
            },
            {
              "name": "asyncRun",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super This, SQLException> sqlAction, final Executor executor) throws IllegalArgumentException, IllegalStateException",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Consumer<? super This, SQLException>",
                  "javadoc": "the SQL action to be executed asynchronously. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for asynchronous execution. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If sqlAction or executor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query is closed"
                }
              ],
              "javadoc_summary": "Asynchronously executes the provided SQL action without returning a result using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#asyncRun(Throwables.Consumer)"
              ]
            },
            {
              "name": "close",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public void close()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Closes this query instance and releases any resources associated with it.",
              "contract": [
                "If the instance is already closed, this method does nothing (idempotent).",
                "} finally { if (query != null) { query.close(); } } // Or use try-with-resources: try (AbstractQuery<?, ?> query = JdbcUtil.prepareQuery(conn, sql)) { // Use query..."
              ],
              "examples": [],
              "see_also": [
                "AutoCloseable#close()"
              ]
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.CallableQuery",
          "name": "CallableQuery",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "A wrapper class for {@link CallableStatement} that provides a fluent API for executing stored procedures and handling OUT parameters.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "setNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNull(final String parameterName, final int sqlType) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to set to {@code NULL} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code defined in {@link java.sql.Types} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to SQL {@code NULL} .",
              "contract": [
                "<p> <b> Note: </b> You must specify the SQL type of the parameter being set to {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNull(final String parameterName, final int sqlType, final String typeName) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to set to {@code NULL} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code from {@link java.sql.Types} (e.g., {@code STRUCT} , {@code REF} ).",
                  "nullability": "unspecified"
                },
                {
                  "name": "typeName",
                  "type": "String",
                  "javadoc": "the fully-qualified name of the SQL user-defined type.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to SQL {@code NULL} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBoolean(final String parameterName, final boolean x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "boolean",
                  "javadoc": "the boolean value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a boolean value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBoolean(final String parameterName, final Boolean x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Boolean",
                  "javadoc": "the Boolean value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Boolean value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setByte(final String parameterName, final byte x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "byte",
                  "javadoc": "the byte value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a byte value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setByte(final String parameterName, final Byte x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Byte",
                  "javadoc": "the Byte value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Byte value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setShort(final String parameterName, final short x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "short",
                  "javadoc": "the short value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a short value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setShort(final String parameterName, final Short x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Short",
                  "javadoc": "the Short value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Short value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setInt(final String parameterName, final int x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "int",
                  "javadoc": "the int value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an int value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setInt(final String parameterName, final Integer x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Integer",
                  "javadoc": "the Integer value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an Integer value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setLong(final String parameterName, final long x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "long",
                  "javadoc": "the long value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a long value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setLong(final String parameterName, final Long x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Long",
                  "javadoc": "the Long value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Long value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setLong(final String parameterName, final BigInteger x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger value as a long for the specified parameter.",
              "contract": [
                "The BigInteger must be within the range of a long value.",
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setFloat(final String parameterName, final float x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "float",
                  "javadoc": "the float value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a float value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setFloat(final String parameterName, final Float x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Float",
                  "javadoc": "the Float value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Float value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setDouble(final String parameterName, final double x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "double",
                  "javadoc": "the double value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a double value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setDouble(final String parameterName, final Double x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Double",
                  "javadoc": "the Double value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Double value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBigDecimal(final String parameterName, final BigDecimal x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigDecimal",
                  "javadoc": "the BigDecimal value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BigDecimal value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBigDecimal(final String parameterName, final BigInteger x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger value as a BigDecimal for the specified parameter.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigIntegerAsString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public CallableQuery setBigIntegerAsString(final String parameterName, final BigInteger x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set as string, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger value as a String for the specified parameter.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": [
                "#setString(String, BigInteger)",
                "#setBigDecimal(String, BigInteger)",
                "#setLong(String, BigInteger)"
              ]
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setString(final String parameterName, final String x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "String",
                  "javadoc": "the String value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a String value.",
              "contract": [
                "<p> <b> Null Handling: </b> If the {@code x} parameter is {@code null} , the database parameter will be set to SQL NULL.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Setting a non-null string value query.setString(\"firstName\", \"John\"); // Setting NULL when value is absent String middleName = getMiddleName(); // might return null query.setString(\"middleName\", middleName); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setString(final String parameterName, final CharSequence x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "CharSequence",
                  "javadoc": "the CharSequence value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a CharSequence value as a String for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setString(final String parameterName, final char x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "char",
                  "javadoc": "the char value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a char value as a String for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setString(final String parameterName, final Character x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Character",
                  "javadoc": "the Character value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Character value as a String for the specified parameter.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setString(final String parameterName, final BigInteger x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set as string, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a BigInteger value as a String for the specified parameter.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNString(final String parameterName, final String x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "String",
                  "javadoc": "the String value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a national character string value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setDate(final String parameterName, final java.sql.Date x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Date",
                  "javadoc": "the java.sql.Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Date value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setDate(final String parameterName, final java.util.Date x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the java.util.Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.util.Date value as a java.sql.Date for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setDate(final String parameterName, final LocalDate x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalDate",
                  "javadoc": "the LocalDate value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a LocalDate value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTime(final String parameterName, final java.sql.Time x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Time",
                  "javadoc": "the java.sql.Time value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Time value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTime(final String parameterName, final java.util.Date x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the java.util.Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.util.Date value as a java.sql.Time for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTime(final String parameterName, final LocalTime x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalTime",
                  "javadoc": "the LocalTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a LocalTime value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTimestamp(final String parameterName, final java.sql.Timestamp x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Timestamp",
                  "javadoc": "the java.sql.Timestamp value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Timestamp value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTimestamp(final String parameterName, final java.util.Date x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the java.util.Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a java.util.Date value as a java.sql.Timestamp for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTimestamp(final String parameterName, final LocalDateTime x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalDateTime",
                  "javadoc": "the LocalDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a LocalDateTime value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTimestamp(final String parameterName, final ZonedDateTime x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "ZonedDateTime",
                  "javadoc": "the ZonedDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a ZonedDateTime value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTimestamp(final String parameterName, final OffsetDateTime x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "OffsetDateTime",
                  "javadoc": "the OffsetDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an OffsetDateTime value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setTimestamp(final String parameterName, final Instant x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Instant",
                  "javadoc": "the Instant value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an Instant value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBytes(final String parameterName, final byte[] x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "byte[]",
                  "javadoc": "the byte array to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a byte array for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setAsciiStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setAsciiStream(final String parameterName, final InputStream inputStream) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the {@code InputStream} object containing the ASCII parameter value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an ASCII stream for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setAsciiStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setAsciiStream(final String parameterName, final InputStream inputStream, final long length) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the {@code InputStream} object containing the ASCII parameter value",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an ASCII stream for the specified parameter with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBinaryStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBinaryStream(final String parameterName, final InputStream inputStream) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the {@code InputStream} object containing the binary parameter value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a binary stream for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBinaryStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBinaryStream(final String parameterName, final InputStream inputStream, final long length) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the {@code InputStream} object containing the binary parameter value",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a binary stream for the specified parameter with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setCharacterStream(final String parameterName, final Reader reader) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the Unicode data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a character stream for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setCharacterStream(final String parameterName, final Reader reader, final long length) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the Unicode data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a character stream for the specified parameter with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNCharacterStream(final String parameterName, final Reader reader) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the Unicode data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a national character stream for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNCharacterStream(final String parameterName, final Reader reader, final long length) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the Unicode data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a national character stream for the specified parameter with a specified length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBlob(final String parameterName, final java.sql.Blob x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Blob",
                  "javadoc": "a Blob object that maps to a SQL BLOB value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Blob object for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBlob(final String parameterName, final InputStream inputStream) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the {@code InputStream} object containing the data to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Blob value using an InputStream for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setBlob(final String parameterName, final InputStream inputStream, final long length) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "inputStream",
                  "type": "InputStream",
                  "javadoc": "the {@code InputStream} object containing the data to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the parameter data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Blob value using an InputStream with a specified length for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setClob(final String parameterName, final java.sql.Clob x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Clob",
                  "javadoc": "a Clob object that maps to a SQL CLOB value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Clob object for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setClob(final String parameterName, final Reader reader) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the data to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Clob value using a Reader for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setClob(final String parameterName, final Reader reader, final long length) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the data to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the parameter data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a Clob value using a Reader with a specified length for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNClob(final String parameterName, final java.sql.NClob x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.NClob",
                  "javadoc": "an NClob object that maps to a SQL NCLOB value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an NClob object for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNClob(final String parameterName, final Reader reader) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the Unicode data to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an NClob value using a Reader for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setNClob(final String parameterName, final Reader reader, final long length) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the {@code Reader} object containing the Unicode data to set",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the parameter data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an NClob value using a Reader with a specified length for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setURL",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setURL(final String parameterName, final URL x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "URL",
                  "javadoc": "the java.net.URL object to be set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a URL value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setSQLXML",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setSQLXML(final String parameterName, final java.sql.SQLXML x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.SQLXML",
                  "javadoc": "an SQLXML object that maps to a SQL XML value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an SQLXML object for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setRowId",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setRowId(final String parameterName, final java.sql.RowId x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.RowId",
                  "javadoc": "the RowId object to be set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets a RowId object for the specified parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setObject(final String parameterName, final Object x) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the input parameter value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an object value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setObject(final String parameterName, final Object x, final int sqlType) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the input parameter value",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an object value for the specified parameter with a specified SQL type.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setObject(final String parameterName, final Object x, final int sqlType, final int scaleOrLength) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the input parameter value",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "scaleOrLength",
                  "type": "int",
                  "javadoc": "for {@code java.sql.Types.DECIMAL} or {@code java.sql.Types.NUMERIC} types, this is the number of digits after the decimal point. For all other types, this value will be ignored",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets an object value for the specified parameter with a specified SQL type and scale.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setParameters(final Map<String, ?> parameters) throws IllegalArgumentException, SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameters",
                  "type": "Map<String, ?>",
                  "javadoc": "a map containing parameter names as keys and their corresponding values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameters map is {@code null}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or any parameter name is not valid"
                }
              ],
              "javadoc_summary": "Sets multiple parameters from a Map where keys are parameter names and values are parameter values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery setParameters(final Object entity, final List<String> parameterNames) throws IllegalArgumentException, SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "Object",
                  "javadoc": "the entity object containing the parameter values. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterNames",
                  "type": "List<String>",
                  "javadoc": "a list of parameter names corresponding to properties in the entity. Each name should match a property name in the entity class.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the entity or parameterNames is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if a parameter name doesn't correspond to a valid property in the entity"
                }
              ],
              "javadoc_summary": "Sets multiple parameters for this CallableQuery by extracting values from an entity object.",
              "contract": [
                "Each parameter name in the list should correspond to a property name in the entity object."
              ],
              "examples": [],
              "see_also": [
                "Beans#getPropNameList(Class)",
                "Beans#getPropNames(Class, Collection)",
                "JdbcUtil#getNamedParameters(String)"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final int parameterIndex, final int sqlType) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter (starts from 1, not 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code as defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterIndex is invalid"
                }
              ],
              "javadoc_summary": "Registers a parameter as an OUT parameter with the specified SQL type.",
              "contract": [
                "<p> OUT parameters must be registered before the statement is executed.",
                "The SQL type specified should match the type of data the stored procedure will return for this parameter."
              ],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(int, int)",
                "java.sql.Types"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final int parameterIndex, final int sqlType, final int scale) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter (starts from 1, not 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code as defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "scale",
                  "type": "int",
                  "javadoc": "the number of digits to the right of the decimal point. Used for DECIMAL and NUMERIC types.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterIndex is invalid"
                }
              ],
              "javadoc_summary": "Registers a parameter as an OUT parameter with the specified SQL type and scale.",
              "contract": [
                "<p> The scale parameter is particularly important for fixed-point numeric types to ensure proper precision when retrieving the OUT parameter value."
              ],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(int, int, int)",
                "java.sql.Types#DECIMAL",
                "java.sql.Types#NUMERIC"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final int parameterIndex, final int sqlType, final String typeName) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter (starts from 1, not 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code as defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "typeName",
                  "type": "String",
                  "javadoc": "the fully-qualified SQL type name. For user-defined types, this should include the schema name if required.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterIndex is invalid"
                }
              ],
              "javadoc_summary": "Registers a parameter as an OUT parameter with a user-defined SQL type name.",
              "contract": [
                "This method is used for database-specific types, user-defined types (UDTs), or when you need to specify the exact SQL type name for proper type mapping.",
                "<p> The typeName parameter should be the fully-qualified SQL type name, which may include the schema name if required by the database."
              ],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(int, int, String)",
                "java.sql.Types#STRUCT",
                "java.sql.Types#DISTINCT",
                "java.sql.Types#JAVA_OBJECT"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final String parameterName, final int sqlType) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter as defined in the stored procedure",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code as defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterName is invalid"
                }
              ],
              "javadoc_summary": "Registers a named parameter as an OUT parameter with the specified SQL type.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(String, int)",
                "java.sql.Types"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final String parameterName, final int sqlType, final int scale) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter as defined in the stored procedure",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code as defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "scale",
                  "type": "int",
                  "javadoc": "the number of digits to the right of the decimal point",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterName is invalid"
                }
              ],
              "javadoc_summary": "Registers a named parameter as an OUT parameter with the specified SQL type and scale.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(String, int, int)",
                "java.sql.Types#DECIMAL",
                "java.sql.Types#NUMERIC"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final String parameterName, final int sqlType, final String typeName) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter as defined in the stored procedure",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code as defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "typeName",
                  "type": "String",
                  "javadoc": "the fully-qualified SQL type name",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterName is invalid"
                }
              ],
              "javadoc_summary": "Registers a named parameter as an OUT parameter with a user-defined SQL type name.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(String, int, String)",
                "java.sql.Types#STRUCT",
                "java.sql.Types#DISTINCT"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final int parameterIndex, final SQLType sqlType) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter (starts from 1, not 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterIndex is invalid"
                }
              ],
              "javadoc_summary": "Registers a parameter as an OUT parameter using the JDBC 4.2 {@link SQLType} interface.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(int, java.sql.SQLType)",
                "java.sql.JDBCType"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final int parameterIndex, final SQLType sqlType, final int scale) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter (starts from 1, not 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation",
                  "nullability": "unspecified"
                },
                {
                  "name": "scale",
                  "type": "int",
                  "javadoc": "the number of digits to the right of the decimal point",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterIndex is invalid"
                }
              ],
              "javadoc_summary": "Registers a parameter as an OUT parameter using {@link SQLType} with scale specification.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(int, java.sql.SQLType, int)",
                "java.sql.JDBCType#DECIMAL",
                "java.sql.JDBCType#NUMERIC"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final int parameterIndex, final SQLType sqlType, final String typeName) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the index of the parameter (starts from 1, not 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation",
                  "nullability": "unspecified"
                },
                {
                  "name": "typeName",
                  "type": "String",
                  "javadoc": "the fully-qualified SQL type name",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterIndex is invalid"
                }
              ],
              "javadoc_summary": "Registers a parameter as an OUT parameter using {@link SQLType} with a user-defined type name.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(int, java.sql.SQLType, String)",
                "java.sql.JDBCType#STRUCT",
                "java.sql.JDBCType#ARRAY"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final String parameterName, final SQLType sqlType) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter as defined in the stored procedure",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterName is invalid"
                }
              ],
              "javadoc_summary": "Registers a named parameter as an OUT parameter using the JDBC 4.2 {@link SQLType} interface.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(String, java.sql.SQLType)",
                "java.sql.JDBCType"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final String parameterName, final SQLType sqlType, final int scale) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter as defined in the stored procedure",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation",
                  "nullability": "unspecified"
                },
                {
                  "name": "scale",
                  "type": "int",
                  "javadoc": "the number of digits to the right of the decimal point",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterName is invalid"
                }
              ],
              "javadoc_summary": "Registers a named parameter as an OUT parameter using {@link SQLType} with scale specification.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(String, java.sql.SQLType, int)",
                "java.sql.JDBCType#DECIMAL"
              ]
            },
            {
              "name": "registerOutParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameter(final String parameterName, final SQLType sqlType, final String typeName) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter as defined in the stored procedure",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQL type from {@link java.sql.JDBCType} or vendor-specific implementation",
                  "nullability": "unspecified"
                },
                {
                  "name": "typeName",
                  "type": "String",
                  "javadoc": "the fully-qualified SQL type name",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if parameterName is invalid"
                }
              ],
              "javadoc_summary": "Registers a named parameter as an OUT parameter using {@link SQLType} with a user-defined type name.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.CallableStatement#registerOutParameter(String, java.sql.SQLType, String)",
                "java.sql.JDBCType#STRUCT"
              ]
            },
            {
              "name": "registerOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public CallableQuery registerOutParameters(final Jdbc.ParametersSetter<? super CallableQuery> register) throws IllegalArgumentException, SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "register",
                  "type": "Jdbc.ParametersSetter<? super CallableQuery>",
                  "javadoc": "the {@link Jdbc.ParametersSetter} that will register the OUT parameters. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if register is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs during parameter registration"
                }
              ],
              "javadoc_summary": "Registers multiple OUT parameters using a functional interface approach.",
              "contract": [
                "This method allows for more complex registration logic and is useful when you need to register multiple parameters based on dynamic conditions.",
                "If an exception occurs during registration, the statement is automatically closed.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code query.registerOutParameters(q -> { q.registerOutParameter(1, Types.INTEGER); q.registerOutParameter(2, Types.VARCHAR); if (includeDetails) { q.registerOutParameter(3, Types.CLOB); } }).execute(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "registerOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> CallableQuery registerOutParameters(final T parameter, final Jdbc.BiParametersSetter<? super CallableQuery, ? super T> register) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameter",
                  "type": "T",
                  "javadoc": "the context object to be passed to the {@code BiParametersSetter} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "register",
                  "type": "Jdbc.BiParametersSetter<? super CallableQuery, ? super T>",
                  "javadoc": "the {@link Jdbc.BiParametersSetter} that defines the registration logic. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs during parameter registration."
                }
              ],
              "javadoc_summary": "Registers multiple OUT parameters using a bi-functional interface and an additional context object.",
              "contract": [
                "If an exception occurs during registration, the statement is automatically closed.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code class ReportConfig { boolean includeTotal; boolean includeAvg; // getters } ReportConfig config = new ReportConfig(true, false); query.registerOutParameters(config, (q, cfg) -> { int paramIndex = 1; q.registerOutParameter(paramIndex++, Types.VARCHAR); // always return a status message if (cfg.includeTotal()) { q.registerOutParameter(paramIndex++, Types.DECIMAL); } if (cfg.includeAvg()) { q.registerOutParameter(paramIndex++, Types.DECIMAL, 2); } }).execute(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "executeThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public <R> R executeThenApply(final Throwables.Function<? super CallableStatement, ? extends R, SQLException> getter) throws SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "getter",
                  "type": "Throwables.Function<? super CallableStatement, ? extends R, SQLException>",
                  "javadoc": "the function to apply to the executed CallableStatement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the function throws an exception"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and applies the provided function to the executed CallableStatement.",
              "contract": [],
              "examples": [],
              "see_also": [
                "JdbcUtil#getOutParameters(CallableStatement, List)",
                "JdbcUtil#streamAllResultSets(Statement, Jdbc.ResultExtractor)",
                "JdbcUtil#streamAllResultSets(Statement, Jdbc.BiResultExtractor)"
              ]
            },
            {
              "name": "executeThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public <R> R executeThenApply(final Throwables.BiFunction<? super CallableStatement, Boolean, ? extends R, SQLException> getter) throws SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "getter",
                  "type": "Throwables.BiFunction<? super CallableStatement, Boolean, ? extends R, SQLException>",
                  "javadoc": "the bi-function to apply. The first parameter is the executed CallableStatement, the second parameter is {@code true} if the first result is a ResultSet, {@code false} otherwise",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the function throws an exception"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and applies the provided bi-function to the executed CallableStatement and a boolean indicating whether the first result is a ResultSet.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Object result = query.executeThenApply((stmt, isResultSet) -> { if (isResultSet) { ResultSet rs = stmt.getResultSet(); // Process result set } else { int updateCount = stmt.getUpdateCount(); // Process update count } return processedResult; }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "JdbcUtil#getOutParameters(CallableStatement, List)",
                "JdbcUtil#streamAllResultSets(Statement, Jdbc.ResultExtractor)"
              ]
            },
            {
              "name": "executeThenApply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> R executeThenApply(final Throwables.TriFunction<? super CallableStatement, List<Jdbc.OutParam>, Boolean, ? extends R, SQLException> getter) throws SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "getter",
                  "type": "Throwables.TriFunction<? super CallableStatement, List<Jdbc.OutParam>, Boolean, ? extends R, SQLException>",
                  "javadoc": "the tri-function to apply. Parameters are: 1. The executed CallableStatement 2. List of registered OUT parameters 3. Boolean indicating if the first result is a ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the function throws an exception"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and applies the provided tri-function to process the results with full access to the CallableStatement, OUT parameters, and result type information.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Map<String, Object> results = query.executeThenApply( (stmt, outParams, isResultSet) -> { Map<String, Object> map = new HashMap<>(); // Process OUT parameters for (Jdbc.OutParam param : outParams) { if (param.getParameterName() != null) { map.put(param.getParameterName(), stmt.getObject(param.getParameterName())); } } // Process result set if available if (isResultSet) { ResultSet rs = stmt.getResultSet(); // Add result set data to map } return map; } ); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Jdbc.OutParam",
                "JdbcUtil#getOutParameters(CallableStatement, List)"
              ]
            },
            {
              "name": "executeThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public void executeThenAccept(final Throwables.Consumer<? super CallableStatement, SQLException> consumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "consumer",
                  "type": "Throwables.Consumer<? super CallableStatement, SQLException>",
                  "javadoc": "the consumer to apply to the executed CallableStatement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and applies the provided consumer to the executed CallableStatement.",
              "contract": [
                "This method is useful when you need to perform side effects with the statement but don't need to return a value.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code query.executeThenAccept(stmt -> { // Log execution details logger.info(\"Warnings: \" + stmt.getWarnings()); // Process multiple result sets boolean hasResults = true; while (hasResults) { if (stmt.getResultSet() != null) { // Process result set } hasResults = stmt.getMoreResults(); } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "JdbcUtil#getOutParameters(CallableStatement, List)",
                "JdbcUtil#streamAllResultSets(Statement, Jdbc.ResultExtractor)"
              ]
            },
            {
              "name": "executeThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public void executeThenAccept(final Throwables.BiConsumer<? super CallableStatement, Boolean, SQLException> consumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "consumer",
                  "type": "Throwables.BiConsumer<? super CallableStatement, Boolean, SQLException>",
                  "javadoc": "the bi-consumer to apply. The first parameter is the executed CallableStatement, the second parameter is {@code true} if the first result is a ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and applies the provided bi-consumer to the executed CallableStatement and a boolean indicating the result type.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code query.executeThenAccept((stmt, isResultSet) -> { if (isResultSet) { ResultSet rs = stmt.getResultSet(); while (rs.next()) { System.out.println(rs.getString(1)); } } else { System.out.println(\"Updated rows: \" + stmt.getUpdateCount()); } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "JdbcUtil#getOutParameters(CallableStatement, List)"
              ]
            },
            {
              "name": "executeThenAccept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void executeThenAccept(final Throwables.TriConsumer<? super CallableStatement, List<Jdbc.OutParam>, Boolean, SQLException> consumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "consumer",
                  "type": "Throwables.TriConsumer<? super CallableStatement, List<Jdbc.OutParam>, Boolean, SQLException>",
                  "javadoc": "the tri-consumer to apply. Parameters are: 1. The executed CallableStatement 2. List of registered OUT parameters 3. Boolean indicating if the first result is a ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and applies the provided tri-consumer for processing with full access to all execution results.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code query.executeThenAccept((stmt, outParams, isResultSet) -> { // Log OUT parameters for (Jdbc.OutParam param : outParams) { if (param.getParameterName() != null) { logger.info(param.getParameterName() + \": \" + stmt.getObject(param.getParameterName())); } } // Process first result if (isResultSet) { ResultSet rs = stmt.getResultSet(); // Write results to file or external system } }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Jdbc.OutParam"
              ]
            },
            {
              "name": "executeAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Jdbc.OutParamResult executeAndGetOutParameters() throws IllegalStateException, SQLException",
              "return_type": "Jdbc.OutParamResult",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this CallableQuery is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and retrieves all OUT parameter values.",
              "contract": [
                "This method is used when you only need the OUT parameters and don't need to process any result sets returned by the procedure."
              ],
              "examples": [],
              "see_also": [
                "Jdbc.OutParamResult"
              ]
            },
            {
              "name": "queryAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Tuple2<Dataset, Jdbc.OutParamResult> queryAndGetOutParameters() throws SQLException",
              "return_type": "Tuple2<Dataset, Jdbc.OutParamResult>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns both the first result set (as a Dataset) and OUT parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#queryAndGetOutParameters(Jdbc.ResultExtractor)",
                "Dataset"
              ]
            },
            {
              "name": "queryAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> Tuple2<R, Jdbc.OutParamResult> queryAndGetOutParameters(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<R, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "the {@link Jdbc.ResultExtractor} to process the result set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this CallableQuery is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns both the first result set and OUT parameters, using a custom ResultExtractor to process the result set.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.ResultExtractor"
              ]
            },
            {
              "name": "queryAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> Tuple2<R, Jdbc.OutParamResult> queryAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<R, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "the {@link Jdbc.BiResultExtractor} to process the result set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if resultExtractor is null"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this CallableQuery is closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns both the first result set and OUT parameters, using a BiResultExtractor that has access to both the ResultSet and column labels.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Jdbc.BiResultExtractor"
              ]
            },
            {
              "name": "queryAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Tuple2<List<Dataset>, Jdbc.OutParamResult> queryAllResultsetsAndGetOutParameters() throws SQLException",
              "return_type": "Tuple2<List<Dataset>, Jdbc.OutParamResult>",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all result sets as Datasets along with OUT parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#queryAllResultsetsAndGetOutParameters(Jdbc.ResultExtractor)"
              ]
            },
            {
              "name": "queryAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> Tuple2<List<R>, Jdbc.OutParamResult> queryAllResultsetsAndGetOutParameters(final Jdbc.ResultExtractor<? extends R> resultExtractor) throws SQLException",
              "return_type": "Tuple2<List<R>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "the {@link Jdbc.ResultExtractor} to process each result set. Must not save or return the ResultSet itself.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all result sets along with OUT parameters, using a custom ResultExtractor to process each result set.",
              "contract": [
                "The extractor should not save or return the ResultSet itself as it will be closed after processing."
              ],
              "examples": [],
              "see_also": [
                "Jdbc.ResultExtractor"
              ]
            },
            {
              "name": "queryAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R> Tuple2<List<R>, Jdbc.OutParamResult> queryAllResultsetsAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws SQLException",
              "return_type": "Tuple2<List<R>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "the {@code BiResultExtractor} used to convert each result set to type R. Must not be {@code null} . The extractor receives the ResultSet and column labels. Warning: Do not save or return the ResultSet reference as it will be closed.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, the stored procedure fails, or the result extraction fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all result sets along with any OUT parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#query2ResultsetsAndGetOutParameters(BiResultExtractor, BiResultExtractor)",
                "#listAllResultsetsAndGetOutParameters(Class)"
              ]
            },
            {
              "name": "query2ResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R1, R2> Tuple3<R1, R2, Jdbc.OutParamResult> query2ResultsetsAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple3<R1, R2, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "R1",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R2",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor1",
                  "type": "Jdbc.BiResultExtractor<? extends R1>",
                  "javadoc": "the extractor for the first result set. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor2",
                  "type": "Jdbc.BiResultExtractor<? extends R2>",
                  "javadoc": "the extractor for the second result set. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if either {@code resultExtractor1} or {@code resultExtractor2} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns the first two result sets along with OUT parameters.",
              "contract": [
                "<p> If the stored procedure returns fewer than two result sets, the corresponding result values will be {@code null} .",
                "If more than two result sets are returned, only the first two are processed."
              ],
              "examples": [],
              "see_also": [
                "#query3ResultsetsAndGetOutParameters(BiResultExtractor, BiResultExtractor, BiResultExtractor)",
                "#queryAllResultsetsAndGetOutParameters(BiResultExtractor)"
              ]
            },
            {
              "name": "query3ResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public <R1, R2, R3> Tuple4<R1, R2, R3, Jdbc.OutParamResult> query3ResultsetsAndGetOutParameters(final Jdbc.BiResultExtractor<? extends R1> resultExtractor1, final Jdbc.BiResultExtractor<? extends R2> resultExtractor2, final Jdbc.BiResultExtractor<? extends R3> resultExtractor3) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple4<R1, R2, R3, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "R1",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R2",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R3",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultExtractor1",
                  "type": "Jdbc.BiResultExtractor<? extends R1>",
                  "javadoc": "the extractor for the first result set. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor2",
                  "type": "Jdbc.BiResultExtractor<? extends R2>",
                  "javadoc": "the extractor for the second result set. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor3",
                  "type": "Jdbc.BiResultExtractor<? extends R3>",
                  "javadoc": "the extractor for the third result set. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if any of the result extractors is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns the first three result sets along with OUT parameters.",
              "contract": [
                "<p> If the stored procedure returns fewer than three result sets, the corresponding result values will be {@code null} .",
                "If more than three result sets are returned, only the first three are processed."
              ],
              "examples": [],
              "see_also": [
                "#query2ResultsetsAndGetOutParameters(BiResultExtractor, BiResultExtractor)",
                "#queryAllResultsetsAndGetOutParameters(BiResultExtractor)"
              ]
            },
            {
              "name": "listAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Class<? extends T> targetType) throws IllegalArgumentException, SQLException",
              "return_type": "Tuple2<List<T>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of type T to map each row to. Must not be {@code null} . The class must have a default constructor.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code targetType} is {@code null}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, the stored procedure fails, or the mapping fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns the first result set as a list of objects along with any OUT parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#listAndGetOutParameters(RowMapper)",
                "#listAndGetOutParameters(BiRowMapper)"
              ]
            },
            {
              "name": "listAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<List<T>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} to convert each row to type T. Must not be {@code null} . The mapper is called once per row with the ResultSet positioned at that row.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code rowMapper} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, the stored procedure fails, or the row mapper throws an exception"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns the first result set as a list of objects along with any OUT parameters.",
              "contract": [
                "<p> The {@code RowMapper} receives the {@code ResultSet} positioned at each row and should extract the data to create an instance of type T.",
                "This method is useful when you need custom mapping logic that cannot be achieved with automatic mapping."
              ],
              "examples": [],
              "see_also": [
                "#listAndGetOutParameters(Class)",
                "#listAndGetOutParameters(RowFilter, RowMapper)"
              ]
            },
            {
              "name": "listAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws SQLException",
              "return_type": "Tuple2<List<T>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the {@code RowFilter} to test each row. Must not be {@code null} . Only rows where the filter returns {@code true} are mapped.",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} to convert filtered rows to type T. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns a filtered result set as a list along with OUT parameters.",
              "contract": [
                "This method allows you to filter rows before mapping, which can improve performance when you only need a subset of the returned data."
              ],
              "examples": [],
              "see_also": [
                "#listAndGetOutParameters(BiRowFilter, BiRowMapper)"
              ]
            },
            {
              "name": "listAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<List<T>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code rowMapper} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns the first result set as a list along with OUT parameters.",
              "contract": [
                "<p> The column labels list is retrieved once and reused for all rows, making this method efficient when you need column metadata for mapping decisions."
              ],
              "examples": [],
              "see_also": [
                "#listAndGetOutParameters(RowMapper)",
                "#listAndGetOutParameters(BiRowFilter, BiRowMapper)"
              ]
            },
            {
              "name": "listAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<T>, Jdbc.OutParamResult> listAndGetOutParameters(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws SQLException",
              "return_type": "Tuple2<List<T>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the {@code BiRowFilter} that receives ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns a filtered result set as a list along with OUT parameters.",
              "contract": [
                "<p> This method is ideal for complex scenarios where both filtering and mapping decisions depend on column metadata or when you need to handle dynamic result set structures.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Filter based on dynamic columns and map accordingly try (CallableQuery query = JdbcUtil.prepareCallableQuery(connection, \"{call search_products(?, ?, ?)}\")) { query.setString(1, searchTerm) .setInt(2, maxResults) .registerOutParameter(3, Types.INTEGER); // total matches Tuple2<List<Product>, Jdbc.OutParamResult> result = query.listAndGetOutParameters( (rs, labels) -> { // Only include products with a discount if the column exists if (labels.contains(\"discount_percent\")) { return rs.getDouble(\"discount_percent\") > 0; } return true; }, (rs, labels) -> { Product p = new Product(); p.setId(rs.getLong(\"id\")); p.setName(rs.getString(\"name\")); if (labels.contains(\"discount_percent\")) { p.setDiscountPercent(rs.getDouble(\"discount_percent\")); } return p; } ); List<Product> discountedProducts = result._1; int totalMatches = result._2.getOutParamValue(3); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#listAndGetOutParameters(RowFilter, RowMapper)"
              ]
            },
            {
              "name": "listAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Class<? extends T> targetType) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<List<List<T>>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map each row to. Must not be {@code null} . Applied to all result sets.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code targetType} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all result sets as lists along with OUT parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#listAllResultsetsAndGetOutParameters(RowMapper)",
                "#queryAllResultsetsAndGetOutParameters(BiResultExtractor)"
              ]
            },
            {
              "name": "listAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<List<List<T>>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} to apply to each row in all result sets. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code rowMapper} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all result sets as lists along with OUT parameters.",
              "contract": [
                "<p> The same {@code RowMapper} is applied to all result sets, so this method is best used when all result sets have the same structure or when the mapper can handle variations."
              ],
              "examples": [],
              "see_also": [
                "#listAllResultsetsAndGetOutParameters(Class)",
                "#listAllResultsetsAndGetOutParameters(RowFilter, RowMapper)"
              ]
            },
            {
              "name": "listAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<List<List<T>>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the {@code RowFilter} to apply to each row in all result sets. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends T>",
                  "javadoc": "the {@code RowMapper} to apply to filtered rows. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code rowFilter} or {@code rowMapper} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all filtered result sets as lists along with OUT parameters.",
              "contract": [
                "Rows that don't pass the filter are skipped entirely, which can significantly improve performance when processing large result sets."
              ],
              "examples": [],
              "see_also": [
                "#listAllResultsetsAndGetOutParameters(BiRowFilter, BiRowMapper)"
              ]
            },
            {
              "name": "listAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<List<List<T>>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code rowMapper} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all result sets as lists along with OUT parameters.",
              "contract": [
                "<p> This method is particularly useful when different result sets have different structures but can be mapped to the same target type, or when mapping logic depends on column metadata.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Handle result sets with varying columns try (CallableQuery query = JdbcUtil.prepareCallableQuery(connection, \"{call get_hierarchical_data(?)}\")) { query.setString(1, rootId); Tuple2<List<List<Node>>, Jdbc.OutParamResult> result = query.listAllResultsetsAndGetOutParameters((rs, labels) -> { Node node = new Node(); node.setId(rs.getString(\"id\")); node.setName(rs.getString(\"name\")); // Different result sets may have different attributes if (labels.contains(\"parent_id\")) { node.setParentId(rs.getString(\"parent_id\")); } if (labels.contains(\"level\")) { node.setLevel(rs.getInt(\"level\")); } if (labels.contains(\"children_count\")) { node.setChildrenCount(rs.getInt(\"children_count\")); } return node; }); List<Node> rootNodes = result._1.get(0); List<Node> childNodes = result._1.get(1); List<Node> leafNodes = result._1.get(2); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#listAllResultsetsAndGetOutParameters(RowMapper)"
              ]
            },
            {
              "name": "listAllResultsetsAndGetOutParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> Tuple2<List<List<T>>, Jdbc.OutParamResult> listAllResultsetsAndGetOutParameters(final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException, IllegalStateException, SQLException",
              "return_type": "Tuple2<List<List<T>>, Jdbc.OutParamResult>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the {@code BiRowFilter} that receives ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends T>",
                  "javadoc": "the {@code BiRowMapper} that receives ResultSet and column labels. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code rowFilter} or {@code rowMapper} is {@code null}"
                },
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this query has already been closed"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the stored procedure fails"
                }
              ],
              "javadoc_summary": "Executes the stored procedure and returns all filtered result sets as lists along with OUT parameters.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Complex filtering and mapping across heterogeneous result sets try (CallableQuery query = JdbcUtil.prepareCallableQuery(connection, \"{call analyze_customer_360(?)}\")) { query.setLong(1, customerId); Tuple2<List<List<CustomerData>>, Jdbc.OutParamResult> result = query.listAllResultsetsAndGetOutParameters( (rs, labels) -> { // Filter based on available columns if (labels.contains(\"is_active\")) { return rs.getBoolean(\"is_active\"); } else if (labels.contains(\"status\")) { return \"ACTIVE\".equals(rs.getString(\"status\")); } return true; // Include all rows if no status column }, (rs, labels) -> { CustomerData data = new CustomerData(); data.setType(determineTypeFromColumns(labels)); // Map common fields if (labels.contains(\"id\")) data.setId(rs.getLong(\"id\")); if (labels.contains(\"value\")) data.setValue(rs.getBigDecimal(\"value\")); // Map type-specific fields if (labels.contains(\"order_date\")) { data.setDate(rs.getTimestamp(\"order_date\")); data.setDescription(rs.getString(\"product_name\")); } else if (labels.contains(\"interaction_date\")) { data.setDate(rs.getTimestamp(\"interaction_date\")); data.setDescription(rs.getString(\"interaction_type\")); } return data; } ); List<CustomerData> orders = result._1.get(0); List<CustomerData> interactions = result._1.get(1); List<CustomerData> preferences = result._1.get(2); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#listAllResultsetsAndGetOutParameters(RowFilter, RowMapper)"
              ]
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.DBLock",
          "name": "DBLock",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "Provides a robust distributed locking mechanism leveraging a dedicated database table.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "lock",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public String lock(final String target)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "target",
                  "type": "String",
                  "javadoc": "the unique identifier of the resource to lock. Must not be {@code null} or empty.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Attempts to acquire a distributed lock on the specified target resource using default settings.",
              "contract": [
                "<p> If the lock is successfully acquired, a unique lock code is returned, which must be used to release the lock later.",
                "If the lock cannot be acquired within the timeout, {@code null} is returned.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, \"my_locks_table\"); String resourceIdentifier = \"report_generation_task\"; String lockCode = dbLock.lock(resourceIdentifier); if (lockCode != null) { try { System.out.println(\"Lock acquired for: \" + resourceIdentifier); // Perform the critical operation that requires exclusive access // ...",
                "} catch (InterruptedException e) { Thread.currentThread().interrupt(); System.err.println(\"Operation interrupted: \" + e.getMessage()); } finally { // Ensure the lock is released, even if an error occurs dbLock.unlock(resourceIdentifier, lockCode); System.out.println(\"Lock released for: \" + resourceIdentifier); } } else { System.out.println(\"Failed to acquire lock for: \" + resourceIdentifier + \" within default timeout.\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#lock(String, long, long)",
                "#DEFAULT_LOCK_LIVE_TIME",
                "#DEFAULT_TIMEOUT"
              ]
            },
            {
              "name": "lock",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public String lock(final String target, final long timeout)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "target",
                  "type": "String",
                  "javadoc": "the unique identifier of the resource to lock. Must not be {@code null} or empty.",
                  "nullability": "unspecified"
                },
                {
                  "name": "timeout",
                  "type": "long",
                  "javadoc": "the maximum time in milliseconds to wait for the lock. Must be non-negative.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Attempts to acquire a distributed lock on the specified target resource with a custom timeout.",
              "contract": [
                "If successful, a unique lock code is returned; otherwise, {@code null} is returned.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, \"my_locks_table\"); String resourceIdentifier = \"data_export_job\"; long customTimeout = 15 * 1000; // Wait up to 15 seconds String lockCode = dbLock.lock(resourceIdentifier, customTimeout); if (lockCode != null) { try { System.out.println(\"Lock acquired for: \" + resourceIdentifier); // Execute the data export logic // ..."
              ],
              "examples": [],
              "see_also": [
                "#lock(String, long, long, long)",
                "#DEFAULT_LOCK_LIVE_TIME"
              ]
            },
            {
              "name": "lock",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public String lock(final String target, final long liveTime, final long timeout)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "target",
                  "type": "String",
                  "javadoc": "the unique identifier of the resource to lock. Must not be {@code null} or empty.",
                  "nullability": "unspecified"
                },
                {
                  "name": "liveTime",
                  "type": "long",
                  "javadoc": "the duration in milliseconds for which the lock is valid. Must be positive.",
                  "nullability": "unspecified"
                },
                {
                  "name": "timeout",
                  "type": "long",
                  "javadoc": "the maximum time in milliseconds to wait for the lock. Must be non-negative.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Attempts to acquire a distributed lock on the specified target resource with custom lock duration (live time) and acquisition timeout.",
              "contract": [
                "<p> The acquired lock will automatically expire after {@code liveTime} milliseconds if not refreshed.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, \"my_locks_table\"); String resourceIdentifier = \"batch_processing_queue\"; long lockDuration = 10 * 60 * 1000; // Lock for 10 minutes long waitTimeout = 30 * 1000; // Wait up to 30 seconds to acquire String lockCode = dbLock.lock(resourceIdentifier, lockDuration, waitTimeout); if (lockCode != null) { try { System.out.println(\"Lock acquired for: \" + resourceIdentifier); // Execute the batch processing logic // ..."
              ],
              "examples": [],
              "see_also": [
                "#lock(String, long, long, long)"
              ]
            },
            {
              "name": "lock",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public String lock(final String target, final long liveTime, final long timeout, final long retryInterval) throws IllegalStateException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "target",
                  "type": "String",
                  "javadoc": "the unique identifier of the resource to lock. Must not be {@code null} or empty.",
                  "nullability": "unspecified"
                },
                {
                  "name": "liveTime",
                  "type": "long",
                  "javadoc": "the duration in milliseconds for which the lock is valid. Must be positive.",
                  "nullability": "unspecified"
                },
                {
                  "name": "timeout",
                  "type": "long",
                  "javadoc": "the maximum time in milliseconds to wait for the lock. Must be non-negative.",
                  "nullability": "unspecified"
                },
                {
                  "name": "retryInterval",
                  "type": "long",
                  "javadoc": "the time in milliseconds to wait between retry attempts. A value of 0 means immediate retry without delay. Must be non-negative.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this {@code DBLock} instance has been closed."
                }
              ],
              "javadoc_summary": "Attempts to acquire a distributed lock on the specified target resource with full control over lock duration, acquisition timeout, and retry behavior.",
              "contract": [
                "If the initial attempt fails (meaning another process holds the lock), it will repeatedly retry after {@code retryPeriod} milliseconds until the total {@code timeout} is reached.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, \"my_locks_table\"); String resourceIdentifier = \"inventory_update_process\"; long lockDuration = 5 * 60 * 1000; // Lock for 5 minutes long acquisitionTimeout = 10 * 1000; // Wait up to 10 seconds long retryInterval = 500; // Retry every 500 milliseconds String lockCode = dbLock.lock(resourceIdentifier, lockDuration, acquisitionTimeout, retryInterval); if (lockCode != null) { try { System.out.println(\"Lock acquired for: \" + resourceIdentifier); // Perform the inventory update // ..."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "unlock",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean unlock(final String target, final String code) throws IllegalStateException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "target",
                  "type": "String",
                  "javadoc": "the unique identifier of the resource whose lock is to be released. Must not be {@code null} or empty.",
                  "nullability": "unspecified"
                },
                {
                  "name": "code",
                  "type": "String",
                  "javadoc": "the unique code obtained during lock acquisition. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalStateException",
                  "condition": "if this {@code DBLock} instance has been closed."
                }
              ],
              "javadoc_summary": "Releases the distributed lock on the specified target resource.",
              "contract": [
                "The lock is released only if the provided {@code code} matches the unique code associated with the currently held lock for that target.",
                "<p> If the lock is successfully released, the corresponding entry is removed from the database table.",
                "If the lock does not exist, or if the provided code does not match the stored code, the operation will fail (return {@code false} ).",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, \"my_locks_table\"); String resourceIdentifier = \"configuration_update\"; String lockCode = dbLock.lock(resourceIdentifier, 30000, 5000); // Acquire lock for 30s, wait 5s if (lockCode != null) { try { System.out.println(\"Lock acquired for: \" + resourceIdentifier); // Perform configuration update // ...",
                "} finally { boolean released = dbLock.unlock(resourceIdentifier, lockCode); if (released) { System.out.println(\"Lock successfully released for: \" + resourceIdentifier); } else { System.err.println(\"Failed to release lock for: \" + resourceIdentifier + \"."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "close",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void close()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Closes this {@code DBLock} instance, releasing all associated resources.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBLock dbLock = JdbcUtil.getDBLock(dataSource, \"my_locks_table\"); try { // Perform operations using the DBLock instance String lockCode = dbLock.lock(\"some_resource\"); if (lockCode != null) { try { // ..."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "LOCKED",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"locked\"",
              "javadoc_summary": "Status constant indicating a locked state."
            },
            {
              "name": "UNLOCKED",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"unlocked\"",
              "javadoc_summary": "Status constant indicating an unlocked state."
            },
            {
              "name": "DEFAULT_LOCK_LIVE_TIME",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "3 * 60 * 1000",
              "javadoc_summary": "Default lock live time in milliseconds (3 minutes)."
            },
            {
              "name": "DEFAULT_TIMEOUT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "3 * 1000",
              "javadoc_summary": "Default timeout for lock acquisition in milliseconds (3 seconds)."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.DBProductInfo",
          "name": "DBProductInfo",
          "kind": "record",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A record that encapsulates database product information including the product name, version string, and parsed version enum.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "<init>",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "record DBProductInfo(String productName, String productVersion, DBVersion version) { // NOSONAR }",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "productName",
                  "type": "String",
                  "nullability": "unspecified"
                },
                {
                  "name": "productVersion",
                  "type": "String",
                  "nullability": "unspecified"
                },
                {
                  "name": "version",
                  "type": "DBVersion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.DBVersion",
          "name": "DBVersion",
          "kind": "enum",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enumeration representing various database products and their major versions.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "isMySQL",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean isMySQL()",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Checks if this {@code DBVersion} enum constant represents any variant of MySQL.",
              "contract": [
                "Checks if this {@code DBVersion} enum constant represents any variant of MySQL.",
                "<p> The check is performed by verifying if the enum constant's name starts with \"MySQL\" (case-insensitive).",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(connection); DBVersion currentDbVersion = dbInfo.version(); if (currentDbVersion.isMySQL()) { System.out.println(\"Connected to a MySQL database.\"); // Apply MySQL-specific SQL or optimizations } else { System.out.println(\"Not a MySQL database.\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isPostgreSQL",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean isPostgreSQL()",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Checks if this {@code DBVersion} enum constant represents any variant of PostgreSQL.",
              "contract": [
                "Checks if this {@code DBVersion} enum constant represents any variant of PostgreSQL.",
                "<p> The check is performed by verifying if the enum constant's name starts with \"PostgreSQL\" (case-insensitive).",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(connection); DBVersion currentDbVersion = dbInfo.version(); if (currentDbVersion.isPostgreSQL()) { System.out.println(\"Connected to a PostgreSQL database.\"); // Apply PostgreSQL-specific SQL or features like JSONB } else { System.out.println(\"Not a PostgreSQL database.\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "H2",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "H2 Database Engine."
            },
            {
              "name": "HSQLDB",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "HSQLDB (HyperSQL Database)."
            },
            {
              "name": "MySQL_5_5",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 5.5."
            },
            {
              "name": "MySQL_5_6",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 5.6."
            },
            {
              "name": "MySQL_5_7",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 5.7."
            },
            {
              "name": "MySQL_5_8",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 5.8."
            },
            {
              "name": "MySQL_5_9",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 5.9."
            },
            {
              "name": "MySQL_6",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 6.x."
            },
            {
              "name": "MySQL_7",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 7.x."
            },
            {
              "name": "MySQL_8",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 8.x."
            },
            {
              "name": "MySQL_9",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 9.x."
            },
            {
              "name": "MySQL_10",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MySQL version 10.x (MariaDB)."
            },
            {
              "name": "MySQL_OTHERS",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "Other MySQL versions not specifically enumerated."
            },
            {
              "name": "MariaDB",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "MariaDB (a fork of MySQL)."
            },
            {
              "name": "PostgreSQL_9_2",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 9.2."
            },
            {
              "name": "PostgreSQL_9_3",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 9.3."
            },
            {
              "name": "PostgreSQL_9_4",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 9.4."
            },
            {
              "name": "PostgreSQL_9_5",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 9.5."
            },
            {
              "name": "PostgreSQL_9_6",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 9.6."
            },
            {
              "name": "PostgreSQL_10",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 10.x."
            },
            {
              "name": "PostgreSQL_11",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 11.x."
            },
            {
              "name": "PostgreSQL_12",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "PostgreSQL version 12.x."
            },
            {
              "name": "PostgreSQL_OTHERS",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "Other PostgreSQL versions not specifically enumerated."
            },
            {
              "name": "Oracle",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "Oracle Database."
            },
            {
              "name": "DB2",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "IBM DB2 Database."
            },
            {
              "name": "SQL_Server",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "Microsoft SQL Server."
            },
            {
              "name": "OTHERS",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "DBVersion",
              "value": "new DBVersion()",
              "javadoc_summary": "Other database systems not specifically enumerated."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.EmptyHandler",
          "name": "EmptyHandler",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "A no-operation implementation of {@link Jdbc.Handler} for DAO instances.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "<init>",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public EmptyHandler()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Constructs a new EmptyHandler instance.",
              "contract": [
                "<p> This no-operation handler is used internally by the framework as a placeholder when no actual handling logic is required."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.FetchDirection",
          "name": "FetchDirection",
          "kind": "enum",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enumeration representing the direction in which rows of a {@link ResultSet} will be processed.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "valueOf",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static FetchDirection valueOf(final int intValue)",
              "return_type": "FetchDirection",
              "type_params": [],
              "params": [
                {
                  "name": "intValue",
                  "type": "int",
                  "javadoc": "the JDBC integer constant representing a fetch direction (e.g., {@link ResultSet#FETCH_FORWARD} , {@link ResultSet#FETCH_REVERSE} , {@link ResultSet#FETCH_UNKNOWN} ).",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns the {@code FetchDirection} enum constant that corresponds to the given JDBC integer constant value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "intValue",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public int intValue()",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the raw JDBC integer constant value associated with this {@code FetchDirection} .",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "FORWARD",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "FetchDirection",
              "value": "new FetchDirection(ResultSet.FETCH_FORWARD)",
              "javadoc_summary": "Indicates that rows in a {@link ResultSet} will be processed in a forward direction, from the first row to the last."
            },
            {
              "name": "REVERSE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "FetchDirection",
              "value": "new FetchDirection(ResultSet.FETCH_REVERSE)",
              "javadoc_summary": "Indicates that rows in a {@link ResultSet} will be processed in a reverse direction, from the last row to the first."
            },
            {
              "name": "UNKNOWN",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "FetchDirection",
              "value": "new FetchDirection(ResultSet.FETCH_UNKNOWN)",
              "javadoc_summary": "Indicates that the order in which rows in a {@link ResultSet} will be processed is unknown."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.IsolationLevel",
          "name": "IsolationLevel",
          "kind": "enum",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enumeration representing the standard transaction isolation levels defined by JDBC.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "intValue",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public int intValue()",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the raw JDBC integer constant value associated with this {@code IsolationLevel} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "valueOf",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static IsolationLevel valueOf(final int intValue)",
              "return_type": "IsolationLevel",
              "type_params": [],
              "params": [
                {
                  "name": "intValue",
                  "type": "int",
                  "javadoc": "the JDBC integer constant representing a transaction isolation level (e.g., {@link Connection#TRANSACTION_READ_COMMITTED} ).",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns the {@code IsolationLevel} enum constant that corresponds to the given JDBC integer constant value.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "DEFAULT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "IsolationLevel",
              "value": "new IsolationLevel(-1)",
              "javadoc_summary": "Represents the default transaction isolation level of the underlying database."
            },
            {
              "name": "NONE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "IsolationLevel",
              "value": "new IsolationLevel(Connection.TRANSACTION_NONE)",
              "javadoc_summary": "Indicates that transactions are not supported."
            },
            {
              "name": "READ_UNCOMMITTED",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "IsolationLevel",
              "value": "new IsolationLevel(Connection.TRANSACTION_READ_UNCOMMITTED)",
              "javadoc_summary": "The lowest transaction isolation level."
            },
            {
              "name": "READ_COMMITTED",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "IsolationLevel",
              "value": "new IsolationLevel(Connection.TRANSACTION_READ_COMMITTED)",
              "javadoc_summary": "Prevents \"dirty reads.\" At this isolation level, a transaction can only read data that has been committed by other transactions."
            },
            {
              "name": "REPEATABLE_READ",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "IsolationLevel",
              "value": "new IsolationLevel(Connection.TRANSACTION_REPEATABLE_READ)",
              "javadoc_summary": "Prevents \"dirty reads\" and \"non-repeatable reads.\" At this isolation level, a transaction is guaranteed to read the same data if it re-reads any row within the same transaction."
            },
            {
              "name": "SERIALIZABLE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "IsolationLevel",
              "value": "new IsolationLevel(Connection.TRANSACTION_SERIALIZABLE)",
              "javadoc_summary": "The highest transaction isolation level."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc",
          "name": "Jdbc",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "Provides a collection of utility interfaces and classes for simplifying JDBC operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.ParametersSetter",
          "name": "ParametersSetter",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for setting parameters on a prepared query statement.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "QS",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "accept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void accept(QS preparedQuery) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "preparedQuery",
                  "type": "QS",
                  "javadoc": "the prepared query statement (e.g., {@code PreparedStatement} ) to set parameters on.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or if the statement is closed."
                }
              ],
              "javadoc_summary": "Sets the parameters on the given prepared query statement.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "DO_NOTHING",
              "modifiers": [],
              "type": "ParametersSetter",
              "value": "(preparedQuery)->{ }",
              "javadoc_summary": "A no-operation parameter setter that does nothing."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.BiParametersSetter",
          "name": "BiParametersSetter",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for setting parameters on a prepared query using a parameter object.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "QS",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "accept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void accept(QS preparedQuery, T param) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "preparedQuery",
                  "type": "QS",
                  "javadoc": "the prepared query to set parameters on",
                  "nullability": "unspecified"
                },
                {
                  "name": "param",
                  "type": "T",
                  "javadoc": "the parameter object containing values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed {@code PreparedStatement}"
                }
              ],
              "javadoc_summary": "Sets the parameters on the given prepared query using the provided parameter object.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createForArray",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static <T> BiParametersSetter<PreparedStatement, T[]> createForArray(final List<String> fieldNameList, final Class<?> entityClass)",
              "return_type": "BiParametersSetter<PreparedStatement, T[]>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "fieldNameList",
                  "type": "List<String>",
                  "javadoc": "the list of property names from the {@code entityClass} . The order must match the order of values in the input array and the '?' placeholders in the SQL statement.",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class used to infer the data type for each parameter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiParametersSetter} for setting parameters from an array.",
              "contract": [
                "It should not be cached, shared, or used in parallel streams.",
                "A new instance should be created for each use."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createForList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static <T> BiParametersSetter<PreparedStatement, List<T>> createForList(final List<String> fieldNameList, final Class<?> entityClass)",
              "return_type": "BiParametersSetter<PreparedStatement, List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "fieldNameList",
                  "type": "List<String>",
                  "javadoc": "the list of property names from the {@code entityClass} . The order must match the order of values in the input list and the '?' placeholders in the SQL statement.",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class used to infer the data type for each parameter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiParametersSetter} for setting parameters from a {@code List} .",
              "contract": [
                "It should not be cached, shared, or used in parallel streams.",
                "A new instance should be created for each use."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "DO_NOTHING",
              "modifiers": [],
              "type": "BiParametersSetter",
              "value": "(preparedQuery,param)->{ }",
              "javadoc_summary": "A no-operation parameter setter that does nothing."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.TriParametersSetter",
          "name": "TriParametersSetter",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for setting parameters on a prepared query, providing access to the parsed SQL structure.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "QS",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "accept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void accept(ParsedSql parsedSql, QS preparedQuery, T param) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "parsedSql",
                  "type": "ParsedSql",
                  "javadoc": "the parsed SQL containing information about the query and its parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "preparedQuery",
                  "type": "QS",
                  "javadoc": "the prepared query to set parameters on",
                  "nullability": "unspecified"
                },
                {
                  "name": "param",
                  "type": "T",
                  "javadoc": "the parameter object containing values to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed {@code PreparedStatement}"
                }
              ],
              "javadoc_summary": "Sets parameters on the given prepared query using parsed SQL information and a parameter object.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "DO_NOTHING",
              "modifiers": [],
              "type": "TriParametersSetter",
              "value": "(TriParametersSetter<Object, Object>)(parsedSql,preparedQuery,param)->{ }",
              "javadoc_summary": "A no-operation parameter setter that does nothing."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.ResultExtractor",
          "name": "ResultExtractor",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for extracting a result from a {@code ResultSet} .",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "apply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override T apply(ResultSet rs) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} to extract data from; may be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs."
                }
              ],
              "javadoc_summary": "Extracts a result from the given {@code ResultSet} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "andThen",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <R> ResultExtractor<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)",
              "return_type": "ResultExtractor<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "after",
                  "type": "Throwables.Function<? super T, ? extends R, SQLException>",
                  "javadoc": "the function to apply after this extractor is applied",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed {@code ResultExtractor} that first applies this extractor to the {@code ResultSet} and then applies the {@code after} function to the result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toBiResultExtractor",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default BiResultExtractor<T> toBiResultExtractor()",
              "return_type": "BiResultExtractor<T>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Converts this {@code ResultExtractor} to a {@code BiResultExtractor} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> ResultExtractor<Map<K, V>> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor)",
              "return_type": "ResultExtractor<Map<K, V>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a {@code Map} .",
              "contract": [
                "If duplicate keys are encountered, an {@code IllegalStateException} will be thrown."
              ],
              "examples": [],
              "see_also": [
                "#toMap(RowMapper, RowMapper, BinaryOperator)"
              ]
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, M extends Map<K, V>> ResultExtractor<M> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)",
              "return_type": "ResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, V>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} .",
              "contract": [
                "If duplicate keys are encountered, an {@code IllegalStateException} will be thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> ResultExtractor<Map<K, V>> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction)",
              "return_type": "ResultExtractor<Map<K, V>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "mergeFunction",
                  "type": "BinaryOperator<V>",
                  "javadoc": "a function to resolve collisions between values associated with the same key",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a {@code Map} , with a specified function to merge values of duplicate keys.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Fn#throwingMerger()",
                "Fn#replacingMerger()",
                "Fn#ignoringMerger()"
              ]
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, M extends Map<K, V>> ResultExtractor<M> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction, final Supplier<? extends M> supplier)",
              "return_type": "ResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, V>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "mergeFunction",
                  "type": "BinaryOperator<V>",
                  "javadoc": "a function to resolve collisions between values associated with the same key",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} , with a specified function to merge values of duplicate keys.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Fn#throwingMerger()",
                "Fn#replacingMerger()",
                "Fn#ignoringMerger()"
              ]
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Deprecated static <K, V, D> ResultExtractor<Map<K, D>> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)",
              "return_type": "ResultExtractor<Map<K, D>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row, which is then fed into the collector",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} to process values associated with each key",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Replaced by {@link #groupTo(RowMapper, RowMapper, Collector)} which has a more descriptive name.",
                "for_removal": false
              },
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#groupTo(RowMapper, RowMapper, Collector)"
              ]
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Deprecated static <K, V, D, M extends Map<K, D>> ResultExtractor<M> toMap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)",
              "return_type": "ResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, D>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row, which is then fed into the collector",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} to process values associated with each key",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Replaced by {@link #groupTo(RowMapper, RowMapper, Collector, Supplier)} which has a more descriptive name.",
                "for_removal": false
              },
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#groupTo(RowMapper, RowMapper, Collector, Supplier)"
              ]
            },
            {
              "name": "toMultimap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> ResultExtractor<ListMultimap<K, V>> toMultimap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor)",
              "return_type": "ResultExtractor<ListMultimap<K, V>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a {@code ListMultimap} , where each key can be associated with multiple values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMultimap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, C extends Collection<V>, M extends Multimap<K, V, C>> ResultExtractor<M> toMultimap(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Supplier<? extends M> multimapSupplier)",
              "return_type": "ResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "C",
                  "bounds": [
                    "Collection<V>"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Multimap<K, V, C>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "multimapSupplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Multimap} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a custom {@code Multimap} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> ResultExtractor<Map<K, List<V>>> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor)",
              "return_type": "ResultExtractor<Map<K, List<V>>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a {@code Map} where each key is associated with a {@code List} of values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, M extends Map<K, List<V>>> ResultExtractor<M> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)",
              "return_type": "ResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, List<V>>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a custom {@code Map} where each key is associated with a {@code List} of values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, D> ResultExtractor<Map<K, D>> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)",
              "return_type": "ResultExtractor<Map<K, D>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} for aggregating values associated with each key",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, D, M extends Map<K, D>> ResultExtractor<M> groupTo(final RowMapper<? extends K> keyExtractor, final RowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)",
              "return_type": "ResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, D>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "RowMapper<? extends K>",
                  "javadoc": "a {@code RowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "RowMapper<? extends V>",
                  "javadoc": "a {@code RowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} for aggregating values associated with each key",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ResultExtractor<List<T>> toList(final RowMapper<? extends T> rowMapper)",
              "return_type": "ResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "RowMapper<? extends T>",
                  "javadoc": "the function to map each row to an element",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, where each object is created by applying the given {@code rowMapper} to each row.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ResultExtractor<List<T>> toList(final RowFilter rowFilter, final RowMapper<? extends T> rowMapper)",
              "return_type": "ResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "RowFilter",
                  "javadoc": "a predicate to filter rows from the result set",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "RowMapper<? extends T>",
                  "javadoc": "the function to map each accepted row to an element",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, including only the rows that satisfy the {@code rowFilter} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ResultExtractor<List<T>> toList(final Class<? extends T> targetClass)",
              "return_type": "ResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the entities to be created",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of entities.",
              "contract": [],
              "examples": [],
              "see_also": [
                "BiResultExtractor#toList(Class)"
              ]
            },
            {
              "name": "toMergedList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ResultExtractor<List<T>> toMergedList(final Class<? extends T> targetClass)",
              "return_type": "ResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the entities to create and merge",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} from a JOIN query into a {@code List} of merged entities.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Dataset#toMergedEntities(Class)"
              ]
            },
            {
              "name": "toMergedList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ResultExtractor<List<T>> toMergedList(final Class<? extends T> targetClass, final String idPropNameForMerge)",
              "return_type": "ResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the entities to create and merge",
                  "nullability": "unspecified"
                },
                {
                  "name": "idPropNameForMerge",
                  "type": "String",
                  "javadoc": "the property name to use for identifying unique entities to merge",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of merged entities, using a specific property to identify unique entities for merging.",
              "contract": [
                "This is useful when the default ID detection is not sufficient."
              ],
              "examples": [],
              "see_also": [
                "Dataset#toMergedEntities(Collection, Collection, Class)"
              ]
            },
            {
              "name": "toMergedList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ResultExtractor<List<T>> toMergedList(final Class<? extends T> targetClass, final Collection<String> idPropNamesForMerge)",
              "return_type": "ResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the entities to create and merge",
                  "nullability": "unspecified"
                },
                {
                  "name": "idPropNamesForMerge",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names that form the composite key for merging",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code List} of merged entities, using a composite key (multiple properties) to identify unique entities for merging.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Dataset#toMergedEntities(Collection, Collection, Class)"
              ]
            },
            {
              "name": "toDataset",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static ResultExtractor<Dataset> toDataset(final Class<?> entityClassForExtractor)",
              "return_type": "ResultExtractor<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClassForExtractor",
                  "type": "Class<?>",
                  "javadoc": "the class used to map column names to property types",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDataset",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static ResultExtractor<Dataset> toDataset(final Class<?> entityClassForExtractor, final Map<String, String> prefixAndFieldNameMap)",
              "return_type": "ResultExtractor<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClassForExtractor",
                  "type": "Class<?>",
                  "javadoc": "the class used to map fields from columns",
                  "nullability": "unspecified"
                },
                {
                  "name": "prefixAndFieldNameMap",
                  "type": "Map<String, String>",
                  "javadoc": "a map where keys are column prefixes and values are field name prefixes for dot notation",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} with custom field name mapping for nested objects.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDataset",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static ResultExtractor<Dataset> toDataset(final RowFilter rowFilter)",
              "return_type": "ResultExtractor<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "RowFilter",
                  "javadoc": "a predicate to filter rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} , including only the rows that satisfy the specified filter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDataset",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static ResultExtractor<Dataset> toDataset(final RowExtractor rowExtractor)",
              "return_type": "ResultExtractor<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "the custom row extractor to process each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} using a custom {@code RowExtractor} for fine-grained control over value extraction.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDataset",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static ResultExtractor<Dataset> toDataset(final RowFilter rowFilter, final RowExtractor rowExtractor)",
              "return_type": "ResultExtractor<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "RowFilter",
                  "javadoc": "a predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "the custom row extractor to process each accepted row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that converts a {@code ResultSet} into a {@code Dataset} using both a filter and a custom row extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <R> ResultExtractor<R> to(final Throwables.Function<Dataset, R, SQLException> after)",
              "return_type": "ResultExtractor<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "after",
                  "type": "Throwables.Function<Dataset, R, SQLException>",
                  "javadoc": "the function to apply to the intermediate {@code Dataset}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code ResultExtractor} that first converts the {@code ResultSet} to a {@code Dataset} and then applies a transformation function to it.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "TO_DATA_SET",
              "modifiers": [],
              "type": "ResultExtractor<Dataset>",
              "value": "(rs)->{ if (rs == null) { return N.newEmptyDataset(); } return JdbcUtil.extractData(rs); }",
              "javadoc_summary": "A pre-defined {@code ResultExtractor} that converts a {@code ResultSet} to a {@code Dataset} ."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.BiResultExtractor",
          "name": "BiResultExtractor",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for extracting a result from a {@code ResultSet} , with access to the list of column labels from the result set's metadata.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "apply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override T apply(ResultSet rs, List<String> columnLabels) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} to extract data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabels",
                  "type": "List<String>",
                  "javadoc": "the list of column labels from the result set's metadata",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Extracts a result from the given {@code ResultSet} using column label information.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "andThen",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <R> BiResultExtractor<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)",
              "return_type": "BiResultExtractor<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "after",
                  "type": "Throwables.Function<? super T, ? extends R, SQLException>",
                  "javadoc": "the function to apply after this extractor is applied",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed {@code BiResultExtractor} that first applies this extractor to the {@code ResultSet} and then applies the {@code after} function to the result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> BiResultExtractor<Map<K, V>> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor)",
              "return_type": "BiResultExtractor<Map<K, V>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a {@code Map} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, M extends Map<K, V>> BiResultExtractor<M> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)",
              "return_type": "BiResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, V>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> BiResultExtractor<Map<K, V>> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction)",
              "return_type": "BiResultExtractor<Map<K, V>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "mergeFunction",
                  "type": "BinaryOperator<V>",
                  "javadoc": "a function to resolve collisions for the same key",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a {@code Map} , with a specified function to merge values of duplicate keys.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Fn#throwingMerger()",
                "Fn#replacingMerger()",
                "Fn#ignoringMerger()"
              ]
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, M extends Map<K, V>> BiResultExtractor<M> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final BinaryOperator<V> mergeFunction, final Supplier<? extends M> supplier)",
              "return_type": "BiResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, V>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "mergeFunction",
                  "type": "BinaryOperator<V>",
                  "javadoc": "a function to resolve collisions for the same key",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that processes a {@code ResultSet} into a custom {@code Map} , with a specified function to merge values of duplicate keys.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Fn#throwingMerger()",
                "Fn#replacingMerger()",
                "Fn#ignoringMerger()"
              ]
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Deprecated static <K, V, D> BiResultExtractor<Map<K, D>> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)",
              "return_type": "BiResultExtractor<Map<K, D>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} to process values for each key",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Replaced by {@link #groupTo(BiRowMapper, BiRowMapper, Collector)} which has a more descriptive name.",
                "for_removal": false
              },
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#groupTo(BiRowMapper, BiRowMapper, Collector)"
              ]
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Deprecated static <K, V, D, M extends Map<K, D>> BiResultExtractor<M> toMap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)",
              "return_type": "BiResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, D>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} to process values for each key",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Replaced by {@link #groupTo(BiRowMapper, BiRowMapper, Collector, Supplier)} which has a more descriptive name.",
                "for_removal": false
              },
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#groupTo(BiRowMapper, BiRowMapper, Collector, Supplier)"
              ]
            },
            {
              "name": "toMultimap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> BiResultExtractor<ListMultimap<K, V>> toMultimap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor)",
              "return_type": "BiResultExtractor<ListMultimap<K, V>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a {@code ListMultimap} , where each key can be associated with multiple values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMultimap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, C extends Collection<V>, M extends Multimap<K, V, C>> BiResultExtractor<M> toMultimap(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Supplier<? extends M> multimapSupplier)",
              "return_type": "BiResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "C",
                  "bounds": [
                    "Collection<V>"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Multimap<K, V, C>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "multimapSupplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Multimap} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a custom {@code Multimap} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V> BiResultExtractor<Map<K, List<V>>> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor)",
              "return_type": "BiResultExtractor<Map<K, List<V>>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a {@code Map} where each key is associated with a {@code List} of values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, M extends Map<K, List<V>>> BiResultExtractor<M> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Supplier<? extends M> supplier)",
              "return_type": "BiResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, List<V>>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a custom {@code Map} where each key is associated with a {@code List} of values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, D> BiResultExtractor<Map<K, D>> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream)",
              "return_type": "BiResultExtractor<Map<K, D>>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} for aggregating values associated with each key",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "groupTo",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <K, V, D, M extends Map<K, D>> BiResultExtractor<M> groupTo(final BiRowMapper<? extends K> keyExtractor, final BiRowMapper<? extends V> valueExtractor, final Collector<? super V, ?, D> downstream, final Supplier<? extends M> supplier)",
              "return_type": "BiResultExtractor<M>",
              "type_params": [
                {
                  "name": "K",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "D",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "M",
                  "bounds": [
                    "Map<K, D>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "keyExtractor",
                  "type": "BiRowMapper<? extends K>",
                  "javadoc": "a {@code BiRowMapper} to extract the key from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueExtractor",
                  "type": "BiRowMapper<? extends V>",
                  "javadoc": "a {@code BiRowMapper} to extract the value from each row",
                  "nullability": "unspecified"
                },
                {
                  "name": "downstream",
                  "type": "Collector<? super V, ?, D>",
                  "javadoc": "the {@code Collector} for aggregating values associated with each key",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "Supplier<? extends M>",
                  "javadoc": "a {@code Supplier} that provides a new, empty {@code Map} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that groups rows into a custom {@code Map} and applies a downstream {@code Collector} to the values associated with each key.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> BiResultExtractor<List<T>> toList(final BiRowMapper<? extends T> rowMapper)",
              "return_type": "BiResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper",
                  "type": "BiRowMapper<? extends T>",
                  "javadoc": "the function to map each row to an element",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, where each object is created by applying the given {@code rowMapper} to each row.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> BiResultExtractor<List<T>> toList(final BiRowFilter rowFilter, final BiRowMapper<? extends T> rowMapper)",
              "return_type": "BiResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowFilter",
                  "type": "BiRowFilter",
                  "javadoc": "a predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "BiRowMapper<? extends T>",
                  "javadoc": "the function to map each accepted row to an element",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that converts a {@code ResultSet} into a {@code List} of objects, including only the rows that satisfy the {@code rowFilter} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> BiResultExtractor<List<T>> toList(final Class<? extends T> targetClass)",
              "return_type": "BiResultExtractor<List<T>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the entities to be created",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiResultExtractor} that converts a {@code ResultSet} into a {@code List} of entities.",
              "contract": [
                "While the returned {@code BiResultExtractor} itself is stateless, for performance-critical scenarios, consider creating the stateful {@code BiRowMapper} once and reusing it if the result set structure is consistent."
              ],
              "examples": [],
              "see_also": [
                "ResultExtractor#toList(Class)",
                "BiRowMapper#to(Class)"
              ]
            }
          ],
          "fields": [
            {
              "name": "TO_DATA_SET",
              "modifiers": [],
              "type": "BiResultExtractor<Dataset>",
              "value": "(rs,columnLabels)->{ if (rs == null) { return N.newEmptyDataset(); } return JdbcUtil.extractData(rs); }",
              "javadoc_summary": "A pre-defined {@code BiResultExtractor} that converts a {@code ResultSet} to a {@code Dataset} ."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.RowMapper",
          "name": "RowMapper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for mapping the current row of a {@code ResultSet} to an object.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "apply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override T apply(ResultSet rs) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} positioned at the row to be mapped",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs during column value retrieval"
                }
              ],
              "javadoc_summary": "Maps the current row of the given {@code ResultSet} to an object of type {@code T} .",
              "contract": [
                "This method should not advance the ResultSet cursor (e.g., call {@code rs.next()} )."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "andThen",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <R> RowMapper<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)",
              "return_type": "RowMapper<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "after",
                  "type": "Throwables.Function<? super T, ? extends R, SQLException>",
                  "javadoc": "the function to apply to the result of this mapper; must not be null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed {@code RowMapper} that first applies this mapper to the row and then applies the {@code after} function to the result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toBiRowMapper",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default BiRowMapper<T> toBiRowMapper()",
              "return_type": "BiRowMapper<T>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Converts this {@code RowMapper} to a {@code BiRowMapper} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "combine",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T, U> RowMapper<Tuple2<T, U>> combine(final RowMapper<? extends T> rowMapper1, final RowMapper<? extends U> rowMapper2)",
              "return_type": "RowMapper<Tuple2<T, U>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "U",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper1",
                  "type": "RowMapper<? extends T>",
                  "javadoc": "the first mapper; must not be null",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper2",
                  "type": "RowMapper<? extends U>",
                  "javadoc": "the second mapper; must not be null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Combines two {@code RowMapper} instances into a single mapper that returns a {@code Tuple2} containing the results of both.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "combine",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <A, B, C> RowMapper<Tuple3<A, B, C>> combine(final RowMapper<? extends A> rowMapper1, final RowMapper<? extends B> rowMapper2, final RowMapper<? extends C> rowMapper3)",
              "return_type": "RowMapper<Tuple3<A, B, C>>",
              "type_params": [
                {
                  "name": "A",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "B",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "C",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper1",
                  "type": "RowMapper<? extends A>",
                  "javadoc": "the first mapper; must not be null",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper2",
                  "type": "RowMapper<? extends B>",
                  "javadoc": "the second mapper; must not be null",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper3",
                  "type": "RowMapper<? extends C>",
                  "javadoc": "the third mapper; must not be null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Combines three {@code RowMapper} instances into a single mapper that returns a {@code Tuple3} containing the results of all three.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toArray",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static RowMapper<Object[]> toArray(final ColumnGetter<?> columnGetterForAll)",
              "return_type": "RowMapper<Object[]>",
              "type_params": [],
              "params": [
                {
                  "name": "columnGetterForAll",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the {@code ColumnGetter} used to retrieve the value for every column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowMapper} that maps all columns of a row to an {@code Object[]} .",
              "contract": [
                "It should not be cached, shared, or used in parallel streams.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code RowMapper<Object[]> arrayMapper = RowMapper.toArray(ColumnGetter.GET_OBJECT); // When applied to a row: Object[] rowData = arrayMapper.apply(rs); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static RowMapper<List<Object>> toList(final ColumnGetter<?> columnGetterForAll)",
              "return_type": "RowMapper<List<Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "columnGetterForAll",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the {@code ColumnGetter} used to retrieve the value for every column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowMapper} that maps all columns of a row to a {@code List<Object>} .",
              "contract": [
                "It should not be cached, shared, or used in parallel streams.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code RowMapper<List<Object>> listMapper = RowMapper.toList(ColumnGetter.GET_OBJECT); // When applied to a row: List<Object> rowData = listMapper.apply(rs); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toCollection",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static <C extends Collection<?>> RowMapper<C> toCollection(final ColumnGetter<?> columnGetterForAll, final IntFunction<? extends C> supplier)",
              "return_type": "RowMapper<C>",
              "type_params": [
                {
                  "name": "C",
                  "bounds": [
                    "Collection<?>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "columnGetterForAll",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the {@code ColumnGetter} used to retrieve the value for every column",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "IntFunction<? extends C>",
                  "javadoc": "a function that takes the column count and returns a new {@code Collection} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowMapper} that maps all columns of a row to a {@code Collection} .",
              "contract": [
                "It should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDisposableObjArray",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static RowMapper<DisposableObjArray> toDisposableObjArray()",
              "return_type": "RowMapper<DisposableObjArray>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowMapper} that maps a row to a reusable {@code DisposableObjArray} .",
              "contract": [
                "You must process or copy its contents before the next row is mapped."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDisposableObjArray",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static RowMapper<DisposableObjArray> toDisposableObjArray(final Class<?> entityClass)",
              "return_type": "RowMapper<DisposableObjArray>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the class used to infer the data type for each column based on matching property names",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowMapper} that maps a row to a reusable {@code DisposableObjArray} , using type information from an entity class to perform appropriate type conversions for each column.",
              "contract": [
                "You must process or copy its contents before the next row is mapped."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "builder",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static RowMapperBuilder builder()",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Creates a new {@code RowMapperBuilder} with a default column getter of {@code ColumnGetter.GET_OBJECT} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "builder",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static RowMapperBuilder builder(final ColumnGetter<?> defaultColumnGetter)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "defaultColumnGetter",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the default {@code ColumnGetter} to use for unconfigured columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a new {@code RowMapperBuilder} with the specified default column getter.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.RowMapper.RowMapperBuilder",
          "name": "RowMapperBuilder",
          "kind": "class",
          "modifiers": [
            "public",
            "static"
          ],
          "javadoc_summary": "A fluent builder for creating customized, stateful {@code RowMapper} instances.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "getBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getBoolean(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code boolean} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getByte(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code byte} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getShort(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code short} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getInt(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve an {@code int} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getLong(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code long} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getFloat(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code float} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getDouble(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code double} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getBigDecimal(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code BigDecimal} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getString(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code String} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getDate(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code java.sql.Date} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getTime(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code java.sql.Time} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getTimestamp(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code java.sql.Timestamp} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public RowMapperBuilder getObject(final int columnIndex)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "The default behavior already uses {@code ColumnGetter.GET_OBJECT} if no specific getter is set.",
                "for_removal": false
              },
              "javadoc_summary": "Configures the mapper to retrieve an {@code Object} value from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder getObject(final int columnIndex, final Class<?> type)",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Class<?>",
                  "javadoc": "the target class type to convert the column value to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve an object of a specific type from the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowMapperBuilder get(final int columnIndex, final ColumnGetter<?> columnGetter) throws IllegalArgumentException",
              "return_type": "RowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnGetter",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the custom {@code ColumnGetter} to use",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code columnIndex} is not positive or {@code columnGetter} is null"
                }
              ],
              "javadoc_summary": "Configures the mapper to use a custom {@code ColumnGetter} for the specified column index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toArray",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public RowMapper<Object[]> toArray()",
              "return_type": "RowMapper<Object[]>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Builds and returns a stateful {@code RowMapper} that maps each row to an {@code Object[]} .",
              "contract": [
                "<p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public RowMapper<List<Object>> toList()",
              "return_type": "RowMapper<List<Object>>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Builds and returns a stateful {@code RowMapper} that maps each row to a {@code List<Object>} .",
              "contract": [
                "<p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toCollection",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public <C extends Collection<?>> RowMapper<C> toCollection(final IntFunction<? extends C> supplier)",
              "return_type": "RowMapper<C>",
              "type_params": [
                {
                  "name": "C",
                  "bounds": [
                    "Collection<?>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "supplier",
                  "type": "IntFunction<? extends C>",
                  "javadoc": "a function that provides a new collection instance, given the column count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Builds and returns a stateful {@code RowMapper} that maps each row to a {@code Collection} .",
              "contract": [
                "<p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public RowMapper<Map<String, Object>> toMap()",
              "return_type": "RowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Builds and returns a stateful {@code RowMapper} that maps each row to a {@code Map<String, Object>} , where keys are the column labels.",
              "contract": [
                "<p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public RowMapper<Map<String, Object>> toMap(final IntFunction<? extends Map<String, Object>> mapSupplier)",
              "return_type": "RowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "mapSupplier",
                  "type": "IntFunction<? extends Map<String, Object>>",
                  "javadoc": "a function that provides a new map instance, given the column count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Builds and returns a stateful {@code RowMapper} that maps each row to a {@code Map<String, Object>} , using the provided supplier to create the map instance.",
              "contract": [
                "<p> <b> Warning: </b> The returned mapper is stateful and should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public <R> RowMapper<R> to(final Throwables.Function<DisposableObjArray, R, SQLException> finisher)",
              "return_type": "RowMapper<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "finisher",
                  "type": "Throwables.Function<DisposableObjArray, R, SQLException>",
                  "javadoc": "a function that transforms the row's values into the final result object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Builds a stateful {@code RowMapper} that processes row values into a final object using a custom finisher function.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public <R> RowMapper<R> to(final Throwables.BiFunction<List<String>, DisposableObjArray, R, SQLException> finisher)",
              "return_type": "RowMapper<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "finisher",
                  "type": "Throwables.BiFunction<List<String>, DisposableObjArray, R, SQLException>",
                  "javadoc": "a function that transforms column labels and row values into the final result object",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Builds a stateful {@code RowMapper} that uses a custom finisher function which receives both the column labels and the row values (as a {@code DisposableObjArray} ).",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.BiRowMapper",
          "name": "BiRowMapper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for mapping the current row of a {@code ResultSet} to an object, with access to the list of column labels.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "apply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override T apply(ResultSet rs, List<String> columnLabels) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} positioned at the row to be mapped",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabels",
                  "type": "List<String>",
                  "javadoc": "the list of column labels from the result set's metadata",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs during column value retrieval"
                }
              ],
              "javadoc_summary": "Maps the current row of the given {@code ResultSet} to an object of type {@code T} , using the provided list of column labels.",
              "contract": [
                "This method should not advance the ResultSet cursor."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "andThen",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <R> BiRowMapper<R> andThen(final Throwables.Function<? super T, ? extends R, SQLException> after)",
              "return_type": "BiRowMapper<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "after",
                  "type": "Throwables.Function<? super T, ? extends R, SQLException>",
                  "javadoc": "the function to apply to the result of this mapper; must not be null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed {@code BiRowMapper} that first applies this mapper to the row and then applies the {@code after} function to the result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toRowMapper",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @SequentialOnly @Stateful default RowMapper<T> toRowMapper()",
              "return_type": "RowMapper<T>",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "This method creates a stateful {@code RowMapper} that can be easily misused, leading to potential issues in multithreaded environments or when reused across different queries. It is recommended to use {@code BiRowMapper} directly where possible.",
                "for_removal": false
              },
              "javadoc_summary": "Converts this {@code BiRowMapper} to a stateful {@code RowMapper} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "RowMapper#toBiRowMapper()"
              ]
            },
            {
              "name": "combine",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T, U> BiRowMapper<Tuple2<T, U>> combine(final BiRowMapper<? extends T> rowMapper1, final BiRowMapper<? extends U> rowMapper2)",
              "return_type": "BiRowMapper<Tuple2<T, U>>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "U",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper1",
                  "type": "BiRowMapper<? extends T>",
                  "javadoc": "the first mapper; must not be null",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper2",
                  "type": "BiRowMapper<? extends U>",
                  "javadoc": "the second mapper; must not be null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Combines two {@code BiRowMapper} instances into a single mapper that returns a {@code Tuple2} containing the results of both.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "combine",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <A, B, C> BiRowMapper<Tuple3<A, B, C>> combine(final BiRowMapper<? extends A> rowMapper1, final BiRowMapper<? extends B> rowMapper2, final BiRowMapper<? extends C> rowMapper3)",
              "return_type": "BiRowMapper<Tuple3<A, B, C>>",
              "type_params": [
                {
                  "name": "A",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "B",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "C",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rowMapper1",
                  "type": "BiRowMapper<? extends A>",
                  "javadoc": "the first mapper; must not be null",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper2",
                  "type": "BiRowMapper<? extends B>",
                  "javadoc": "the second mapper; must not be null",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper3",
                  "type": "BiRowMapper<? extends C>",
                  "javadoc": "the third mapper; must not be null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Combines three {@code BiRowMapper} instances into a single mapper that returns a {@code Tuple3} containing the results of all three.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that maps a row to an instance of the specified {@code targetClass} .",
              "contract": [
                "It should not be cached or shared for use with different SQL queries (which may have different column structures), nor should it be used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final boolean ignoreNonMatchedColumns)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                },
                {
                  "name": "ignoreNonMatchedColumns",
                  "type": "boolean",
                  "javadoc": "if {@code true} , columns without a corresponding property in {@code targetClass} are ignored; if {@code false} , an {@code IllegalArgumentException} is thrown.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that maps a row to an instance of the specified {@code targetClass} , with an option to ignore columns in the {@code ResultSet} that do not have a matching property in the class.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final Predicate<? super String> columnNameFilter, final Function<? super String, String> columnNameConverter)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnNameFilter",
                  "type": "Predicate<? super String>",
                  "javadoc": "a predicate to filter which columns should be considered for mapping",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnNameConverter",
                  "type": "Function<? super String, String>",
                  "javadoc": "a function to transform column names before matching them to properties",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} with custom filtering and conversion for column names before mapping them to object properties.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final Predicate<? super String> columnNameFilter, final Function<? super String, String> columnNameConverter, final boolean ignoreNonMatchedColumns)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnNameFilter",
                  "type": "Predicate<? super String>",
                  "javadoc": "a predicate to filter which columns should be considered for mapping",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnNameConverter",
                  "type": "Function<? super String, String>",
                  "javadoc": "a function to transform column names before matching them to properties",
                  "nullability": "unspecified"
                },
                {
                  "name": "ignoreNonMatchedColumns",
                  "type": "boolean",
                  "javadoc": "if {@code true} , filtered columns without a corresponding property are ignored; if {@code false} , an {@code IllegalArgumentException} is thrown.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} with full customization over column filtering, name conversion, and handling of non-matched columns.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> entityClass, final Map<String, String> prefixAndFieldNameMap)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                },
                {
                  "name": "prefixAndFieldNameMap",
                  "type": "Map<String, String>",
                  "javadoc": "a map where keys are column prefixes and values are corresponding property paths",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} for a target entity class, using a map to resolve column name prefixes to nested property paths.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static <T> BiRowMapper<T> to(final Class<? extends T> entityClass, final Map<String, String> prefixAndFieldNameMap, final boolean ignoreNonMatchedColumns)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                },
                {
                  "name": "prefixAndFieldNameMap",
                  "type": "Map<String, String>",
                  "javadoc": "a map where keys are column prefixes and values are corresponding property paths",
                  "nullability": "unspecified"
                },
                {
                  "name": "ignoreNonMatchedColumns",
                  "type": "boolean",
                  "javadoc": "if {@code true} , columns without a matching property are ignored",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} with prefix-to-property mapping and an option to ignore non-matched columns.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static BiRowMapper<Map<String, Object>> toMap(final BiPredicate<String, Object> valueFilter, final IntFunction<? extends Map<String, Object>> mapSupplier)",
              "return_type": "BiRowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "valueFilter",
                  "type": "BiPredicate<String, Object>",
                  "javadoc": "a bi-predicate to test column names and their corresponding values",
                  "nullability": "unspecified"
                },
                {
                  "name": "mapSupplier",
                  "type": "IntFunction<? extends Map<String, Object>>",
                  "javadoc": "a function that provides a new map instance, given the column count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiRowMapper} that converts a row to a {@code Map} , including only the entries that satisfy the given key-value filter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final RowExtractor rowExtractor, final BiPredicate<String, Object> valueFilter, final IntFunction<? extends Map<String, Object>> mapSupplier)",
              "return_type": "BiRowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "the custom extractor to get values from the {@code ResultSet} row",
                  "nullability": "unspecified"
                },
                {
                  "name": "valueFilter",
                  "type": "BiPredicate<String, Object>",
                  "javadoc": "a bi-predicate to test column names and their corresponding values",
                  "nullability": "unspecified"
                },
                {
                  "name": "mapSupplier",
                  "type": "IntFunction<? extends Map<String, Object>>",
                  "javadoc": "a function that provides a new map instance, given the column count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that converts a row to a {@code Map} using a custom {@code RowExtractor} and then filters the results.",
              "contract": [
                "This method is useful when you need custom value extraction logic (via {@code RowExtractor} ) combined with filtering.",
                "It should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final Function<? super String, String> columnNameConverter)",
              "return_type": "BiRowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "columnNameConverter",
                  "type": "Function<? super String, String>",
                  "javadoc": "a function to transform column names into map keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that converts a row to a {@code Map} , applying a conversion function to each column name to generate the map keys.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final Function<? super String, String> columnNameConverter, final IntFunction<? extends Map<String, Object>> mapSupplier)",
              "return_type": "BiRowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "columnNameConverter",
                  "type": "Function<? super String, String>",
                  "javadoc": "a function to transform column names into map keys",
                  "nullability": "unspecified"
                },
                {
                  "name": "mapSupplier",
                  "type": "IntFunction<? extends Map<String, Object>>",
                  "javadoc": "a function that provides a new map instance, given the column count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that converts a row to a custom {@code Map} , applying a conversion function to each column name to generate the map keys.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final RowExtractor rowExtractor)",
              "return_type": "BiRowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "the custom extractor to get values from the {@code ResultSet} row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that converts a row to a {@code Map} using a custom {@code RowExtractor} .",
              "contract": [
                "This method is useful when you need custom value extraction logic for all columns, producing a HashMap with original column names as keys.",
                "It should not be cached, shared, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static BiRowMapper<Map<String, Object>> toMap(final RowExtractor rowExtractor, final Function<? super String, String> columnNameConverter, final IntFunction<? extends Map<String, Object>> mapSupplier)",
              "return_type": "BiRowMapper<Map<String, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "the custom extractor to get values from the row",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnNameConverter",
                  "type": "Function<? super String, String>",
                  "javadoc": "a function to transform column names into map keys",
                  "nullability": "unspecified"
                },
                {
                  "name": "mapSupplier",
                  "type": "IntFunction<? extends Map<String, Object>>",
                  "javadoc": "a function that provides a new map instance, given the column count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that converts a row to a custom {@code Map} using a {@code RowExtractor} and applying a conversion to the column names for keys.",
              "contract": [
                "It should not be cached, shared across different query structures, or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toArray",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta static BiRowMapper<Object[]> toArray(final ColumnGetter<?> columnGetterForAll)",
              "return_type": "BiRowMapper<Object[]>",
              "type_params": [],
              "params": [
                {
                  "name": "columnGetterForAll",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the {@code ColumnGetter} used for every column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiRowMapper} that maps all columns of a row to an {@code Object[]} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toList",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta static BiRowMapper<List<Object>> toList(final ColumnGetter<?> columnGetterForAll)",
              "return_type": "BiRowMapper<List<Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "columnGetterForAll",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the {@code ColumnGetter} used for every column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiRowMapper} that maps all columns of a row to a {@code List<Object>} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toCollection",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta static <C extends Collection<?>> BiRowMapper<C> toCollection(final ColumnGetter<?> columnGetterForAll, final IntFunction<? extends C> supplier)",
              "return_type": "BiRowMapper<C>",
              "type_params": [
                {
                  "name": "C",
                  "bounds": [
                    "Collection<?>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "columnGetterForAll",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the {@code ColumnGetter} used for every column",
                  "nullability": "unspecified"
                },
                {
                  "name": "supplier",
                  "type": "IntFunction<? extends C>",
                  "javadoc": "a function that takes the column count and returns a new {@code Collection} instance",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiRowMapper} that maps all columns of a row to a {@code Collection} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDisposableObjArray",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static BiRowMapper<DisposableObjArray> toDisposableObjArray()",
              "return_type": "BiRowMapper<DisposableObjArray>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that maps a row to a reusable {@code DisposableObjArray} .",
              "contract": [
                "You must process or copy its contents before the next row is mapped."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toDisposableObjArray",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static BiRowMapper<DisposableObjArray> toDisposableObjArray(final Class<?> entityClass)",
              "return_type": "BiRowMapper<DisposableObjArray>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the class used to infer the data type for each column based on matching property names",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowMapper} that maps a row to a reusable {@code DisposableObjArray} , using type information from an entity class to perform type conversions for each column.",
              "contract": [
                "You must process or copy its contents before the next row is mapped."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "builder",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static BiRowMapperBuilder builder()",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Creates a new {@code BiRowMapperBuilder} with a default column getter of {@code ColumnGetter.GET_OBJECT} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "builder",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static BiRowMapperBuilder builder(final ColumnGetter<?> defaultColumnGetter)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "defaultColumnGetter",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the default {@code ColumnGetter} to use for unconfigured columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a new {@code BiRowMapperBuilder} with the specified default column getter.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "TO_ARRAY",
              "modifiers": [],
              "type": "BiRowMapper<Object[]>",
              "value": "(rs,columnLabels)->{ final int columnCount = columnLabels.size(); final Object[] result = new Object[columnCount]; for (int i = 1; i <= columnCount; i++) { result[i - 1] = JdbcUtil.getColumnValue(rs, i); } return result; }",
              "javadoc_summary": "A pre-defined mapper that converts a row into an {@code Object[]} ."
            },
            {
              "name": "TO_LIST",
              "modifiers": [],
              "type": "BiRowMapper<List<Object>>",
              "value": "(rs,columnLabels)->{ final int columnCount = columnLabels.size(); final List<Object> result = new ArrayList<>(columnCount); for (int i = 1; i <= columnCount; i++) { result.add(JdbcUtil.getColumnValue(rs, i)); } return result; }",
              "javadoc_summary": "A pre-defined mapper that converts a row into a {@code List<Object>} ."
            },
            {
              "name": "TO_MAP",
              "modifiers": [],
              "type": "BiRowMapper<Map<String, Object>>",
              "value": "(rs,columnLabels)->{ final int columnCount = columnLabels.size(); final Map<String, Object> result = N.newHashMap(columnCount); for (int i = 1; i <= columnCount; i++) { result.put(columnLabels.get(i - 1), JdbcUtil.getColumnValue(rs, i)); } return result; }",
              "javadoc_summary": "A pre-defined mapper that converts a row into a {@code Map<String, Object>} , where keys are the column labels."
            },
            {
              "name": "TO_LINKED_HASH_MAP",
              "modifiers": [],
              "type": "BiRowMapper<Map<String, Object>>",
              "value": "(rs,columnLabels)->{ final int columnCount = columnLabels.size(); final Map<String, Object> result = N.newLinkedHashMap(columnCount); for (int i = 1; i <= columnCount; i++) { result.put(columnLabels.get(i - 1), JdbcUtil.getColumnValue(rs, i)); } return result; }",
              "javadoc_summary": "A pre-defined mapper that converts a row into a {@code LinkedHashMap<String, Object>} , preserving the order of columns from the {@code ResultSet} ."
            },
            {
              "name": "TO_ENTITY_ID",
              "modifiers": [],
              "type": "BiRowMapper<EntityId>",
              "value": "(rs,columnLabels)->{ final int columnCount = columnLabels.size(); final Seid entityId = Seid.of(Strings.EMPTY); for (int i = 1; i <= columnCount; i++) { entityId.set(columnLabels.get(i - 1), JdbcUtil.getColumnValue(rs, i)); } return entityId; }",
              "javadoc_summary": "A pre-defined mapper that converts a row into an {@code EntityId} ."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.BiRowMapper.BiRowMapperBuilder",
          "name": "BiRowMapperBuilder",
          "kind": "class",
          "modifiers": [
            "public",
            "static"
          ],
          "javadoc_summary": "A fluent builder for creating customized, stateful {@code BiRowMapper} instances.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "getBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getBoolean(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code boolean} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getByte(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code byte} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getShort(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code short} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getInt(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve an {@code int} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getLong(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code long} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getFloat(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code float} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getDouble(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code double} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getBigDecimal(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code BigDecimal} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getString(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code String} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getDate(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code java.sql.Date} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getTime(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code java.sql.Time} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getTimestamp(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve a {@code java.sql.Timestamp} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public BiRowMapperBuilder getObject(final String columnName)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "The default behavior already uses {@code ColumnGetter.GET_OBJECT} if no specific getter is set.",
                "for_removal": false
              },
              "javadoc_summary": "Configures the mapper to retrieve an {@code Object} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder getObject(final String columnName, final Class<?> type)",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Class<?>",
                  "javadoc": "the target class type to convert the column value to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the mapper to retrieve an object of a specific type from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public BiRowMapperBuilder get(final String columnName, final ColumnGetter<?> columnGetter) throws IllegalArgumentException",
              "return_type": "BiRowMapperBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnGetter",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the custom {@code ColumnGetter} to use for this column",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code columnName} is null/empty or {@code columnGetter} is null"
                }
              ],
              "javadoc_summary": "Configures the mapper to use a custom {@code ColumnGetter} for the specified column name.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public <T> BiRowMapper<T> to(final Class<? extends T> targetClass)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Builds and returns a stateful {@code BiRowMapper} that maps each row to an instance of the specified {@code targetClass} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "to",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public <T> BiRowMapper<T> to(final Class<? extends T> targetClass, final boolean ignoreNonMatchedColumns)",
              "return_type": "BiRowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to map rows to",
                  "nullability": "unspecified"
                },
                {
                  "name": "ignoreNonMatchedColumns",
                  "type": "boolean",
                  "javadoc": "if {@code true} , columns without a corresponding property are ignored",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Builds and returns a stateful {@code BiRowMapper} that maps each row to an instance of the specified {@code targetClass} , with an option to ignore columns that don't match any property.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.RowConsumer",
          "name": "RowConsumer",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for consuming a single row of a {@code ResultSet} without returning a value.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "accept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void accept(ResultSet rs) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} positioned at the current row to be consumed.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs."
                }
              ],
              "javadoc_summary": "Performs this operation on the given {@code ResultSet} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "andThen",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default RowConsumer andThen(final Throwables.Consumer<? super ResultSet, SQLException> after)",
              "return_type": "RowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "after",
                  "type": "Throwables.Consumer<? super ResultSet, SQLException>",
                  "javadoc": "the operation to perform after this operation.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed {@code RowConsumer} that performs, in sequence, this operation followed by the {@code after} operation.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toBiRowConsumer",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default BiRowConsumer toBiRowConsumer()",
              "return_type": "BiRowConsumer",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Converts this {@code RowConsumer} to a {@link BiRowConsumer} , which also accepts a list of column labels.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "create",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static RowConsumer create(final Throwables.ObjIntConsumer<? super ResultSet, SQLException> consumerForAll)",
              "return_type": "RowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "consumerForAll",
                  "type": "Throwables.ObjIntConsumer<? super ResultSet, SQLException>",
                  "javadoc": "the action to be performed for each column. The first parameter is the {@code ResultSet} , and the second is the 1-based column index.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowConsumer} that iterates over all columns in each row and applies the specified action.",
              "contract": [
                "Therefore, it should not be reused across different queries with varying column counts or used in parallel streams.",
                "A new instance should be created for each distinct query execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "oneOff",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static RowConsumer oneOff(final Consumer<DisposableObjArray> consumer)",
              "return_type": "RowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "consumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "the consumer to process the {@code DisposableObjArray} for each row.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowConsumer} that converts each row into a reusable {@code DisposableObjArray} and passes it to the specified consumer.",
              "contract": [
                "This consumer should not be reused across different queries with varying column counts or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "oneOff",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static RowConsumer oneOff(final Class<?> entityClass, final Consumer<DisposableObjArray> consumer)",
              "return_type": "RowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the class used to infer column types for fetching values from the {@code ResultSet} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "consumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "the consumer to process the typed {@code DisposableObjArray} for each row.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowConsumer} that converts each row into a reusable {@code DisposableObjArray} using type information from a specified entity class, then passes it to the consumer.",
              "contract": [
                "This consumer should not be reused across different queries or used in parallel streams."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "DO_NOTHING",
              "modifiers": [],
              "type": "RowConsumer",
              "value": "(rs)->{ }",
              "javadoc_summary": "A {@code RowConsumer} that performs no operation."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.BiRowConsumer",
          "name": "BiRowConsumer",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for consuming a single row of a {@code ResultSet} along with its column labels.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "accept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void accept(ResultSet rs, List<String> columnLabels) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} positioned at the current row to be consumed.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabels",
                  "type": "List<String>",
                  "javadoc": "the list of column labels from the result set metadata.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs."
                }
              ],
              "javadoc_summary": "Performs this operation on the given {@code ResultSet} and column labels.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "andThen",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default BiRowConsumer andThen(final Throwables.BiConsumer<? super ResultSet, ? super List<String>, SQLException> after)",
              "return_type": "BiRowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "after",
                  "type": "Throwables.BiConsumer<? super ResultSet, ? super List<String>, SQLException>",
                  "javadoc": "the operation to perform after this operation.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed {@code BiRowConsumer} that performs, in sequence, this operation followed by the {@code after} operation.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "create",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta static BiRowConsumer create(final Throwables.ObjIntConsumer<? super ResultSet, SQLException> consumerForAll)",
              "return_type": "BiRowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "consumerForAll",
                  "type": "Throwables.ObjIntConsumer<? super ResultSet, SQLException>",
                  "javadoc": "the action to be performed for each column. The first parameter is the {@code ResultSet} , and the second is the 1-based column index.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiRowConsumer} that iterates over all columns in each row and applies the specified action.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "oneOff",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static BiRowConsumer oneOff(final BiConsumer<List<String>, DisposableObjArray> consumer)",
              "return_type": "BiRowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "consumer",
                  "type": "BiConsumer<List<String>, DisposableObjArray>",
                  "javadoc": "the consumer to process the column labels and {@code DisposableObjArray} for each row.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowConsumer} that converts each row into a reusable {@code DisposableObjArray} and passes it, along with column labels, to the specified consumer.",
              "contract": [
                "This consumer should not be reused in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "oneOff",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@Beta @SequentialOnly @Stateful static BiRowConsumer oneOff(final Class<?> entityClass, final BiConsumer<List<String>, DisposableObjArray> consumer)",
              "return_type": "BiRowConsumer",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the class used to infer column types for fetching values from the {@code ResultSet} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "consumer",
                  "type": "BiConsumer<List<String>, DisposableObjArray>",
                  "javadoc": "the consumer to process the column labels and typed {@code DisposableObjArray} for each row.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code BiRowConsumer} that converts each row into a reusable {@code DisposableObjArray} using type information from a specified entity class.",
              "contract": [
                "This consumer should not be reused across different queries or in parallel streams."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "DO_NOTHING",
              "modifiers": [],
              "type": "BiRowConsumer",
              "value": "(rs,cls)->{ }",
              "javadoc_summary": "A {@code BiRowConsumer} that performs no operation."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.RowFilter",
          "name": "RowFilter",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface that represents a predicate (boolean-valued function) of one {@code ResultSet} argument.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "test",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override boolean test(final ResultSet rs) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} positioned at the current row.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs."
                }
              ],
              "javadoc_summary": "Evaluates this filter on the given {@code ResultSet} .",
              "contract": [
                "This method should be fast enough to avoid holding DB connections for a long time or slowing down overall performance."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "negate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default RowFilter negate()",
              "return_type": "RowFilter",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns a filter that represents the logical negation of this filter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "and",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default RowFilter and(final Throwables.Predicate<? super ResultSet, SQLException> other)",
              "return_type": "RowFilter",
              "type_params": [],
              "params": [
                {
                  "name": "other",
                  "type": "Throwables.Predicate<? super ResultSet, SQLException>",
                  "javadoc": "a {@code RowFilter} that will be logically-ANDed with this filter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed filter that represents a short-circuiting logical AND of this filter and another.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toBiRowFilter",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default BiRowFilter toBiRowFilter()",
              "return_type": "BiRowFilter",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Converts this {@code RowFilter} to a {@link BiRowFilter} , which also accepts a list of column labels.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "ALWAYS_TRUE",
              "modifiers": [],
              "type": "RowFilter",
              "value": "(rs)->true",
              "javadoc_summary": "A {@code RowFilter} that includes every row."
            },
            {
              "name": "ALWAYS_FALSE",
              "modifiers": [],
              "type": "RowFilter",
              "value": "(rs)->false",
              "javadoc_summary": "A {@code RowFilter} that excludes every row."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.BiRowFilter",
          "name": "BiRowFilter",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface that represents a predicate (boolean-valued function) of a {@code ResultSet} and its column labels.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "test",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override boolean test(ResultSet rs, List<String> columnLabels) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} positioned at the current row.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabels",
                  "type": "List<String>",
                  "javadoc": "the list of column labels from the result set metadata.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs."
                }
              ],
              "javadoc_summary": "Evaluates this filter on the given {@code ResultSet} and column labels.",
              "contract": [
                "This method should be fast enough to avoid holding DB connections for a long time or slowing down overall performance."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "negate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default BiRowFilter negate()",
              "return_type": "BiRowFilter",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns a filter that represents the logical negation of this filter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "and",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default BiRowFilter and(final Throwables.BiPredicate<? super ResultSet, ? super List<String>, SQLException> other)",
              "return_type": "BiRowFilter",
              "type_params": [],
              "params": [
                {
                  "name": "other",
                  "type": "Throwables.BiPredicate<? super ResultSet, ? super List<String>, SQLException>",
                  "javadoc": "a {@code BiRowFilter} that will be logically-ANDed with this filter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a composed filter that represents a short-circuiting logical AND of this filter and another.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "ALWAYS_TRUE",
              "modifiers": [],
              "type": "BiRowFilter",
              "value": "(rs,columnLabels)->true",
              "javadoc_summary": "A {@code BiRowFilter} that includes every row."
            },
            {
              "name": "ALWAYS_FALSE",
              "modifiers": [],
              "type": "BiRowFilter",
              "value": "(rs,columnLabels)->false",
              "javadoc_summary": "A {@code BiRowFilter} that excludes every row."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.RowExtractor",
          "name": "RowExtractor",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for extracting data from the current row of a {@code ResultSet} into a target {@code Object} array.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "accept",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void accept(final ResultSet rs, final Object[] outputRow) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} positioned at a valid row.",
                  "nullability": "unspecified"
                },
                {
                  "name": "outputRow",
                  "type": "Object[]",
                  "javadoc": "the array to be populated with data from the current row.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs."
                }
              ],
              "javadoc_summary": "Extracts data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createBy",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch)",
              "return_type": "RowExtractor",
              "type_params": [],
              "params": [
                {
                  "name": "entityClassForFetch",
                  "type": "Class<?>",
                  "javadoc": "the entity class whose properties guide the type mapping.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowExtractor} that maps {@code ResultSet} columns to an {@code Object} array based on the properties of the given entity class.",
              "contract": [
                "It should not be reused across queries with different column structures or in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createBy",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch, final Map<String, String> prefixAndFieldNameMap)",
              "return_type": "RowExtractor",
              "type_params": [],
              "params": [
                {
                  "name": "entityClassForFetch",
                  "type": "Class<?>",
                  "javadoc": "the entity class for type mapping.",
                  "nullability": "unspecified"
                },
                {
                  "name": "prefixAndFieldNameMap",
                  "type": "Map<String, String>",
                  "javadoc": "a map where keys are column prefixes and values are corresponding entity field prefixes.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowExtractor} based on an entity class, with custom mapping for column prefixes to field name prefixes.",
              "contract": [
                "<p> <b> Warning: </b> The returned extractor is stateful and should not be reused across different queries or in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createBy",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch, final List<String> columnLabels)",
              "return_type": "RowExtractor",
              "type_params": [],
              "params": [
                {
                  "name": "entityClassForFetch",
                  "type": "Class<?>",
                  "javadoc": "the entity class for type mapping.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabels",
                  "type": "List<String>",
                  "javadoc": "the explicit list of column labels to use for mapping.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowExtractor} based on an entity class, using a predefined list of column labels.",
              "contract": [
                "<p> <b> Warning: </b> The returned extractor is stateful and should not be reused across different queries or in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createBy",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "@SequentialOnly @Stateful static RowExtractor createBy(final Class<?> entityClassForFetch, final List<String> columnLabels, final Map<String, String> prefixAndFieldNameMap)",
              "return_type": "RowExtractor",
              "type_params": [],
              "params": [
                {
                  "name": "entityClassForFetch",
                  "type": "Class<?>",
                  "javadoc": "the entity class for type mapping.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabels",
                  "type": "List<String>",
                  "javadoc": "an optional list of column labels to use for mapping. If {@code null} , they are discovered from the {@code ResultSet} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "prefixAndFieldNameMap",
                  "type": "Map<String, String>",
                  "javadoc": "an optional map for mapping column prefixes to field name prefixes.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stateful {@code RowExtractor} with comprehensive customization options, including an entity class for type mapping, an explicit list of column labels, and a prefix map for complex mappings.",
              "contract": [
                "It should not be reused across queries with different column structures or in parallel streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "create",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static RowExtractorBuilder create(final ColumnGetter<?> defaultColumnGetter)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "defaultColumnGetter",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the default {@code ColumnGetter} to use.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@link RowExtractorBuilder} with a specified default {@code ColumnGetter} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "builder",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static RowExtractorBuilder builder()",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Creates a {@link RowExtractorBuilder} with a default behavior of retrieving all column values as {@code Object} instances using {@code ColumnGetter.GET_OBJECT} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "builder",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static RowExtractorBuilder builder(final ColumnGetter<?> defaultColumnGetter)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "defaultColumnGetter",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the default {@code ColumnGetter} to use for unconfigured columns.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@link RowExtractorBuilder} with a specified default {@code ColumnGetter} .",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.RowExtractor.RowExtractorBuilder",
          "name": "RowExtractorBuilder",
          "kind": "class",
          "modifiers": [
            "public",
            "static"
          ],
          "javadoc_summary": "A builder for creating customized {@link RowExtractor} instances.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "getBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getBoolean(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code boolean} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getByte(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code byte} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getShort(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code short} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getInt(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get an {@code int} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getLong(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code long} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getFloat(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code float} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getDouble(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code double} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getBigDecimal(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code BigDecimal} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getString(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code String} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getDate(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code java.sql.Date} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getTime(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code java.sql.Time} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getTimestamp(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get a {@code java.sql.Timestamp} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public RowExtractorBuilder getObject(final int columnIndex)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "The default behavior is {@link #getObject(int)} if no specific {@code ColumnGetter} is set for the column.",
                "for_removal": false
              },
              "javadoc_summary": "Configures the extractor to get an {@code Object} value from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder getObject(final int columnIndex, final Class<?> type)",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Class<?>",
                  "javadoc": "the class type to which the column value should be converted.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Configures the extractor to get an {@code Object} of a specific type from the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public RowExtractorBuilder get(final int columnIndex, final ColumnGetter<?> columnGetter) throws IllegalArgumentException",
              "return_type": "RowExtractorBuilder",
              "type_params": [],
              "params": [
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnGetter",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the custom {@code ColumnGetter} to use for this column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code columnIndex} is not positive or {@code columnGetter} is {@code null} ."
                }
              ],
              "javadoc_summary": "Configures the extractor to use a custom {@code ColumnGetter} for the specified column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "build",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SequentialOnly @Stateful public RowExtractor build()",
              "return_type": "RowExtractor",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Builds a stateful {@code RowExtractor} based on the configured column getters.",
              "contract": [
                "It should not be cached or reused across different queries or in parallel streams.",
                "A new instance should be built for each distinct query execution."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.ColumnGetter",
          "name": "ColumnGetter",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A functional interface for extracting a typed value from a specified column of a {@code ResultSet} .",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "V",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "apply",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "V apply(ResultSet rs, int columnIndex) throws SQLException",
              "return_type": "V",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the {@code ResultSet} to extract from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs."
                }
              ],
              "javadoc_summary": "Extracts a value from the specified column of the given {@code ResultSet} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ColumnGetter<T> get(final Class<? extends T> cls)",
              "return_type": "ColumnGetter<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cls",
                  "type": "Class<? extends T>",
                  "javadoc": "the class for which to get a {@code ColumnGetter} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves a cached or creates a new {@code ColumnGetter} for the specified class type.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static <T> ColumnGetter<T> get(final Type<? extends T> type)",
              "return_type": "ColumnGetter<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "type",
                  "type": "Type<? extends T>",
                  "javadoc": "the {@code Type} for which to get a {@code ColumnGetter} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves a cached or creates a new {@code ColumnGetter} for the specified Abacus-common {@code Type} .",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "GET_BOOLEAN",
              "modifiers": [],
              "type": "ColumnGetter<Boolean>",
              "value": "ResultSet::getBoolean",
              "javadoc_summary": "Predefined getter for {@code boolean} values."
            },
            {
              "name": "GET_BYTE",
              "modifiers": [],
              "type": "ColumnGetter<Byte>",
              "value": "ResultSet::getByte",
              "javadoc_summary": "Predefined getter for {@code byte} values."
            },
            {
              "name": "GET_SHORT",
              "modifiers": [],
              "type": "ColumnGetter<Short>",
              "value": "ResultSet::getShort",
              "javadoc_summary": "Predefined getter for {@code short} values."
            },
            {
              "name": "GET_INT",
              "modifiers": [],
              "type": "ColumnGetter<Integer>",
              "value": "ResultSet::getInt",
              "javadoc_summary": "Predefined getter for {@code int} values."
            },
            {
              "name": "GET_LONG",
              "modifiers": [],
              "type": "ColumnGetter<Long>",
              "value": "ResultSet::getLong",
              "javadoc_summary": "Predefined getter for {@code long} values."
            },
            {
              "name": "GET_FLOAT",
              "modifiers": [],
              "type": "ColumnGetter<Float>",
              "value": "ResultSet::getFloat",
              "javadoc_summary": "Predefined getter for {@code float} values."
            },
            {
              "name": "GET_DOUBLE",
              "modifiers": [],
              "type": "ColumnGetter<Double>",
              "value": "ResultSet::getDouble",
              "javadoc_summary": "Predefined getter for {@code double} values."
            },
            {
              "name": "GET_BIG_DECIMAL",
              "modifiers": [],
              "type": "ColumnGetter<BigDecimal>",
              "value": "ResultSet::getBigDecimal",
              "javadoc_summary": "Predefined getter for {@code BigDecimal} values."
            },
            {
              "name": "GET_STRING",
              "modifiers": [],
              "type": "ColumnGetter<String>",
              "value": "ResultSet::getString",
              "javadoc_summary": "Predefined getter for {@code String} values."
            },
            {
              "name": "GET_DATE",
              "modifiers": [],
              "type": "ColumnGetter<Date>",
              "value": "ResultSet::getDate",
              "javadoc_summary": "Predefined getter for {@code java.sql.Date} values."
            },
            {
              "name": "GET_TIME",
              "modifiers": [],
              "type": "ColumnGetter<Time>",
              "value": "ResultSet::getTime",
              "javadoc_summary": "Predefined getter for {@code java.sql.Time} values."
            },
            {
              "name": "GET_TIMESTAMP",
              "modifiers": [],
              "type": "ColumnGetter<Timestamp>",
              "value": "ResultSet::getTimestamp",
              "javadoc_summary": "Predefined getter for {@code java.sql.Timestamp} values."
            },
            {
              "name": "GET_BYTES",
              "modifiers": [],
              "type": "ColumnGetter<byte[]>",
              "value": "ResultSet::getBytes",
              "javadoc_summary": "Predefined getter for {@code byte[]} values."
            },
            {
              "name": "GET_BINARY_STREAM",
              "modifiers": [],
              "type": "ColumnGetter<InputStream>",
              "value": "ResultSet::getBinaryStream",
              "javadoc_summary": "Predefined getter for {@code InputStream} values."
            },
            {
              "name": "GET_CHARACTER_STREAM",
              "modifiers": [],
              "type": "ColumnGetter<Reader>",
              "value": "ResultSet::getCharacterStream",
              "javadoc_summary": "Predefined getter for {@code Reader} values."
            },
            {
              "name": "GET_BLOB",
              "modifiers": [],
              "type": "ColumnGetter<Blob>",
              "value": "ResultSet::getBlob",
              "javadoc_summary": "Predefined getter for {@code Blob} values."
            },
            {
              "name": "GET_CLOB",
              "modifiers": [],
              "type": "ColumnGetter<Clob>",
              "value": "ResultSet::getClob",
              "javadoc_summary": "Predefined getter for {@code Clob} values."
            },
            {
              "name": "GET_OBJECT",
              "modifiers": [],
              "type": "ColumnGetter",
              "value": "JdbcUtil::getColumnValue",
              "javadoc_summary": "Predefined getter for {@code Object} values, using {@code JdbcUtil.getColumnValue} for generic type handling."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.Columns",
          "name": "Columns",
          "kind": "class",
          "modifiers": [
            "public",
            "static",
            "final"
          ],
          "javadoc_summary": "A utility class containing helpers and constants for column-specific operations, primarily focused on single-column results.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.Columns.ColumnOne",
          "name": "ColumnOne",
          "kind": "class",
          "modifiers": [
            "public",
            "static",
            "final"
          ],
          "javadoc_summary": "A utility class providing predefined {@link RowMapper} and {@link BiParametersSetter} instances for operations on the first column of a {@code ResultSet} or the first parameter of a {@code PreparedStatement} .",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "getObject",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> RowMapper<T> getObject()",
              "return_type": "RowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [],
              "throws": [],
              "javadoc_summary": "Gets a generic {@code RowMapper} that extracts a value as an {@code Object} from the first column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> RowMapper<T> get(final Class<? extends T> firstColumnType)",
              "return_type": "RowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "firstColumnType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class of the value in the first column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Gets a {@code RowMapper} that extracts a value of the specified type from the first column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"cast\") public static <T> RowMapper<T> get(final Type<? extends T> type)",
              "return_type": "RowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "type",
                  "type": "Type<? extends T>",
                  "javadoc": "the {@code Type} of the value in the first column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Gets a {@code RowMapper} that extracts a value of the specified Abacus-common {@code Type} from the first column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "readJson",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> RowMapper<T> readJson(final Class<? extends T> targetType)",
              "return_type": "RowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to deserialize the JSON string into.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code RowMapper} that reads a JSON string from the first column and deserializes it into an object of the specified target type.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "readXml",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> RowMapper<T> readXml(final Class<? extends T> targetType)",
              "return_type": "RowMapper<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "targetType",
                  "type": "Class<? extends T>",
                  "javadoc": "the class to deserialize the XML string into.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code RowMapper} that reads an XML string from the first column and deserializes it into an object of the specified target type.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "set",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <T> BiParametersSetter<AbstractQuery, T> set(final Class<T> type)",
              "return_type": "BiParametersSetter<AbstractQuery, T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "type",
                  "type": "Class<T>",
                  "javadoc": "the class of the parameter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiParametersSetter} for setting a value of the specified type as the first parameter of a {@code PreparedStatement} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "set",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <T> BiParametersSetter<AbstractQuery, T> set(final Type<T> type)",
              "return_type": "BiParametersSetter<AbstractQuery, T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "type",
                  "type": "Type<T>",
                  "javadoc": "the {@code Type} of the parameter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code BiParametersSetter} for setting a value of the specified Abacus-common {@code Type} as the first parameter of a {@code PreparedStatement} .",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "GET_BOOLEAN",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Boolean>",
              "value": "(rs)->rs.getBoolean(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code boolean} value from the first column."
            },
            {
              "name": "GET_BYTE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Byte>",
              "value": "(rs)->rs.getByte(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code byte} value from the first column."
            },
            {
              "name": "GET_SHORT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Short>",
              "value": "(rs)->rs.getShort(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code short} value from the first column."
            },
            {
              "name": "GET_INT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Integer>",
              "value": "(rs)->rs.getInt(1)",
              "javadoc_summary": "A {@code RowMapper} for getting an {@code int} value from the first column."
            },
            {
              "name": "GET_LONG",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Long>",
              "value": "(rs)->rs.getLong(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code long} value from the first column."
            },
            {
              "name": "GET_FLOAT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Float>",
              "value": "(rs)->rs.getFloat(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code float} value from the first column."
            },
            {
              "name": "GET_DOUBLE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Double>",
              "value": "(rs)->rs.getDouble(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code double} value from the first column."
            },
            {
              "name": "GET_BIG_DECIMAL",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<BigDecimal>",
              "value": "(rs)->rs.getBigDecimal(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code BigDecimal} value from the first column."
            },
            {
              "name": "GET_STRING",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<String>",
              "value": "(rs)->rs.getString(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code String} value from the first column."
            },
            {
              "name": "GET_DATE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Date>",
              "value": "(rs)->rs.getDate(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code java.sql.Date} value from the first column."
            },
            {
              "name": "GET_TIME",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Time>",
              "value": "(rs)->rs.getTime(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code java.sql.Time} value from the first column."
            },
            {
              "name": "GET_TIMESTAMP",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Timestamp>",
              "value": "(rs)->rs.getTimestamp(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code java.sql.Timestamp} value from the first column."
            },
            {
              "name": "GET_BYTES",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<byte[]>",
              "value": "(rs)->rs.getBytes(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code byte[]} value from the first column."
            },
            {
              "name": "GET_BINARY_STREAM",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<InputStream>",
              "value": "(rs)->rs.getBinaryStream(1)",
              "javadoc_summary": "A {@code RowMapper} for getting an {@code InputStream} from the first column."
            },
            {
              "name": "GET_CHARACTER_STREAM",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Reader>",
              "value": "(rs)->rs.getCharacterStream(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code Reader} from the first column."
            },
            {
              "name": "GET_BLOB",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Blob>",
              "value": "(rs)->rs.getBlob(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code Blob} from the first column."
            },
            {
              "name": "GET_CLOB",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Clob>",
              "value": "(rs)->rs.getClob(1)",
              "javadoc_summary": "A {@code RowMapper} for getting a {@code Clob} from the first column."
            },
            {
              "name": "GET_OBJECT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "RowMapper<Object>",
              "value": "(rs)->JdbcUtil.getColumnValue(rs, 1)",
              "javadoc_summary": "A {@code RowMapper} for getting an {@code Object} value from the first column."
            },
            {
              "name": "SET_BOOLEAN",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Boolean>",
              "value": "(preparedQuery,x)->preparedQuery.setBoolean(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code boolean} value for the first parameter."
            },
            {
              "name": "SET_BYTE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Byte>",
              "value": "(preparedQuery,x)->preparedQuery.setByte(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code byte} value for the first parameter."
            },
            {
              "name": "SET_SHORT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Short>",
              "value": "(preparedQuery,x)->preparedQuery.setShort(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code short} value for the first parameter."
            },
            {
              "name": "SET_INT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Integer>",
              "value": "(preparedQuery,x)->preparedQuery.setInt(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting an {@code int} value for the first parameter."
            },
            {
              "name": "SET_LONG",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Long>",
              "value": "(preparedQuery,x)->preparedQuery.setLong(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code long} value for the first parameter."
            },
            {
              "name": "SET_FLOAT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Float>",
              "value": "(preparedQuery,x)->preparedQuery.setFloat(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code float} value for the first parameter."
            },
            {
              "name": "SET_DOUBLE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Double>",
              "value": "(preparedQuery,x)->preparedQuery.setDouble(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code double} value for the first parameter."
            },
            {
              "name": "SET_BIG_DECIMAL",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, BigDecimal>",
              "value": "(preparedQuery,x)->preparedQuery.setBigDecimal(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code BigDecimal} value for the first parameter."
            },
            {
              "name": "SET_STRING",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, String>",
              "value": "(preparedQuery,x)->preparedQuery.setString(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code String} value for the first parameter."
            },
            {
              "name": "SET_DATE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Date>",
              "value": "(preparedQuery,x)->preparedQuery.setDate(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code java.sql.Date} value for the first parameter."
            },
            {
              "name": "SET_TIME",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Time>",
              "value": "(preparedQuery,x)->preparedQuery.setTime(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code java.sql.Time} value for the first parameter."
            },
            {
              "name": "SET_TIMESTAMP",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Timestamp>",
              "value": "(preparedQuery,x)->preparedQuery.setTimestamp(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code java.sql.Timestamp} value for the first parameter."
            },
            {
              "name": "SET_DATE_JU",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, java.util.Date>",
              "value": "(preparedQuery,x)->preparedQuery.setDate(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code java.util.Date} as a SQL DATE for the first parameter."
            },
            {
              "name": "SET_TIME_JU",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, java.util.Date>",
              "value": "(preparedQuery,x)->preparedQuery.setTime(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code java.util.Date} as a SQL TIME for the first parameter."
            },
            {
              "name": "SET_TIMESTAMP_JU",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, java.util.Date>",
              "value": "(preparedQuery,x)->preparedQuery.setTimestamp(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code java.util.Date} as a SQL TIMESTAMP for the first parameter."
            },
            {
              "name": "SET_BYTES",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, byte[]>",
              "value": "(preparedQuery,x)->preparedQuery.setBytes(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code byte[]} value for the first parameter."
            },
            {
              "name": "SET_BINARY_STREAM",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, InputStream>",
              "value": "(preparedQuery,x)->preparedQuery.setBinaryStream(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting an {@code InputStream} for the first parameter."
            },
            {
              "name": "SET_CHARACTER_STREAM",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Reader>",
              "value": "(preparedQuery,x)->preparedQuery.setCharacterStream(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code Reader} for the first parameter."
            },
            {
              "name": "SET_BLOB",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Blob>",
              "value": "(preparedQuery,x)->preparedQuery.setBlob(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code Blob} value for the first parameter."
            },
            {
              "name": "SET_CLOB",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Clob>",
              "value": "(preparedQuery,x)->preparedQuery.setClob(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting a {@code Clob} value for the first parameter."
            },
            {
              "name": "SET_OBJECT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "BiParametersSetter<AbstractQuery, Object>",
              "value": "(preparedQuery,x)->preparedQuery.setObject(1, x)",
              "javadoc_summary": "A {@code BiParametersSetter} for setting an {@code Object} value for the first parameter."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.OutParam",
          "name": "OutParam",
          "kind": "class",
          "modifiers": [
            "public",
            "static",
            "final"
          ],
          "javadoc_summary": "Represents an output parameter for a stored procedure call.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "<init>",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "class OutParam { /** * The 1-based index of the parameter in the stored procedure call. */ private int parameterIndex; /** * The name of the parameter. This is optional and used for named parameter calls. */ private String parameterName; /** * The SQL type of the parameter, as defined in {@code java.sql.Types}. */ private int sqlType; /** * The database-specific type name. This is generally used for user-defined or complex types. */ private String typeName; /** * The number of digits to the right of the decimal point, for {@code DECIMAL} or {@code NUMERIC} types. */ private int scale; /** * A factory method to create an {@code OutParam} with the specified index and SQL type. * * @param parameterIndex the 1-based index of the parameter. * @param sqlType the SQL type from {@code java.sql.Types}. * @return a new {@code OutParam} instance. */ public static OutParam of(int parameterIndex, int sqlType) { final OutParam outParam = new OutParam(); outParam.setParameterIndex(parameterIndex); outParam.setSqlType(sqlType); return outParam; } } /** * A container for the results of output parameters from a stored procedure execution. * It provides methods to retrieve parameter values by their index or name. */ @EqualsAndHashCode @ToString public static final class OutParamResult { private final List<OutParam> outParams; private final Map<Object, Object> outParamValues; /** * Constructs an {@code OutParamResult} with the specified output parameters and their values. * * @param outParams the list of {@code OutParam} definitions. * @param outParamValues a map of output parameter values, keyed by index or name. */ OutParamResult(final List<OutParam> outParams, final Map<Object, Object> outParamValues) { this.outParams = outParams; this.outParamValues = outParamValues; } /** * Retrieves the value of an output parameter by its 1-based index. * * @param <T> expected parameter value type * @param parameterIndex the 1-based index of the parameter. * @return the parameter value, cast to type {@code T}. May be {@code null}. */ public <T> T getOutParamValue(final int parameterIndex) { return (T) outParamValues.get(parameterIndex); } /** * Retrieves the value of an output parameter by its name. * * @param <T> expected parameter value type * @param parameterName the name of the parameter. * @return the parameter value, cast to type {@code T}. May be {@code null}. */ public <T> T getOutParamValue(final String parameterName) { return (T) outParamValues.get(parameterName); } /** * Returns a map containing all output parameter values. The keys of the map are * either the parameter index ({@code Integer}) or name ({@code String}). * * @return an unmodifiable map of all output parameter values. */ public Map<Object, Object> getOutParamValues() { return outParamValues; } /** * Returns the list of {@link OutParam} definitions that were used to register the output parameters. * * @return an unmodifiable list of {@code OutParam} objects. */ public List<OutParam> getOutParams() { return outParams; } } /** * A handler interface for intercepting method invocations on DAO proxies, similar to an Aspect-Oriented * Programming (AOP) interceptor. It allows for executing custom logic before and after a DAO method is called. * * <p><b>Usage Examples:</b></p> * <pre>{@code * Handler<UserDao> loggingHandler = new Handler<>() { * public void beforeInvoke(UserDao proxy, Object[] args, Tuple3<Method, ..., ...> sig) { * System.out.println(\"Calling method: \" + sig._1.getName()); * } * public void afterInvoke(Object result, UserDao proxy, Object[] args, Tuple3<Method, ..., ...> sig) { * System.out.println(\"Method returned: \" + result); * } * }; * }</pre> * * @param <P> DAO proxy type */ @Beta public interface Handler<P> { /** * This method is invoked before the actual DAO method is called. It can be used for * logging, argument validation, security checks, or transaction management. * * @param proxy the proxy instance on which the method was invoked. * @param args the arguments passed to the method. * @param methodSignature a tuple containing the {@code Method} object, a list of parameter types, and the return type. */ @SuppressWarnings(\"unused\") default void beforeInvoke(final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { // empty action. } /** * This method is invoked after the DAO method completes, whether successfully or with an exception. * It can be used for logging results, result transformation, or resource cleanup. * * @param result the value returned by the method. If the method's return type is void, this will be {@code null}. * @param proxy the proxy instance on which the method was invoked. * @param args the arguments passed to the method. * @param methodSignature a tuple containing the {@code Method} object, a list of parameter types, and the return type. */ @SuppressWarnings(\"unused\") default void afterInvoke(final Object result, final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { // empty action. } } /** * A factory for creating and managing {@link Handler} instances. It provides a central registry * for handlers and supports integration with the Spring Framework's application context. */ public static final class HandlerFactory { @SuppressWarnings(\"rawtypes\") static final Handler EMPTY = new Handler() { // Do nothing. }; private static final Map<String, Handler<?>> handlerPool = new ConcurrentHashMap<>(); private static final SpringApplicationContext springAppContext; static { handlerPool.put(ClassUtil.getCanonicalClassName(Handler.class), EMPTY); handlerPool.put(ClassUtil.getClassName(EMPTY.getClass()), EMPTY); SpringApplicationContext tmp = null; try { tmp = new SpringApplicationContext(); } catch (final Throwable e) { // ignore. } springAppContext = tmp; } /** * Registers a handler by creating a new instance of the specified handler class. * The handler is registered using its canonical class name as the qualifier. * * @param handlerClass the handler class to instantiate and register. * @return {@code true} if the handler was registered successfully, {@code false} if a handler with the same name already exists. * @throws IllegalArgumentException if {@code handlerClass} is {@code null}. */ public static boolean register(final Class<? extends Handler<?>> handlerClass) throws IllegalArgumentException { N.checkArgNotNull(handlerClass, cs.handlerClass); return register(N.newInstance(handlerClass)); } /** * Registers a handler instance. The handler is registered using its canonical class name as the qualifier. * * @param handler the handler instance to register. * @return {@code true} if the handler was registered successfully, {@code false} if a handler with the same name already exists. * @throws IllegalArgumentException if {@code handler} is {@code null}. */ public static boolean register(final Handler<?> handler) throws IllegalArgumentException { N.checkArgNotNull(handler, cs.handler); return register(ClassUtil.getCanonicalClassName(handler.getClass()), handler); } /** * Registers a handler instance with a specific qualifier string. * * @param qualifier the unique identifier for the handler. * @param handler the handler instance to register. * @return {@code true} if the handler was registered successfully, {@code false} if a handler with the same qualifier already exists. * @throws IllegalArgumentException if {@code qualifier} is empty or {@code handler} is {@code null}. */ public static boolean register(final String qualifier, final Handler<?> handler) throws IllegalArgumentException { N.checkArgNotEmpty(qualifier, cs.qualifier); N.checkArgNotNull(handler, cs.handler); if (handlerPool.containsKey(qualifier)) { return false; } handlerPool.put(qualifier, handler); return true; } /** * Retrieves a handler by its qualifier. It first checks the internal registry, and if not found, * it attempts to retrieve it from the Spring application context if available. * * @param qualifier the unique identifier for the handler. * @return the handler instance, or {@code null} if not found. * @throws IllegalArgumentException if {@code qualifier} is empty. */ public static Handler<?> get(final String qualifier) { //NOSONAR N.checkArgNotEmpty(qualifier, cs.qualifier); Handler<?> result = handlerPool.get(qualifier); if (result == null && springAppContext != null) { final Object bean = springAppContext.getBean(qualifier); if (bean instanceof Handler) { result = (Handler<?>) bean; handlerPool.put(qualifier, result); } } return result; } /** * Retrieves a handler by its class. It first checks the internal registry using the class's * canonical name as the qualifier. If not found, it attempts to retrieve it from the Spring * application context. * * @param handlerClass the class of the handler to retrieve. * @return the handler instance, or {@code null} if not found. * @throws IllegalArgumentException if {@code handlerClass} is {@code null}. */ public static Handler<?> get(final Class<? extends Handler<?>> handlerClass) { //NOSONAR N.checkArgNotNull(handlerClass, cs.handlerClass); final String qualifier = ClassUtil.getCanonicalClassName(handlerClass); Handler<?> result = handlerPool.get(qualifier); if (result == null && springAppContext != null) { result = springAppContext.getBean(handlerClass); if (result == null) { final Object bean = springAppContext.getBean(qualifier); if (bean instanceof Handler) { result = (Handler<?>) bean; } } if (result != null) { handlerPool.put(qualifier, result); } } return result; } /** * Retrieves a handler by its class. If the handler is not found in the registry or Spring context, * a new instance is created, registered, and returned. * * @param handlerClass the class of the handler to retrieve or create. * @return the existing or newly created handler instance. * @throws IllegalArgumentException if {@code handlerClass} is {@code null}. */ public static Handler<?> getOrCreate(final Class<? extends Handler<?>> handlerClass) { //NOSONAR N.checkArgNotNull(handlerClass, cs.handlerClass); Handler<?> result = get(handlerClass); if (result == null) { try { result = N.newInstance(handlerClass); if (result != null) { register(result); } } catch (final Throwable e) { // ignore } } return result; } /** * Creates a {@code Handler} with a custom action to be executed before method invocation. * * @param <T> proxy type * @param <E> exception type that action can throw * @param beforeInvokeAction the action to perform before the method is called. * @return a new {@code Handler} instance. * @throws IllegalArgumentException if {@code beforeInvokeAction} is {@code null}. */ public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction) throws IllegalArgumentException { N.checkArgNotNull(beforeInvokeAction, cs.beforeInvokeAction); return new Handler<>() { @Override public void beforeInvoke(final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { beforeInvokeAction.accept(targetObject, args, methodSignature); } }; } /** * Creates a {@code Handler} with a custom action to be executed after method invocation. * * @param <T> proxy type * @param <E> exception type that action can throw * @param afterInvokeAction the action to perform after the method returns. * @return a new {@code Handler} instance. * @throws IllegalArgumentException if {@code afterInvokeAction} is {@code null}. */ public static <T, E extends RuntimeException> Handler<T> create( final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException { N.checkArgNotNull(afterInvokeAction, cs.afterInvokeAction); return new Handler<>() { @Override public void afterInvoke(final Object result, final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { afterInvokeAction.accept(result, targetObject, args, methodSignature); } }; } /** * Creates a {@code Handler} with custom actions to be executed both before and after method invocation. * * @param <T> proxy type * @param <E> exception type that actions can throw * @param beforeInvokeAction the action to perform before the method is called. * @param afterInvokeAction the action to perform after the method returns. * @return a new {@code Handler} instance. * @throws IllegalArgumentException if either action is {@code null}. */ public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction, final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException { N.checkArgNotNull(beforeInvokeAction, cs.beforeInvokeAction); N.checkArgNotNull(afterInvokeAction, cs.afterInvokeAction); return new Handler<>() { @Override public void beforeInvoke(final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { beforeInvokeAction.accept(targetObject, args, methodSignature); } @Override public void afterInvoke(final Object result, final T targetObject, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { afterInvokeAction.accept(result, targetObject, args, methodSignature); } }; } private HandlerFactory() { // singleton. } } /** * An interface for caching the results of DAO method calls. Implementations can provide * various caching strategies (e.g., in-memory, distributed) to improve application performance. * * <p>The default cache key format is: {@code fullMethodName#tableName#jsonArrayOfParameters}.</p> * <p>Example: {@code com.example.UserDao.findById#users#[123]}</p> */ public interface DaoCache { /** * Creates a {@code DaoCache} with a specified capacity and eviction delay, backed by a {@code LocalCache}. * * @param capacity the maximum number of entries in the cache. * @param evictDelay the interval in milliseconds for the eviction scheduler to run. * @return a new {@code DaoCache} instance. */ static DaoCache create(final int capacity, final long evictDelay) { return new DefaultDaoCache(capacity, evictDelay); } /** * Creates a {@code DaoCache} backed by a simple {@code java.util.HashMap}. This cache does not * perform automatic eviction. * * @return a new {@code DaoCache} instance backed by a {@code HashMap}. */ static DaoCache createByMap() { return new DaoCacheByMap(); } /** * Creates a {@code DaoCache} backed by the provided {@code Map}. This allows for using custom * map implementations (e.g., {@code ConcurrentHashMap}) for caching. * * @param map the map to use for caching. * @return a new {@code DaoCache} instance backed by the provided map. */ static DaoCache createByMap(Map<String, Object> map) { return new DaoCacheByMap(map); } /** * Retrieves a cached result. The implementation can use the provided parameters to customize * the cache key generation if needed. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key (fullMethodName#tableName#jsonArrayOfParameters). * @param daoProxy the DAO proxy instance on which the method was called. * @param args the arguments passed to the method. * @param methodSignature a tuple containing method metadata. * @return the cached result, or {@code null} if not found. */ Object get(String defaultCacheKey, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); /** * Caches a result with default time-to-live (TTL) settings. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key. * @param result the method result to cache. * @param daoProxy the DAO proxy instance. * @param args the method arguments. * @param methodSignature a tuple containing method metadata. * @return {@code true} if the result was cached successfully. */ boolean put(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); /** * Caches a result with custom time-to-live (TTL) and idle time settings. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key. * @param result the method result to cache. * @param liveTime the maximum time in milliseconds the entry should live in the cache. * @param maxIdleTime the maximum time in milliseconds the entry can remain idle before being evicted. * @param daoProxy the DAO proxy instance. * @param args the method arguments. * @param methodSignature a tuple containing method metadata. * @return {@code true} if the result was cached successfully. */ boolean put(String defaultCacheKey, Object result, final long liveTime, final long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); /** * Updates the cache after a data modification operation (e.g., insert, update, delete). This method * is responsible for invalidating or clearing cache entries that may be affected by the operation. * * <p><b>Implementation Note:</b> This method MUST NOT modify the input arguments.</p> * * @param defaultCacheKey the default cache key from the modification method. * @param result the result of the modification operation (e.g., number of rows affected). * @param daoProxy the DAO proxy instance. * @param args the arguments of the modification method. * @param methodSignature a tuple containing method metadata. */ void update(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature); } /** * The default implementation of {@link DaoCache}, using a {@link KeyedObjectPool} for in-memory caching * with support for time-to-live (TTL) and idle time-based eviction. */ public static final class DefaultDaoCache implements DaoCache { private final KeyedObjectPool<String, PoolableWrapper<Object>> pool; /** * Creates a {@code DefaultDaoCache} with a specified capacity and eviction delay. * * @param capacity the maximum number of entries the cache can hold. * @param evictDelay the interval in milliseconds for the background eviction thread. */ public DefaultDaoCache(final int capacity, final long evictDelay) { pool = PoolFactory.createKeyedObjectPool(capacity, evictDelay); } @Override @SuppressWarnings(\"unused\") public Object get(final String defaultCacheKey, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { final PoolableWrapper<Object> w = pool.get(defaultCacheKey); return w == null ? null : w.value(); } @Override @SuppressWarnings(\"unused\") public boolean put(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { N.checkArgNotNull(defaultCacheKey, \"Key cannot be null\"); return pool.put(defaultCacheKey, Poolable.wrap(result, JdbcUtil.DEFAULT_CACHE_LIVE_TIME, JdbcUtil.DEFAULT_CACHE_MAX_IDLE_TIME)); } @Override public boolean put(String defaultCacheKey, Object result, long liveTime, long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { N.checkArgNotNull(defaultCacheKey, \"Key cannot be null\"); return pool.put(defaultCacheKey, Poolable.wrap(result, liveTime, maxIdleTime)); } /** * Implements cache invalidation. If the table name can be determined from the cache key, * it removes all cache entries associated with that table. Otherwise, it clears the entire cache. * No action is taken for update operations that affect zero rows. */ @Override @SuppressWarnings(\"unused\") public void update(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { final Method method = methodSignature._1; if (JdbcUtil.BUILT_IN_DAO_UPDATE_METHODS.contains(method)) { if ((methodSignature._3.equals(int.class) || methodSignature._3.equals(long.class)) && (result != null && ((Number) result).longValue() == 0)) { return; } } final String updatedTableName = Strings.substringBetween(defaultCacheKey, JdbcUtil.CACHE_KEY_SPLITOR); if (Strings.isEmpty(updatedTableName)) { pool.clear(); } else { pool.keySet().stream().filter(k -> Strings.containsIgnoreCase(k, updatedTableName)).toList().forEach(pool::remove); } } } /** * A simple implementation of {@link DaoCache} that uses a standard {@code java.util.Map} * as the backing cache. It does not support automatic eviction or TTL. */ record DaoCacheByMap(Map<String, Object> cache) implements DaoCache { /** * Creates a {@code DaoCacheByMap} with a new {@code HashMap}. */ public DaoCacheByMap() { this(new HashMap<>()); } /** * Creates a {@code DaoCacheByMap} with a {@code HashMap} of a specified initial capacity. * * @param capacity the initial capacity for the backing {@code HashMap}. */ public DaoCacheByMap(final int capacity) { this(new HashMap<>(capacity)); } /** * Creates a {@code DaoCacheByMap} backed by a provided map instance. * * @param cache the map to be used for caching. */ DaoCacheByMap { } @Override @SuppressWarnings(\"unused\") public Object get(final String defaultCacheKey, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { return cache.get(defaultCacheKey); } @Override @SuppressWarnings(\"unused\") public boolean put(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { cache.put(defaultCacheKey, result); return true; } @Override public boolean put(String defaultCacheKey, Object result, long liveTime, long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { cache.put(defaultCacheKey, result); return true; } /** * Implements cache invalidation. If the table name can be determined from the cache key, * it removes all entries whose keys contain that table name. Otherwise, it clears the entire cache. * No action is taken for update operations that affect zero rows. */ @Override @SuppressWarnings(\"unused\") public void update(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature) { final Method method = methodSignature._1; if (JdbcUtil.BUILT_IN_DAO_UPDATE_METHODS.contains(method)) { if ((methodSignature._3.equals(int.class) || methodSignature._3.equals(long.class)) && (result != null && ((Number) result).longValue() == 0)) { return; } } final String updatedTableName = Strings.substringBetween(defaultCacheKey, JdbcUtil.CACHE_KEY_SPLITOR); if (Strings.isEmpty(updatedTableName)) { cache.clear(); } else { cache.entrySet().removeIf(e -> Strings.containsIgnoreCase(e.getKey(), updatedTableName)); } } } }",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "of",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static OutParam of(int parameterIndex, int sqlType)",
              "return_type": "OutParam",
              "type_params": [],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the parameter.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type from {@code java.sql.Types} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "A factory method to create an {@code OutParam} with the specified index and SQL type.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.OutParamResult",
          "name": "OutParamResult",
          "kind": "class",
          "modifiers": [
            "public",
            "static",
            "final"
          ],
          "javadoc_summary": "A container for the results of output parameters from a stored procedure execution.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "getOutParamValue",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T getOutParamValue(final int parameterIndex)",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameterIndex",
                  "type": "int",
                  "javadoc": "the 1-based index of the parameter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves the value of an output parameter by its 1-based index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getOutParamValue",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> T getOutParamValue(final String parameterName)",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves the value of an output parameter by its name.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getOutParamValues",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Map<Object, Object> getOutParamValues()",
              "return_type": "Map<Object, Object>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns a map containing all output parameter values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getOutParams",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public List<OutParam> getOutParams()",
              "return_type": "List<OutParam>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the list of {@link OutParam} definitions that were used to register the output parameters.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.Handler",
          "name": "Handler",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A handler interface for intercepting method invocations on DAO proxies, similar to an Aspect-Oriented Programming (AOP) interceptor.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "P",
              "bounds": [
                "java.lang.Object"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "beforeInvoke",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"unused\") default void beforeInvoke(final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "proxy",
                  "type": "P",
                  "javadoc": "the proxy instance on which the method was invoked.",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "javadoc": "the arguments passed to the method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "javadoc": "a tuple containing the {@code Method} object, a list of parameter types, and the return type.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "This method is invoked before the actual DAO method is called.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "afterInvoke",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"unused\") default void afterInvoke(final Object result, final P proxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "result",
                  "type": "Object",
                  "javadoc": "the value returned by the method. If the method's return type is void, this will be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "proxy",
                  "type": "P",
                  "javadoc": "the proxy instance on which the method was invoked.",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "javadoc": "the arguments passed to the method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "javadoc": "a tuple containing the {@code Method} object, a list of parameter types, and the return type.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "This method is invoked after the DAO method completes, whether successfully or with an exception.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.HandlerFactory",
          "name": "HandlerFactory",
          "kind": "class",
          "modifiers": [
            "public",
            "static",
            "final"
          ],
          "javadoc_summary": "A factory for creating and managing {@link Handler} instances.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "register",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean register(final Class<? extends Handler<?>> handlerClass) throws IllegalArgumentException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "handlerClass",
                  "type": "Class<? extends Handler<?>>",
                  "javadoc": "the handler class to instantiate and register.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code handlerClass} is {@code null} ."
                }
              ],
              "javadoc_summary": "Registers a handler by creating a new instance of the specified handler class.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "register",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean register(final Handler<?> handler) throws IllegalArgumentException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "handler",
                  "type": "Handler<?>",
                  "javadoc": "the handler instance to register.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code handler} is {@code null} ."
                }
              ],
              "javadoc_summary": "Registers a handler instance.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "register",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean register(final String qualifier, final Handler<?> handler) throws IllegalArgumentException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "qualifier",
                  "type": "String",
                  "javadoc": "the unique identifier for the handler.",
                  "nullability": "unspecified"
                },
                {
                  "name": "handler",
                  "type": "Handler<?>",
                  "javadoc": "the handler instance to register.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code qualifier} is empty or {@code handler} is {@code null} ."
                }
              ],
              "javadoc_summary": "Registers a handler instance with a specific qualifier string.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Handler<?> get(final String qualifier)",
              "return_type": "Handler<?>",
              "type_params": [],
              "params": [
                {
                  "name": "qualifier",
                  "type": "String",
                  "javadoc": "the unique identifier for the handler.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves a handler by its qualifier.",
              "contract": [
                "It first checks the internal registry, and if not found, it attempts to retrieve it from the Spring application context if available."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Handler<?> get(final Class<? extends Handler<?>> handlerClass)",
              "return_type": "Handler<?>",
              "type_params": [],
              "params": [
                {
                  "name": "handlerClass",
                  "type": "Class<? extends Handler<?>>",
                  "javadoc": "the class of the handler to retrieve.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves a handler by its class.",
              "contract": [
                "If not found, it attempts to retrieve it from the Spring application context."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getOrCreate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Handler<?> getOrCreate(final Class<? extends Handler<?>> handlerClass)",
              "return_type": "Handler<?>",
              "type_params": [],
              "params": [
                {
                  "name": "handlerClass",
                  "type": "Class<? extends Handler<?>>",
                  "javadoc": "the class of the handler to retrieve or create.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves a handler by its class.",
              "contract": [
                "If the handler is not found in the registry or Spring context, a new instance is created, registered, and returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "create",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction) throws IllegalArgumentException",
              "return_type": "Handler<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "RuntimeException"
                  ]
                }
              ],
              "params": [
                {
                  "name": "beforeInvokeAction",
                  "type": "Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>",
                  "javadoc": "the action to perform before the method is called.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code beforeInvokeAction} is {@code null} ."
                }
              ],
              "javadoc_summary": "Creates a {@code Handler} with a custom action to be executed before method invocation.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "create",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T, E extends RuntimeException> Handler<T> create( final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException",
              "return_type": "Handler<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "RuntimeException"
                  ]
                }
              ],
              "params": [
                {
                  "name": "afterInvokeAction",
                  "type": "Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>",
                  "javadoc": "the action to perform after the method returns.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if {@code afterInvokeAction} is {@code null} ."
                }
              ],
              "javadoc_summary": "Creates a {@code Handler} with a custom action to be executed after method invocation.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "create",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T, E extends RuntimeException> Handler<T> create( final Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> beforeInvokeAction, final Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E> afterInvokeAction) throws IllegalArgumentException",
              "return_type": "Handler<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "RuntimeException"
                  ]
                }
              ],
              "params": [
                {
                  "name": "beforeInvokeAction",
                  "type": "Throwables.TriConsumer<T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>",
                  "javadoc": "the action to perform before the method is called.",
                  "nullability": "unspecified"
                },
                {
                  "name": "afterInvokeAction",
                  "type": "Throwables.QuadConsumer<Object, T, Object[], Tuple3<Method, ImmutableList<Class<?>>, Class<?>>, E>",
                  "javadoc": "the action to perform after the method returns.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if either action is {@code null} ."
                }
              ],
              "javadoc_summary": "Creates a {@code Handler} with custom actions to be executed both before and after method invocation.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.DaoCache",
          "name": "DaoCache",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "An interface for caching the results of DAO method calls.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "create",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static DaoCache create(final int capacity, final long evictDelay)",
              "return_type": "DaoCache",
              "type_params": [],
              "params": [
                {
                  "name": "capacity",
                  "type": "int",
                  "javadoc": "the maximum number of entries in the cache.",
                  "nullability": "unspecified"
                },
                {
                  "name": "evictDelay",
                  "type": "long",
                  "javadoc": "the interval in milliseconds for the eviction scheduler to run.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code DaoCache} with a specified capacity and eviction delay, backed by a {@code LocalCache} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createByMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static DaoCache createByMap()",
              "return_type": "DaoCache",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Creates a {@code DaoCache} backed by a simple {@code java.util.HashMap} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createByMap",
              "kind": "static",
              "modifiers": [
                "static",
                "public"
              ],
              "signature": "static DaoCache createByMap(Map<String, Object> map)",
              "return_type": "DaoCache",
              "type_params": [],
              "params": [
                {
                  "name": "map",
                  "type": "Map<String, Object>",
                  "javadoc": "the map to use for caching.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code DaoCache} backed by the provided {@code Map} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Object get(String defaultCacheKey, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "Object",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "javadoc": "the default cache key (fullMethodName#tableName#jsonArrayOfParameters).",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "javadoc": "the DAO proxy instance on which the method was called.",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "javadoc": "the arguments passed to the method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "javadoc": "a tuple containing method metadata.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves a cached result.",
              "contract": [
                "The implementation can use the provided parameters to customize the cache key generation if needed.",
                "<p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "put",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean put(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "javadoc": "the default cache key.",
                  "nullability": "unspecified"
                },
                {
                  "name": "result",
                  "type": "Object",
                  "javadoc": "the method result to cache.",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "javadoc": "the DAO proxy instance.",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "javadoc": "the method arguments.",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "javadoc": "a tuple containing method metadata.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Caches a result with default time-to-live (TTL) settings.",
              "contract": [
                "<p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "put",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean put(String defaultCacheKey, Object result, final long liveTime, final long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "javadoc": "the default cache key.",
                  "nullability": "unspecified"
                },
                {
                  "name": "result",
                  "type": "Object",
                  "javadoc": "the method result to cache.",
                  "nullability": "unspecified"
                },
                {
                  "name": "liveTime",
                  "type": "long",
                  "javadoc": "the maximum time in milliseconds the entry should live in the cache.",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxIdleTime",
                  "type": "long",
                  "javadoc": "the maximum time in milliseconds the entry can remain idle before being evicted.",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "javadoc": "the DAO proxy instance.",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "javadoc": "the method arguments.",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "javadoc": "a tuple containing method metadata.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Caches a result with custom time-to-live (TTL) and idle time settings.",
              "contract": [
                "<p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void update(String defaultCacheKey, Object result, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "javadoc": "the default cache key from the modification method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "result",
                  "type": "Object",
                  "javadoc": "the result of the modification operation (e.g., number of rows affected).",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "javadoc": "the DAO proxy instance.",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "javadoc": "the arguments of the modification method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "javadoc": "a tuple containing method metadata.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Updates the cache after a data modification operation (e.g., insert, update, delete).",
              "contract": [
                "<p> <b> Implementation Note: </b> This method MUST NOT modify the input arguments."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Jdbc.DefaultDaoCache",
          "name": "DefaultDaoCache",
          "kind": "class",
          "modifiers": [
            "public",
            "static",
            "final"
          ],
          "javadoc_summary": "The default implementation of {@link DaoCache} , using a {@link KeyedObjectPool} for in-memory caching with support for time-to-live (TTL) and idle time-based eviction.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "<init>",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public DefaultDaoCache(final int capacity, final long evictDelay)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "capacity",
                  "type": "int",
                  "javadoc": "the maximum number of entries the cache can hold.",
                  "nullability": "unspecified"
                },
                {
                  "name": "evictDelay",
                  "type": "long",
                  "javadoc": "the interval in milliseconds for the background eviction thread.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code DefaultDaoCache} with a specified capacity and eviction delay.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override @SuppressWarnings(\"unused\") public Object get(final String defaultCacheKey, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "Object",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "put",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override @SuppressWarnings(\"unused\") public boolean put(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "nullability": "unspecified"
                },
                {
                  "name": "result",
                  "type": "Object",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "put",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public boolean put(String defaultCacheKey, Object result, long liveTime, long maxIdleTime, Object daoProxy, Object[] args, Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "nullability": "unspecified"
                },
                {
                  "name": "result",
                  "type": "Object",
                  "nullability": "unspecified"
                },
                {
                  "name": "liveTime",
                  "type": "long",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxIdleTime",
                  "type": "long",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override @SuppressWarnings(\"unused\") public void update(final String defaultCacheKey, final Object result, final Object daoProxy, final Object[] args, final Tuple3<Method, ImmutableList<Class<?>>, Class<?>> methodSignature)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "defaultCacheKey",
                  "type": "String",
                  "nullability": "unspecified"
                },
                {
                  "name": "result",
                  "type": "Object",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoProxy",
                  "type": "Object",
                  "nullability": "unspecified"
                },
                {
                  "name": "args",
                  "type": "Object[]",
                  "nullability": "unspecified"
                },
                {
                  "name": "methodSignature",
                  "type": "Tuple3<Method, ImmutableList<Class<?>>, Class<?>>",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Implements cache invalidation.",
              "contract": [
                "If the table name can be determined from the cache key, it removes all cache entries associated with that table."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.JdbcCodeGenerationUtil",
          "name": "JdbcCodeGenerationUtil",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "Utility class for generating JDBC-related code including entity classes and SQL statements.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final DataSource ds, final String tableName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the entity class",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class for the specified table using default configuration.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final DataSource ds, final String tableName, final EntityCodeConfig config)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the entity class",
                  "nullability": "unspecified"
                },
                {
                  "name": "config",
                  "type": "EntityCodeConfig",
                  "javadoc": "The configuration for customizing the generated entity class. If {@code null} , default configuration is used",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class for the specified table with custom configuration.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final DataSource ds, final String entityName, final String query)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityName",
                  "type": "String",
                  "javadoc": "The name of the entity class to generate",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "The SQL query to execute for retrieving the table metadata. The query should return an empty result set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class using a custom SQL query to determine the entity structure.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final DataSource ds, final String entityName, final String query, final EntityCodeConfig config)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityName",
                  "type": "String",
                  "javadoc": "The name of the entity class to generate",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "The SQL query to execute for retrieving the table metadata. The query should return an empty result set",
                  "nullability": "unspecified"
                },
                {
                  "name": "config",
                  "type": "EntityCodeConfig",
                  "javadoc": "The configuration for customizing the generated entity class. If {@code null} , default configuration is used",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class using a custom SQL query and configuration.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final Connection conn, final String tableName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the entity class",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class for the specified table using an existing database connection.",
              "contract": [
                "This method is useful when you already have an open connection and want to avoid creating a new one."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final Connection conn, final String tableName, final EntityCodeConfig config)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the entity class",
                  "nullability": "unspecified"
                },
                {
                  "name": "config",
                  "type": "EntityCodeConfig",
                  "javadoc": "The configuration for customizing the generated entity class. If {@code null} , default configuration is used",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class for the specified table using an existing connection and custom configuration.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final Connection conn, final String entityName, final String query)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityName",
                  "type": "String",
                  "javadoc": "The name of the entity class to generate",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "The SQL query to execute for retrieving the table metadata. The query should return an empty result set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class using an existing connection and a custom SQL query.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateEntityClass",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateEntityClass(final Connection conn, final String entityName, final String query, final EntityCodeConfig config)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityName",
                  "type": "String",
                  "javadoc": "The name of the entity class to generate",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "The SQL query to execute for retrieving the table metadata. The query should return an empty result set",
                  "nullability": "unspecified"
                },
                {
                  "name": "config",
                  "type": "EntityCodeConfig",
                  "javadoc": "The configuration for customizing the generated entity class. If {@code null} , default configuration is used",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an entity class using an existing connection, custom SQL query, and configuration.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateSelectSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateSelectSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the SELECT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates a SELECT SQL statement for the specified table.",
              "contract": [
                "Column names are properly escaped with backticks if they contain special characters."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateSelectSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateSelectSql(final Connection conn, final String tableName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the SELECT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates a SELECT SQL statement for the specified table using an existing connection.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateSelectSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateSelectSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames, final String whereClause) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the SELECT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the SELECT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "whereClause",
                  "type": "String",
                  "javadoc": "An optional WHERE clause to append to the SELECT statement (without the \"WHERE\" keyword)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates a SELECT SQL statement for the specified table, excluding certain columns and applying a WHERE clause.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateSelectSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateSelectSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames, final String whereClause) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the SELECT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the SELECT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "whereClause",
                  "type": "String",
                  "javadoc": "An optional WHERE clause to append to the SELECT statement (without the \"WHERE\" keyword)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates a SELECT SQL statement for the specified table using an existing connection, excluding certain columns and applying a WHERE clause.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateInsertSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the INSERT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates an INSERT SQL statement for the specified table.",
              "contract": [
                "Column names are properly escaped with backticks if they contain special characters."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateInsertSql(final Connection conn, final String tableName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the INSERT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an INSERT SQL statement for the specified table using an existing connection.",
              "contract": [
                "Column names are properly escaped with backticks if they contain special characters."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateInsertSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the INSERT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs or the table cannot be queried"
                }
              ],
              "javadoc_summary": "Generates an INSERT SQL statement for the specified table, excluding certain columns.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateInsertSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the INSERT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an INSERT SQL statement for the specified table, excluding certain columns.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#generateInsertSql(Connection, String)",
                "#generateInsertSql(DataSource, String, Collection)",
                "#generateNamedInsertSql(Connection, String, Collection)"
              ]
            },
            {
              "name": "generateNamedInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedInsertSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named INSERT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates a named INSERT SQL statement for the specified table.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedInsertSql(final Connection conn, final String tableName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named INSERT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates a named INSERT SQL statement for the specified table using an existing connection.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedInsertSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named INSERT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs or the table cannot be queried"
                }
              ],
              "javadoc_summary": "Generates a named INSERT SQL statement for the specified table, excluding certain columns.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedInsertSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedInsertSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named INSERT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the INSERT statement. Can be {@code null} or empty to include all columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates a named INSERT SQL statement for the specified table using an existing connection, excluding certain columns.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#generateNamedInsertSql(Connection, String)",
                "#generateNamedInsertSql(DataSource, String, Collection)",
                "#generateInsertSql(Connection, String, Collection)"
              ]
            },
            {
              "name": "generateUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateUpdateSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the UPDATE statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates an UPDATE SQL statement for the specified table.",
              "contract": [
                "Note: Users should append an appropriate WHERE clause before executing.",
                "No WHERE clause - must be added manually."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateUpdateSql(final Connection conn, final String tableName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the UPDATE statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an UPDATE SQL statement for the specified table using an existing connection.",
              "contract": [
                "Note: Users should append an appropriate WHERE clause before executing."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateUpdateSql(final DataSource dataSource, final String tableName, final String keyColumnName) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnName",
                  "type": "String",
                  "javadoc": "The column name to use in the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates an UPDATE SQL statement for the specified table with a WHERE clause based on a single column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateUpdateSql(final Connection conn, final String tableName, final String keyColumnName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnName",
                  "type": "String",
                  "javadoc": "The column name to use in the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an UPDATE SQL statement for the specified table with a WHERE clause based on a single column using an existing connection.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateUpdateSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the SET clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to use in the WHERE clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "whereClause",
                  "type": "String",
                  "javadoc": "An optional additional WHERE clause to append (without the \"WHERE\" keyword). Can be {@code null} or empty",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs or the table cannot be queried"
                }
              ],
              "javadoc_summary": "Generates an UPDATE SQL statement for the specified table using an existing connection, excluding certain columns and applying WHERE conditions with an optional custom WHERE clause.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#generateUpdateSql(Connection, String, String)",
                "#generateUpdateSql(Connection, String, Collection, Collection, String)",
                "#generateNamedUpdateSql(DataSource, String, Collection, Collection, String)"
              ]
            },
            {
              "name": "generateUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateUpdateSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the SET clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to use in the WHERE clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "whereClause",
                  "type": "String",
                  "javadoc": "An optional additional WHERE clause to append (without the \"WHERE\" keyword). Can be {@code null} or empty",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates an UPDATE SQL statement for the specified table using an existing connection, excluding certain columns and applying WHERE conditions with an optional custom WHERE clause.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#generateUpdateSql(Connection, String, String)",
                "#generateUpdateSql(DataSource, String, Collection, Collection, String)",
                "#generateNamedUpdateSql(Connection, String, Collection, Collection, String)"
              ]
            },
            {
              "name": "generateNamedUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedUpdateSql(final DataSource dataSource, final String tableName) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named UPDATE statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates a named UPDATE SQL statement for the specified table.",
              "contract": [
                "Note: Users should append an appropriate WHERE clause before executing.",
                "No WHERE clause - must be added manually."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedUpdateSql(final Connection conn, final String tableName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named UPDATE statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates a named UPDATE SQL statement for the specified table using an existing connection.",
              "contract": [
                "Note: Users should append an appropriate WHERE clause before executing."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedUpdateSql(final DataSource dataSource, final String tableName, final String keyColumnName) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnName",
                  "type": "String",
                  "javadoc": "The column name to use in the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Generates a named UPDATE SQL statement for the specified table with a WHERE clause based on a single column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedUpdateSql(final Connection conn, final String tableName, final String keyColumnName)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnName",
                  "type": "String",
                  "javadoc": "The column name to use in the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates a named UPDATE SQL statement for the specified table with a WHERE clause based on a single column using an existing connection.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedUpdateSql(final DataSource dataSource, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause) throws UncheckedSQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the named UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the SET clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to use in the WHERE clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "whereClause",
                  "type": "String",
                  "javadoc": "An optional additional WHERE clause to append (without the \"WHERE\" keyword). Can be {@code null} or empty",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs or the table cannot be queried"
                }
              ],
              "javadoc_summary": "Generates a named UPDATE SQL statement for the specified table using an existing connection, excluding certain key columns and applying WHERE conditions with an optional custom WHERE clause.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateNamedUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String generateNamedUpdateSql(final Connection conn, final String tableName, final Collection<String> excludedColumnNames, final Collection<String> keyColumnNames, final String whereClause)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to generate the UPDATE statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to exclude from the SET clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "keyColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "A collection of column names to use in the WHERE clause. Can be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "whereClause",
                  "type": "String",
                  "javadoc": "An optional additional WHERE clause to append (without the \"WHERE\" keyword). Can be {@code null} or empty",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Generates a named UPDATE SQL statement for the specified table using an existing connection, excluding certain key columns and applying WHERE conditions with an optional custom WHERE clause.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#generateNamedUpdateSql(Connection, String, String)",
                "#generateNamedUpdateSql(DataSource, String, Collection, Collection, String)",
                "#generateUpdateSql(Connection, String, Collection, Collection, String)"
              ]
            },
            {
              "name": "convertInsertSqlToUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static String convertInsertSqlToUpdateSql(final DataSource dataSource, final String insertSql)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "The INSERT SQL statement to convert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Converts an INSERT SQL statement to an UPDATE SQL statement.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "convertInsertSqlToUpdateSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static String convertInsertSqlToUpdateSql(final DataSource dataSource, final String insertSql, final String whereClause)",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "DataSource",
                  "javadoc": "The data source to connect to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "The INSERT SQL statement to convert",
                  "nullability": "unspecified"
                },
                {
                  "name": "whereClause",
                  "type": "String",
                  "javadoc": "The WHERE clause to append to the UPDATE statement (without the WHERE keyword)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Converts an INSERT SQL statement to an UPDATE SQL statement with a specified WHERE clause.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "S",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"s\"",
              "javadoc_summary": "Default name of class for field/prop names."
            },
            {
              "name": "SF",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"sf\"",
              "javadoc_summary": "Default name of class for function field/prop names."
            },
            {
              "name": "X",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"x\"",
              "javadoc_summary": "Default name of inner class for field names inside an entity class."
            },
            {
              "name": "MIN_FUNC",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "TriFunction<Class<?>, Class<?>, String, String>",
              "value": "(entityClass,propClass,propName)->{ if (Comparable.class.isAssignableFrom(propClass)) { return \"min(\" + propName + \")\"; } return null; }",
              "javadoc_summary": "Pre-defined function for generating MIN SQL aggregate function."
            },
            {
              "name": "MAX_FUNC",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "TriFunction<Class<?>, Class<?>, String, String>",
              "value": "(entityClass,propClass,propName)->{ if (Comparable.class.isAssignableFrom(propClass)) { return \"max(\" + propName + \")\"; } return null; }",
              "javadoc_summary": "Pre-defined function for generating MAX SQL aggregate function."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.JdbcCodeGenerationUtil.EntityCodeConfig",
          "name": "EntityCodeConfig",
          "kind": "class",
          "modifiers": [
            "public",
            "static",
            "final"
          ],
          "javadoc_summary": "Configuration class for customizing entity code generation.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "<init>",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "class EntityCodeConfig { /** * The source directory where the generated entity class file will be saved. * If specified, the generated class will be written to this directory following the package structure. * Example: \"./src/main/java\" */ private String srcDir; /** * The package name for the generated entity class. * Example: \"com.example.entity\" */ private String packageName; /** * The class name for the generated entity. * If not specified, it will be derived from the table name using camelCase conversion. */ private String className; /** * Function to convert database column names to Java field names. * First parameter is entity/table name, second is column name. * Default implementation converts column names to camelCase. * Example: (tableName, columnName) -> Strings.toCamelCase(columnName) */ private BiFunction<String, String, String> fieldNameConverter; /** * Function to convert database column types to Java field types. * Parameters: entity/table name, field name, column name, column class name (from ResultSetMetaData). * Example: (entity, field, column, className) -> className.replace(\"java.lang.\", \"\") */ private QuadFunction<String, String, String, String, String> fieldTypeConverter; /** * List of customized field mappings. * Each tuple contains: (column name, field name, field class). * Allows overriding default field names and types for specific columns. */ private List<Tuple3<String, String, Class<?>>> customizedFields; /** * List of customized database type annotations. * Each tuple contains: (field name, database type). * Used to generate @Type annotations for special database types. */ private List<Tuple2<String, String>> customizedFieldDbTypes; /** * Whether to use boxed types (Integer, Long, etc.) instead of primitives (int, long, etc.). * Default is {@code false} (uses primitives where possible). */ private boolean useBoxedType; private boolean mapBigIntegerToLong; private boolean mapBigDecimalToDouble; private Collection<String> readOnlyFields; private Collection<String> nonUpdatableFields; private Collection<String> idFields; private String idField; private Collection<String> excludedFields; private String additionalFieldsOrLines; private List<String> classNamesToImport; private Class<? extends Annotation> tableAnnotationClass; private Class<? extends Annotation> columnAnnotationClass; private Class<? extends Annotation> idAnnotationClass; private boolean chainAccessor; private boolean generateBuilder; private boolean generateCopyMethod; private boolean generateFieldNameTable; private boolean extendFieldNameTableClassName; // private String fieldNameTableClassName; // Always be \"NT\"; // private List<Tuple2<String, String>> customizedJsonFields; @Beta private JsonXmlConfig jsonXmlConfig; /** * Configuration for JSON and XML serialization/deserialization settings. * * <p>This class allows customization of how entity fields are serialized to * and deserialized from JSON and XML formats. It includes settings for naming * conventions, field filtering, date/time formatting, and enum handling.</p> * * <p>This feature is marked as {@code @Beta} and may be subject to changes * in future releases.</p> */ @Builder @Data @AllArgsConstructor @Accessors(chain = true) public static class JsonXmlConfig { private NamingPolicy namingPolicy; private String ignoredFields; private String dateFormat; private String timeZone; private String numberFormat; private EnumType enumerated; /** * Constructs a new JsonXmlConfig instance with default values. */ public JsonXmlConfig() { } } } }",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.JdbcCodeGenerationUtil.EntityCodeConfig.JsonXmlConfig",
          "name": "JsonXmlConfig",
          "kind": "class",
          "modifiers": [
            "public",
            "static"
          ],
          "javadoc_summary": "Configuration for JSON and XML serialization/deserialization settings.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "<init>",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public JsonXmlConfig()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Constructs a new JsonXmlConfig instance with default values.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.JdbcUtil",
          "name": "JdbcUtil",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "A comprehensive, production-ready utility class providing enterprise-grade JDBC operations with advanced database access patterns, transaction management, and performance optimization features.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "getDBProductInfo",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static DBProductInfo getDBProductInfo(final javax.sql.DataSource ds) throws UncheckedSQLException",
              "return_type": "DBProductInfo",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource from which to obtain a database connection.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs while trying to connect to the database."
                }
              ],
              "javadoc_summary": "Retrieves the database product information from the given DataSource.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code DataSource dataSource = ...; // Obtain a DataSource instance DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(dataSource); System.out.println(\"Database Product Name: \" + dbInfo.productName()); System.out.println(\"Database Product Version: \" + dbInfo.productVersion()); // Perform actions based on the database type if (dbInfo.version().isPostgreSQL()) { System.out.println(\"This is a PostgreSQL database.\"); } else if (dbInfo.version() == DBVersion.MySQL_8) { System.out.println(\"This is MySQL version 8.\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#getDBProductInfo(Connection)",
                "DBProductInfo",
                "DBVersion"
              ]
            },
            {
              "name": "getDBProductInfo",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static DBProductInfo getDBProductInfo(final Connection conn) throws UncheckedSQLException",
              "return_type": "DBProductInfo",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use for retrieving metadata. It must be an active connection.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs while retrieving metadata."
                }
              ],
              "javadoc_summary": "Retrieves the database product information from the given {@link Connection} .",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Connection connection = ...; // Obtain a database Connection DBProductInfo dbInfo = JdbcUtil.getDBProductInfo(connection); System.out.println(\"Database Name: \" + dbInfo.productName()); System.out.println(\"Database Version: \" + dbInfo.productVersion()); // Example of checking for a specific database version if (dbInfo.version() == DBVersion.Oracle) { System.out.println(\"Connected to an Oracle database.\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#getDBProductInfo(javax.sql.DataSource)",
                "DatabaseMetaData"
              ]
            },
            {
              "name": "createHikariDataSource",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static javax.sql.DataSource createHikariDataSource(final String url, final String user, final String password)",
              "return_type": "javax.sql.DataSource",
              "type_params": [],
              "params": [
                {
                  "name": "url",
                  "type": "String",
                  "javadoc": "The JDBC URL for the database connection (e.g., \"jdbc:mysql://localhost:3306/mydb\").",
                  "nullability": "unspecified"
                },
                {
                  "name": "user",
                  "type": "String",
                  "javadoc": "The username for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "password",
                  "type": "String",
                  "javadoc": "The password for database authentication.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code HikariDataSource} with the specified database connection details.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#createHikariDataSource(String, String, String, int, int)",
                "com.zaxxer.hikari.HikariDataSource"
              ]
            },
            {
              "name": "createHikariDataSource",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static javax.sql.DataSource createHikariDataSource(final String url, final String user, final String password, final int minIdle, final int maxPoolSize)",
              "return_type": "javax.sql.DataSource",
              "type_params": [],
              "params": [
                {
                  "name": "url",
                  "type": "String",
                  "javadoc": "The JDBC URL for the database connection.",
                  "nullability": "unspecified"
                },
                {
                  "name": "user",
                  "type": "String",
                  "javadoc": "The username for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "password",
                  "type": "String",
                  "javadoc": "The password for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "minIdle",
                  "type": "int",
                  "javadoc": "The minimum number of idle connections that HikariCP tries to maintain in the pool.",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxPoolSize",
                  "type": "int",
                  "javadoc": "The maximum number of connections that can be in the pool, including both idle and in-use connections.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a {@code HikariDataSource} with specified connection details and pool size configuration.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#createHikariDataSource(String, String, String)",
                "com.zaxxer.hikari.HikariConfig"
              ]
            },
            {
              "name": "createC3p0DataSource",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static javax.sql.DataSource createC3p0DataSource(final String url, final String user, final String password)",
              "return_type": "javax.sql.DataSource",
              "type_params": [],
              "params": [
                {
                  "name": "url",
                  "type": "String",
                  "javadoc": "The JDBC URL for the database connection.",
                  "nullability": "unspecified"
                },
                {
                  "name": "user",
                  "type": "String",
                  "javadoc": "The username for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "password",
                  "type": "String",
                  "javadoc": "The password for database authentication.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a C3P0 {@code ComboPooledDataSource} with the specified database connection details.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#createC3p0DataSource(String, String, String, int, int)",
                "com.mchange.v2.c3p0.ComboPooledDataSource"
              ]
            },
            {
              "name": "createC3p0DataSource",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static javax.sql.DataSource createC3p0DataSource(final String url, final String user, final String password, final int minPoolSize, final int maxPoolSize)",
              "return_type": "javax.sql.DataSource",
              "type_params": [],
              "params": [
                {
                  "name": "url",
                  "type": "String",
                  "javadoc": "The JDBC URL for the database connection.",
                  "nullability": "unspecified"
                },
                {
                  "name": "user",
                  "type": "String",
                  "javadoc": "The username for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "password",
                  "type": "String",
                  "javadoc": "The password for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "minPoolSize",
                  "type": "int",
                  "javadoc": "The minimum number of connections the pool will maintain.",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxPoolSize",
                  "type": "int",
                  "javadoc": "The maximum number of connections the pool will allow.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a C3P0 {@code ComboPooledDataSource} with specified connection details and pool size configuration.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#createC3p0DataSource(String, String, String)",
                "com.mchange.v2.c3p0.ComboPooledDataSource"
              ]
            },
            {
              "name": "createConnection",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Connection createConnection(final String url, final String user, final String password) throws UncheckedSQLException",
              "return_type": "Connection",
              "type_params": [],
              "params": [
                {
                  "name": "url",
                  "type": "String",
                  "javadoc": "The JDBC URL for the database connection (e.g., \"jdbc:mysql://localhost:3306/mydb\").",
                  "nullability": "unspecified"
                },
                {
                  "name": "user",
                  "type": "String",
                  "javadoc": "The username for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "password",
                  "type": "String",
                  "javadoc": "The password for database authentication.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs or the driver cannot be determined from the URL."
                }
              ],
              "javadoc_summary": "Creates a new database {@link Connection} using the specified URL, username, and password.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#createConnection(String, String, String, String)",
                "DriverManager#getConnection(String, String, String)"
              ]
            },
            {
              "name": "createConnection",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Connection createConnection(final String driverClass, final String url, final String user, final String password) throws UncheckedSQLException",
              "return_type": "Connection",
              "type_params": [],
              "params": [
                {
                  "name": "driverClass",
                  "type": "String",
                  "javadoc": "The fully qualified name of the JDBC driver class (e.g., \"com.mysql.cj.jdbc.Driver\").",
                  "nullability": "unspecified"
                },
                {
                  "name": "url",
                  "type": "String",
                  "javadoc": "The JDBC URL for the database connection.",
                  "nullability": "unspecified"
                },
                {
                  "name": "user",
                  "type": "String",
                  "javadoc": "The username for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "password",
                  "type": "String",
                  "javadoc": "The password for database authentication.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs or the specified driver class is not found."
                }
              ],
              "javadoc_summary": "Creates a new database {@link Connection} using an explicitly specified driver class.",
              "contract": [
                "This method is useful when the JDBC driver cannot be automatically determined from the URL or when a specific driver version needs to be enforced."
              ],
              "examples": [],
              "see_also": [
                "#createConnection(Class, String, String, String)"
              ]
            },
            {
              "name": "createConnection",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Connection createConnection(final Class<? extends Driver> driverClass, final String url, final String user, final String password) throws UncheckedSQLException",
              "return_type": "Connection",
              "type_params": [],
              "params": [
                {
                  "name": "driverClass",
                  "type": "Class<? extends Driver>",
                  "javadoc": "The JDBC {@link Driver} class (e.g., {@code com.mysql.cj.jdbc.Driver.class} ).",
                  "nullability": "unspecified"
                },
                {
                  "name": "url",
                  "type": "String",
                  "javadoc": "The JDBC URL for the database connection.",
                  "nullability": "unspecified"
                },
                {
                  "name": "user",
                  "type": "String",
                  "javadoc": "The username for database authentication.",
                  "nullability": "unspecified"
                },
                {
                  "name": "password",
                  "type": "String",
                  "javadoc": "The password for database authentication.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during connection creation."
                }
              ],
              "javadoc_summary": "Creates a new database {@link Connection} using a type-safe {@link Driver} class.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#createConnection(String, String, String, String)",
                "DriverManager#registerDriver(Driver)"
              ]
            },
            {
              "name": "getConnection",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Connection getConnection(final javax.sql.DataSource ds) throws UncheckedSQLException",
              "return_type": "Connection",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} from which to obtain a connection.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Retrieves a {@link Connection} from the specified {@link javax.sql.DataSource} .",
              "contract": [
                "If a transaction is active, it returns the connection associated with the current transaction."
              ],
              "examples": [],
              "see_also": [
                "#releaseConnection(Connection, javax.sql.DataSource)",
                "org.springframework.jdbc.datasource.DataSourceUtils#getConnection(javax.sql.DataSource)"
              ]
            },
            {
              "name": "releaseConnection",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void releaseConnection(final Connection conn, final javax.sql.DataSource ds)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The {@link Connection} to be released. Can be {@code null} , in which case the method does nothing.",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} from which the connection was obtained.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Releases the given {@link Connection} back to the {@link javax.sql.DataSource} .",
              "contract": [
                "If no transaction is active, it closes the connection.",
                "perform database work } finally { // This ensures the connection is always released, even if an error occurs."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "org.springframework.jdbc.datasource.DataSourceUtils#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void close(final ResultSet rs) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. If {@code null} , the method does nothing.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "javadoc_summary": "Closes the specified {@link ResultSet} .",
              "contract": [
                "However, if manual closing is necessary, this method can be used in a {@code finally} block."
              ],
              "examples": [],
              "see_also": [
                "#closeQuietly(ResultSet)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void close(final ResultSet rs, final boolean closeStatement) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. If {@code null} , no action is taken.",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeStatement",
                  "type": "boolean",
                  "javadoc": "If {@code true} , the {@link Statement} that created the {@code ResultSet} will also be closed.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "javadoc_summary": "Closes the specified {@link ResultSet} and, optionally, its associated {@link Statement} .",
              "contract": [
                "This is useful when the {@code Statement} is created and used only for a single {@code ResultSet} ."
              ],
              "examples": [],
              "see_also": [
                "#close(ResultSet, boolean, boolean)",
                "#closeQuietly(ResultSet, boolean)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void close(final ResultSet rs, final boolean closeStatement, final boolean closeConnection) throws IllegalArgumentException, UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeStatement",
                  "type": "boolean",
                  "javadoc": "If {@code true} , the {@link Statement} from the {@code ResultSet} is also closed.",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeConnection",
                  "type": "boolean",
                  "javadoc": "If {@code true} , the {@link Connection} from the {@code Statement} is also closed. This requires {@code closeStatement} to be {@code true} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code closeConnection} is {@code true} but {@code closeStatement} is {@code false} ."
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "javadoc_summary": "Closes a {@link ResultSet} , and optionally the associated {@link Statement} and {@link Connection} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#closeQuietly(ResultSet, boolean, boolean)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void close(final Statement stmt) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. If {@code null} , the method does nothing.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "javadoc_summary": "Closes the specified {@link Statement} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#closeQuietly(Statement)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated public static void close(final Connection conn) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The {@link Connection} to close. If {@code null} , the method does nothing.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This method is deprecated because it directly closes the connection, which is often not the desired behavior when using a {@link javax.sql.DataSource} that provides pooled connections. Use {@link #releaseConnection(Connection, javax.sql.DataSource)} instead to correctly handle pooled connections and integration with transaction managers. <p> <b> Recommended Alternative: </b> </p> <pre> {@code DataSource dataSource = ...; Connection conn = null; try { conn = JdbcUtil.getConnection(dataSource); // ... perform database operations } finally { // Correctly releases the connection back to the pool or closes it. JdbcUtil.releaseConnection(conn, dataSource); } } </pre>",
                "for_removal": false
              },
              "javadoc_summary": "Closes the specified {@link Connection} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#releaseConnection(Connection, javax.sql.DataSource)",
                "#closeQuietly(Connection)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void close(final ResultSet rs, final Statement stmt) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "javadoc_summary": "Closes the specified {@link ResultSet} and {@link Statement} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#closeQuietly(ResultSet, Statement)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void close(final Statement stmt, final Connection conn) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The {@link Connection} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "javadoc_summary": "Closes the specified {@link Statement} and {@link Connection} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#closeQuietly(Statement, Connection)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "close",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void close(final ResultSet rs, final Statement stmt, final Connection conn) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The {@link Connection} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If a database access error occurs during closing."
                }
              ],
              "javadoc_summary": "Closes the specified {@link ResultSet} , {@link Statement} , and {@link Connection} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#closeQuietly(ResultSet, Statement, Connection)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeQuietly(final ResultSet rs)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Unconditionally closes a {@link ResultSet} , ignoring any {@code SQLException} that occurs.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#close(ResultSet)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeQuietly(final ResultSet rs, final boolean closeStatement) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeStatement",
                  "type": "boolean",
                  "javadoc": "If {@code true} , the {@link Statement} associated with the {@code ResultSet} will also be closed quietly.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If retrieving the {@code Statement} from the {@code ResultSet} fails."
                }
              ],
              "javadoc_summary": "Unconditionally closes a {@link ResultSet} and, optionally, its associated {@link Statement} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#close(ResultSet, boolean)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeQuietly(final ResultSet rs, final boolean closeStatement, final boolean closeConnection) throws IllegalArgumentException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeStatement",
                  "type": "boolean",
                  "javadoc": "If {@code true} , the associated {@link Statement} is also closed quietly.",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeConnection",
                  "type": "boolean",
                  "javadoc": "If {@code true} , the associated {@link Connection} is also closed quietly. Requires {@code closeStatement} to be {@code true} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code closeConnection} is {@code true} but {@code closeStatement} is {@code false} ."
                }
              ],
              "javadoc_summary": "Unconditionally closes a {@link ResultSet} and, optionally, its associated {@link Statement} and {@link Connection} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#close(ResultSet, boolean, boolean)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeQuietly(final Statement stmt)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Unconditionally closes a {@link Statement} , ignoring any {@code SQLException} that occurs.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#close(Statement)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated public static void closeQuietly(final Connection conn)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The {@link Connection} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "This method is deprecated as it encourages manual connection management, which can be error-prone. It's almost always better to use a {@link javax.sql.DataSource} and let it manage the connection lifecycle, or use {@link #releaseConnection(Connection, javax.sql.DataSource)} to safely return a connection to a pool. <p> <b> Usage Examples: </b> </p> <pre> {@code // Avoid this pattern; use a DataSource instead. Connection conn = null; try { conn = JdbcUtil.createConnection(url, user, pass); // ... } catch (SQLException e) { // ... } finally { JdbcUtil.closeQuietly(conn); // Deprecated practice } } </pre>",
                "for_removal": false
              },
              "javadoc_summary": "Unconditionally closes a {@link Connection} , ignoring any {@code SQLException} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#releaseConnection(Connection, javax.sql.DataSource)",
                "#close(Connection)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeQuietly(final ResultSet rs, final Statement stmt)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Unconditionally closes a {@link ResultSet} and a {@link Statement} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#close(ResultSet, Statement)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeQuietly(final Statement stmt, final Connection conn)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The {@link Connection} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Unconditionally closes a {@link Statement} and a {@link Connection} .",
              "contract": [
                "This is primarily for cleanup in {@code finally} blocks when not using a {@code DataSource} ."
              ],
              "examples": [],
              "see_also": [
                "#close(Statement, Connection)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "closeQuietly",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeQuietly(final ResultSet rs, final Statement stmt, final Connection conn)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "The {@link Statement} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The {@link Connection} to close. Can be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Unconditionally closes a {@link ResultSet} , a {@link Statement} , and a {@link Connection} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#close(ResultSet, Statement, Connection)"
              ]
            },
            {
              "name": "skip",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int skip(final ResultSet rs, final int n) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to skip rows in.",
                  "nullability": "unspecified"
                },
                {
                  "name": "n",
                  "type": "int",
                  "javadoc": "The number of rows to skip.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs or the result set type is {@code TYPE_FORWARD_ONLY} ."
                }
              ],
              "javadoc_summary": "Skips a specified number of rows in a {@link ResultSet} .",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code ResultSet rs = statement.executeQuery(\"SELECT * FROM users\"); // Skip the first 10 users int skippedRows = JdbcUtil.skip(rs, 10); if (skippedRows == 10) { // Now processing from the 11th user if (rs.next()) { // ..."
              ],
              "examples": [],
              "see_also": [
                "#skip(ResultSet, long)"
              ]
            },
            {
              "name": "skip",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int skip(final ResultSet rs, long n) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to skip rows in.",
                  "nullability": "unspecified"
                },
                {
                  "name": "n",
                  "type": "long",
                  "javadoc": "The number of rows to skip.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Skips a specified number of rows in a {@link ResultSet} , supporting a {@code long} count.",
              "contract": [
                "It attempts to use {@link ResultSet#absolute(int)} for scrollable result sets and falls back to manual iteration for forward-only result sets or when {@code absolute()} is not supported by the driver."
              ],
              "examples": [],
              "see_also": [
                "ResultSet#absolute(int)"
              ]
            },
            {
              "name": "getColumnCount",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int getColumnCount(final ResultSet rs) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to get the column count from.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Returns the number of columns in a {@link ResultSet} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "ResultSet#getMetaData()",
                "ResultSetMetaData#getColumnCount()"
              ]
            },
            {
              "name": "getColumnNameList",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static List<String> getColumnNameList(final Connection conn, final String tableName) throws SQLException",
              "return_type": "List<String>",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use.",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table for which to retrieve column names.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs or the table does not exist."
                }
              ],
              "javadoc_summary": "Returns an ordered list of column names for a specified table.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#getColumnLabelList(ResultSet)"
              ]
            },
            {
              "name": "getColumnLabelList",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static List<String> getColumnLabelList(final ResultSet rs) throws SQLException",
              "return_type": "List<String>",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} from which to retrieve column labels.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Returns an ordered list of column labels from a {@link ResultSet} .",
              "contract": [
                "If a column has no explicit label, its name is returned instead."
              ],
              "examples": [],
              "see_also": [
                "#getColumnNameList(Connection, String)",
                "ResultSetMetaData#getColumnLabel(int)"
              ]
            },
            {
              "name": "getColumnLabel",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String getColumnLabel(final ResultSetMetaData rsmd, final int columnIndex) throws SQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "rsmd",
                  "type": "ResultSetMetaData",
                  "javadoc": "The {@link ResultSetMetaData} to get the label from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "The 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Returns the column label for a specified column index from {@link ResultSetMetaData} .",
              "contract": [
                "This method prioritizes the column label, but falls back to the column name if the label is {@code null} or empty.",
                "This is useful for consistently getting a meaningful name for a column, especially when aliases are used."
              ],
              "examples": [],
              "see_also": [
                "ResultSetMetaData#getColumnLabel(int)",
                "ResultSetMetaData#getColumnName(int)"
              ]
            },
            {
              "name": "getColumnIndex",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int getColumnIndex(final ResultSet resultSet, final String columnName) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to search within.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "The name or label of the column to find.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Returns the 1-based index of a column in a {@link ResultSet} given its name.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // For a query: \"SELECT user_id, user_name AS name FROM users\" ResultSet rs = ...; int indexByName = JdbcUtil.getColumnIndex(rs, \"user_id\"); // Returns 1 int indexByLabel = JdbcUtil.getColumnIndex(rs, \"name\"); // Returns 2 int caseInsensitiveIndex = JdbcUtil.getColumnIndex(rs, \"USERNAME\"); // Still returns 2 if \"user_name\" is the original name int notFoundIndex = JdbcUtil.getColumnIndex(rs, \"email\"); // Returns -1 } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#getColumnIndex(ResultSetMetaData, String)"
              ]
            },
            {
              "name": "getColumnIndex",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int getColumnIndex(final ResultSetMetaData rsmd, final String columnName) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "rsmd",
                  "type": "ResultSetMetaData",
                  "javadoc": "The {@link ResultSetMetaData} to search within.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "The name or label of the column to find.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Returns the 1-based index of a column from {@link ResultSetMetaData} given its name.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#getColumnIndex(ResultSet, String)"
              ]
            },
            {
              "name": "getColumnValue",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Object getColumnValue(final ResultSet rs, final int columnIndex) throws SQLException",
              "return_type": "Object",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} from which to retrieve the value.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "The 1-based index of the column.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Retrieves the value of a specified column in the current row of a {@link ResultSet} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#getColumnValue(ResultSet, String)"
              ]
            },
            {
              "name": "getColumnValue",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated public static Object getColumnValue(final ResultSet rs, final String columnLabel) throws SQLException",
              "return_type": "Object",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} from which to retrieve the value.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabel",
                  "type": "String",
                  "javadoc": "The label of the column to retrieve.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@link #getColumnValue(ResultSet, int)} with a cached column index for better performance.",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the value of a specified column in the current row of a {@link ResultSet} by its label.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#getColumnValue(ResultSet, int)",
                "#getColumnIndex(ResultSet, String)"
              ]
            },
            {
              "name": "getAllColumnValues",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> List<T> getAllColumnValues(final ResultSet rs, final int columnIndex) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to retrieve values from. It will be iterated to the end.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "The 1-based index of the column to retrieve.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Retrieves all values from a single column of a {@link ResultSet} and returns them as a list.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getAllColumnValues",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> List<T> getAllColumnValues(final ResultSet rs, final String columnLabel) throws SQLException",
              "return_type": "List<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} to retrieve values from. It will be iterated to the end.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabel",
                  "type": "String",
                  "javadoc": "The label of the column to retrieve.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Retrieves all values from a single column of a {@link ResultSet} by its label and returns them as a list.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getColumnValue",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> T getColumnValue(final ResultSet rs, final int columnIndex, final Class<? extends T> targetClass) throws SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} from which to retrieve the value.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "The 1-based index of the column.",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "The {@link Class} of the desired type {@code T} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Retrieves the value of a specified column in the current row of a {@link ResultSet} and converts it to the given target type.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#getColumnValue(ResultSet, String, Class)"
              ]
            },
            {
              "name": "getColumnValue",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated public static <T> T getColumnValue(final ResultSet rs, final String columnLabel, final Class<? extends T> targetClass) throws SQLException",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The {@link ResultSet} from which to retrieve the value.",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnLabel",
                  "type": "String",
                  "javadoc": "The label of the column to retrieve.",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "The {@link Class} of the desired type {@code T} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@link #getColumnValue(ResultSet, int, Class)} with a cached column index for better performance.",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the value of a specified column by its label and converts it to the given target type.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getColumn2FieldNameMap",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static ImmutableMap<String, String> getColumn2FieldNameMap(final Class<?> entityClass)",
              "return_type": "ImmutableMap<String, String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "The entity class to analyze for column-to-field mappings.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves a mapping from database column names to entity field names for a given entity class.",
              "contract": [],
              "examples": [],
              "see_also": [
                "com.landawn.abacus.annotation.Column",
                "com.landawn.abacus.util.NamingPolicy"
              ]
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to get the connection from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL query to prepare with optional {@code ?} parameter placeholders, must not be {@code null} or empty",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code ds} or {@code sql} is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs during preparation"
                }
              ],
              "javadoc_summary": "Prepares a SQL query for execution, returning a {@link PreparedQuery} object that can be reused multiple times with different parameters( {@code 'closeAfterExecution'} flag is set to {@code false} by calling {@code #closeAfterExecution(false)} ).",
              "contract": [
                "This is more efficient than creating new prepared statements for each execution, especially when the same query is executed repeatedly with different parameters.",
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.",
                "</p> <p> <b> Key Features: </b> </p> <ul> <li> Automatic resource management when used with try-with-resources </li> <li> Support for method chaining with fluent parameter setting API </li> <li> Integration with transaction context for transactional operations </li> <li> Type-safe result mapping to Java objects, Lists, Maps, and more </li> <li> Stream support for memory-efficient processing of large result sets </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Basic query execution with single result // If closeAfterExecution(false) is not called, // there is no need to place the query instance in a try-catch block for closure.",
                "Optional<User> user = JdbcUtil.prepareQuery(dataSource, \"SELECT * FROM users WHERE id = ?\") .setLong(1, userId).findFirst(User.class); if (user.isPresent()) { System.out.println(\"Found: \" + user.get().getName()); } // Query with multiple parameters returning a list List<Order> orders = JdbcUtil.prepareQuery(dataSource, \"SELECT * FROM orders WHERE customer_id = ?"
              ],
              "examples": [],
              "see_also": [
                "PreparedQuery",
                "#prepareQuery(Connection, String)",
                "#executeQuery(javax.sql.DataSource, String, Object...)"
              ]
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to get the connection from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare (usually an {@code INSERT} statement).",
                  "nullability": "unspecified"
                },
                {
                  "name": "autoGeneratedKeys",
                  "type": "boolean",
                  "javadoc": "A boolean flag; if {@code true} , the driver will be instructed to make generated keys available.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code ds} or {@code sql} is {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs or the driver does not support auto-generated keys."
                }
              ],
              "javadoc_summary": "Prepares a SQL query with support for retrieving auto-generated keys.",
              "contract": [
                "This is typically used for {@code INSERT} statements when you need to get the ID of the newly created row.",
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Optional<Long> newUserId = JdbcUtil.prepareQuery(dataSource, \"INSERT INTO users (first_name, last_name) VALUES (?, ?)\", true).setString(1, \"John\") .setString(2, \"Doe\") .insert(); if (newUserId.isPresent()) { System.out.println(\"New user created with ID: \" + newUserId.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Statement#RETURN_GENERATED_KEYS"
              ]
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to get the connection from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare.",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "An array of column indexes that should be made available for retrieval.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any of the arguments are {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query to make auto-generated keys available from specified column indexes.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.",
                "String insertSql = \"INSERT INTO documents (content) VALUES (?)\"; Row row = JdbcUtil.prepareQuery(dataSource, insertSql, new int[]{1, 4}) // Assuming id is 1, created_at is 4 .setString(1, \"Some content...\") .insert() .orElse(null); if (row != null) { String generatedUuid = row.getString(1); Timestamp creationTime = row.getTimestamp(2); System.out.println(\"New document created with UUID: \" + generatedUuid + \" at \" + creationTime); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Connection#prepareStatement(String, int[])"
              ]
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to get the connection from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare.",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "An array of column names that should be made available for retrieval.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any of the arguments are {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query to make auto-generated keys available from specified column names.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.",
                "String query = \"INSERT INTO logs (message) VALUES (?)\"; Row generatedValues = JdbcUtil.prepareQuery(dataSource, query, new String[]{\"id\", \"created_at\"}) .setString(1, \"User logged in\") .insert() .orElse(null); if (generatedValues != null) { long newId = generatedValues.getLong(\"id\"); Timestamp creationTime = generatedValues.getTimestamp(\"created_at\"); System.out.println(\"New log entry created with ID: \" + newId + \" at \" + creationTime); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Connection#prepareStatement(String, String[])"
              ]
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final javax.sql.DataSource ds, final String sql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to get the connection from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare.",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "A function that takes a {@link Connection} and a SQL string and returns a new {@link PreparedStatement} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any of the arguments are {@code null} ."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query using a custom {@link PreparedStatement} creator.",
              "contract": [
                "This method provides an extension point to customize the creation of the {@code PreparedStatement} , <p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final Connection conn, final String sql) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use for the query. It will not be closed by this method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL query to prepare.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code conn} or {@code sql} is {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query using a provided {@link Connection} .",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // If closeAfterExecution(false) is not called, // there is no need to place the query instance in a try-catch block for closure."
              ],
              "examples": [],
              "see_also": [
                "#prepareQuery(javax.sql.DataSource, String)"
              ]
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final Connection conn, final String sql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use. It will not be closed by this method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare.",
                  "nullability": "unspecified"
                },
                {
                  "name": "autoGeneratedKeys",
                  "type": "boolean",
                  "javadoc": "If {@code true} , generated keys will be available for retrieval.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code conn} or {@code sql} is {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query with auto-generated keys support using a provided {@link Connection} .",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // If closeAfterExecution(false) is not called, // there is no need to place query instance in a try-catch block for closure."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final Connection conn, final String sql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use. It will not be closed by this method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare.",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "An array of 1-based column indexes of generated keys to return.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any argument is {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query to retrieve auto-generated keys from specified column indexes, using a provided {@link Connection} .",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // Assumes columns 1 ('id') and 4 ('creation_ts') are auto-generated Row generated = JdbcUtil.prepareQuery(conn, \"INSERT INTO events (message) VALUES (?)\", new int[]{1, 4}) .setString(1, \"System startup\") .insert() .orElse(null); if (generated != null) { System.out.println(\"New event ID: \" + generated.get(0)); System.out.println(\"Creation timestamp: \" + generated.get(1)); } } catch (SQLException e) { // Handle exception } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final Connection conn, final String sql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use. It will not be closed by this method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare.",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "An array of column names of generated keys to return.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any argument is {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query to retrieve auto-generated keys from specified column names, using a provided {@link Connection} .",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // Assumes columns 'id' and 'creation_ts' are auto-generated Row generated = JdbcUtil.prepareQuery(conn, \"INSERT INTO events (message) VALUES (?)\", new String[]{\"id\", \"creation_ts\"}) .setString(1, \"System shutdown\") .insert() .orElse(null); if (generated != null) { System.out.println(\"New event ID: \" + generated.getLong(\"id\")); System.out.println(\"Creation timestamp: \" + generated.getTimestamp(\"creation_ts\")); } } catch (SQLException e) { // Handle exception } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static PreparedQuery prepareQuery(final Connection conn, final String sql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use. It will not be closed by this method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL statement to prepare.",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "A factory function to create the {@link PreparedStatement} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any argument is {@code null} ."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query using a custom {@link PreparedStatement} creator and a provided {@link Connection} .",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQueryForLargeResult",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static PreparedQuery prepareQueryForLargeResult(final javax.sql.DataSource ds, final String sql) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to get the connection from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL query to prepare.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query optimized for processing large result sets from a {@link javax.sql.DataSource} .",
              "contract": [
                "This method configures the underlying {@link PreparedStatement} with a forward-only fetch direction and a larger fetch size to improve performance when streaming or iterating over many rows.",
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#prepareQueryForLargeResult(Connection, String)"
              ]
            },
            {
              "name": "prepareQueryForLargeResult",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static PreparedQuery prepareQueryForLargeResult(final Connection conn, final String sql) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database {@link Connection} to use. It will not be closed by this method.",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL query to prepare.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a SQL query optimized for large result sets using a provided {@link Connection} .",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": [
                "#prepareQueryForLargeResult(javax.sql.DataSource, String)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to get the connection from.",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The SQL query with named parameters (e.g., {@code :paramName} ).",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code ds} or {@code namedSql} is {@code null} or empty."
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs."
                }
              ],
              "javadoc_summary": "Prepares a named-parameter SQL query for execution, returning a {@link NamedQuery} object.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "NamedQuery",
                "#prepareNamedQuery(Connection, String)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "autoGeneratedKeys",
                  "type": "boolean",
                  "javadoc": "Whether auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or named SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with auto-generated keys support using the provided DataSource.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Optional<Long> newUserId = JdbcUtil.prepareNamedQuery(dataSource, \"INSERT INTO users (first_name, last_name, email) VALUES (:firstName, :lastName, :email)\", true) .setParameter(\"firstName\", \"John\") .setParameter(\"lastName\", \"Doe\") .setParameter(\"email\", \"john.doe@example.com\") .insert(); if (newUserId.isPresent()) { System.out.println(\"New user created with ID: \" + newUserId.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "The column indexes for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource, named SQL string, or returnColumnIndexes is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column indexes for auto-generated keys using the provided DataSource.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Assuming a table where a trigger generates a UUID at column 1 and a timestamp at column 4 on insert String insertSql = \"INSERT INTO documents (title, content) VALUES (:title, :content)\"; Row row = JdbcUtil.prepareNamedQuery(dataSource, insertSql, new int[]{1, 4}) .setParameter(\"title\", \"Annual Report\") .setParameter(\"content\", \"Report content...\") .insert() .orElse(null); if (row != null) { String generatedUuid = row.getString(1); Timestamp creationTime = row.getTimestamp(2); System.out.println(\"Document created with UUID: \" + generatedUuid + \" at \" + creationTime); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "The column names for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource, named SQL string, or returnColumnNames is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column names for auto-generated keys using the provided DataSource.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Assuming a table with an auto-incrementing 'id' and a 'created_at' column with a default value String query = \"INSERT INTO logs (message, severity) VALUES (:message, :severity)\"; Row generatedValues = JdbcUtil.prepareNamedQuery(dataSource, query, new String[]{\"id\", \"created_at\"}) .setParameter(\"message\", \"User logged in\") .setParameter(\"severity\", \"INFO\") .insert() .orElse(null); if (generatedValues != null) { long newId = generatedValues.getLong(\"id\"); Timestamp creationTime = generatedValues.getTimestamp(\"created_at\"); System.out.println(\"New log entry created with ID: \" + newId + \" at \" + creationTime); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final String namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "A function to create a PreparedStatement with custom configuration",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource, named SQL string, or stmtCreator is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query using a custom statement creator with the provided DataSource.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or named SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query using the provided Connection and named SQL string.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "autoGeneratedKeys",
                  "type": "boolean",
                  "javadoc": "Whether auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or named SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with auto-generated keys support using the provided Connection.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "The column indexes for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection, named SQL string, or returnColumnIndexes is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column indexes for auto-generated keys using the provided Connection.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { // Assumes columns 1 ('id') and 4 ('creation_ts') are auto-generated Row generated = JdbcUtil.prepareNamedQuery(conn, \"INSERT INTO events (event_type, message) VALUES (:type, :msg)\", new int[]{1, 4}) .setParameter(\"type\", \"SYSTEM\") .setParameter(\"msg\", \"System startup\") .insert() .orElse(null); if (generated != null) { System.out.println(\"New event ID: \" + generated.get(0)); System.out.println(\"Creation timestamp: \" + generated.get(1)); } } catch (SQLException e) { // Handle exception } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "The column names for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection, named SQL string, or returnColumnNames is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column names for auto-generated keys using the provided Connection.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code try (Connection conn = dataSource.getConnection()) { Row generatedValues = JdbcUtil.prepareNamedQuery(conn, \"INSERT INTO notifications (user_id, message) VALUES (:userId, :msg)\", new String[]{\"id\", \"created_at\"}) .setParameter(\"userId\", 123) .setParameter(\"msg\", \"Welcome to the system\") .insert() .orElse(null); if (generatedValues != null) { long newId = generatedValues.getLong(\"id\"); Timestamp creationTime = generatedValues.getTimestamp(\"created_at\"); System.out.println(\"New notification ID: \" + newId + \" at \" + creationTime); } } catch (SQLException e) { // Handle exception } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final String namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "A function to create a PreparedStatement with custom configuration",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection, named SQL string, or stmtCreator is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query using a custom statement creator with the provided Connection.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or named SQL is {@code null} or invalid"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query using the provided DataSource and ParsedSql object.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "autoGeneratedKeys",
                  "type": "boolean",
                  "javadoc": "Whether auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or named SQL is {@code null} or invalid"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with auto-generated keys support using the provided DataSource and ParsedSql object.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "The column indexes for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource, named SQL, or returnColumnIndexes is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column indexes for auto-generated keys using the provided DataSource and ParsedSql object.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "The column names for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource, named SQL, or returnColumnNames is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column names for auto-generated keys using the provided DataSource and ParsedSql object.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final javax.sql.DataSource ds, final ParsedSql namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "A function to create a PreparedStatement with custom configuration",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource, named SQL, or stmtCreator is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query using a custom statement creator with the provided DataSource and ParsedSql object.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or named SQL is {@code null} or invalid"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query using the provided Connection and ParsedSql object.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final boolean autoGeneratedKeys) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "autoGeneratedKeys",
                  "type": "boolean",
                  "javadoc": "Whether auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or named SQL is {@code null} or invalid"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with auto-generated keys support using the provided Connection and ParsedSql object.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final int[] returnColumnIndexes) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "The column indexes for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection, named SQL, or returnColumnIndexes is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column indexes for auto-generated keys using the provided Connection and ParsedSql object.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final String[] returnColumnNames) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "The column names for which auto-generated keys should be returned",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection, named SQL, or returnColumnNames is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query with specific column names for auto-generated keys using the provided Connection and ParsedSql object.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static NamedQuery prepareNamedQuery(final Connection conn, final ParsedSql namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "A function to create a PreparedStatement with custom configuration",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection, named SQL, or stmtCreator is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query using a custom statement creator with the provided Connection and ParsedSql object.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQueryForLargeResult",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static NamedQuery prepareNamedQueryForLargeResult(final javax.sql.DataSource ds, final String namedSql) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query optimized for large result sets using the provided DataSource.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQueryForLargeResult",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static NamedQuery prepareNamedQueryForLargeResult(final javax.sql.DataSource ds, final ParsedSql namedSql) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "The ParsedSql object containing the named SQL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query optimized for large result sets using the provided DataSource and ParsedSql object.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQueryForLargeResult",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static NamedQuery prepareNamedQueryForLargeResult(final Connection conn, final String namedSql) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "namedSql",
                  "type": "String",
                  "javadoc": "The named SQL string to prepare",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a named SQL query optimized for large result sets using the provided Connection.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareCallableQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static CallableQuery prepareCallableQuery(final javax.sql.DataSource ds, final String sql) throws IllegalArgumentException, SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string for the stored procedure call",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a callable SQL query (stored procedure) using the provided DataSource.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareCallableQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static CallableQuery prepareCallableQuery(final javax.sql.DataSource ds, final String sql, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the query, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string for the stored procedure call, must not be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, CallableStatement, SQLException>",
                  "javadoc": "A functional interface that creates a CallableStatement with custom configuration. Receives the Connection and SQL string, and returns a configured CallableStatement. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code ds} , {@code sql} , or {@code stmtCreator} is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a callable SQL query using a custom statement creator with the provided DataSource.",
              "contract": [
                "<p> This method intelligently manages connections: if a transaction is active on the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transactional connection is used.",
                "Otherwise, a new connection is obtained from the {@code DataSource} and will be automatically closed when the {@code PreparedQuery} is closed."
              ],
              "examples": [],
              "see_also": [
                "#prepareCallableQuery(javax.sql.DataSource, String)",
                "#getConnection(javax.sql.DataSource)",
                "#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "prepareCallableQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static CallableQuery prepareCallableQuery(final Connection conn, final String sql) throws IllegalArgumentException, SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string for the stored procedure call",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a callable SQL query (stored procedure) using the provided Connection.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareCallableQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static CallableQuery prepareCallableQuery(final Connection conn, final String sql, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws IllegalArgumentException, SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string for the stored procedure call",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, CallableStatement, SQLException>",
                  "javadoc": "A function to create a CallableStatement with custom configuration",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection, SQL string, or stmtCreator is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while preparing the query"
                }
              ],
              "javadoc_summary": "Prepares a callable SQL query using a custom statement creator with the provided Connection.",
              "contract": [
                "The caller MUST close the provided {@code Connection} to avoid resource leaks."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "executeQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset executeQuery(final javax.sql.DataSource ds, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to obtain a connection from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL SELECT statement to execute with optional {@code ?} parameter placeholders, must not be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Object[]",
                  "javadoc": "Variable number of parameters to bind to the SQL statement, matching the {@code ?} placeholders in order. Can be empty if the SQL has no parameters. Supports primitive types, Strings, Dates, and other JDBC-compatible types",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code ds} or {@code sql} is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs, the SQL is invalid, or parameter types are incompatible"
                }
              ],
              "javadoc_summary": "Executes a SQL query immediately with the provided parameters and returns all results as a {@link Dataset} .",
              "contract": [
                "<p> If a transaction is active in the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transaction's Connection will be used."
              ],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeQuery()",
                "#prepareQuery(javax.sql.DataSource, String)",
                "Dataset"
              ]
            },
            {
              "name": "executeQuery",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset executeQuery(final Connection conn, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Object[]",
                  "javadoc": "Optional parameters for the SQL query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the query"
                }
              ],
              "javadoc_summary": "Executes a SQL query using the provided Connection and SQL string with optional parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeQuery()"
              ]
            },
            {
              "name": "executeUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int executeUpdate(final javax.sql.DataSource ds, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The {@link javax.sql.DataSource} to obtain a connection from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL INSERT, UPDATE, DELETE, or DDL statement with optional {@code ?} parameter placeholders, must not be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Object[]",
                  "javadoc": "Variable number of parameters to bind to the SQL statement, matching the {@code ?} placeholders in order. Can be empty if the SQL has no parameters. Supports primitive types, Strings, Dates, and other JDBC-compatible types",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code ds} or {@code sql} is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a database access error occurs, the SQL is invalid, or parameter types are incompatible"
                }
              ],
              "javadoc_summary": "Executes a SQL data modification statement (INSERT, UPDATE, DELETE) or DDL statement immediately with the provided parameters and returns the number of affected rows.",
              "contract": [
                "<p> If a transaction is active in the current thread (started via {@link #beginTransaction(javax.sql.DataSource)} or Spring's transactional support), the transaction's Connection will be used.",
                "AND stock > ?\", 0.9, \"Electronics\", 100); // INSERT with multiple values int inserted = JdbcUtil.executeUpdate(dataSource, \"INSERT INTO user_preferences (user_id, theme, language, notifications) VALUES (?, ?, ?, ?)\", userId, \"DARK\", \"en_US\", true); // DELETE all records (use with caution!) int allDeleted = JdbcUtil.executeUpdate(dataSource, \"DELETE FROM temp_data\"); // No parameters needed // Conditional update if (needsUpdate) { int count = JdbcUtil.executeUpdate(dataSource, \"UPDATE inventory SET quantity = quantity - ?",
                "AND quantity >= ?\", orderQuantity, productId, orderQuantity); if (count == 0) { throw new InsufficientInventoryException(\"Not enough stock\"); } } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeUpdate()",
                "#prepareQuery(javax.sql.DataSource, String)"
              ]
            },
            {
              "name": "executeUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int executeUpdate(final Connection conn, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Object[]",
                  "javadoc": "Optional parameters for the SQL update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the update"
                }
              ],
              "javadoc_summary": "Executes a SQL update using the provided Connection and SQL string with optional parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeUpdate()"
              ]
            },
            {
              "name": "executeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int executeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a batch SQL update using the provided DataSource with default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeBatch()"
              ]
            },
            {
              "name": "executeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int executeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the batch update, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute, must not be {@code null} or empty",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update. Each element should be an Object array or a compatible collection representing one set of parameters.",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The size of each batch, must be positive. Smaller batches use less memory but may be slower; larger batches are faster but use more memory.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If {@code ds} or {@code sql} is {@code null} or empty, or if {@code batchSize} is not positive"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a batch SQL update using the provided DataSource with specified batch size.",
              "contract": [
                "When the number of parameter sets exceeds the batch size, a transaction is automatically started to ensure atomicity."
              ],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeBatch()",
                "#executeBatchUpdate(javax.sql.DataSource, String, List)"
              ]
            },
            {
              "name": "executeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int executeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a batch SQL update using the provided Connection with default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeBatch()"
              ]
            },
            {
              "name": "executeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int executeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a batch SQL update using the provided Connection with specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeBatch()"
              ]
            },
            {
              "name": "executeLargeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long executeLargeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a large batch SQL update using the provided DataSource with default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeLargeBatch()"
              ]
            },
            {
              "name": "executeLargeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long executeLargeBatchUpdate(final javax.sql.DataSource ds, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a large batch SQL update using the provided DataSource with specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeLargeBatch()"
              ]
            },
            {
              "name": "executeLargeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long executeLargeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters) throws IllegalArgumentException, SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a large batch SQL update using the provided Connection with default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeLargeBatch()"
              ]
            },
            {
              "name": "executeLargeBatchUpdate",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long executeLargeBatchUpdate(final Connection conn, final String sql, final List<?> listOfParameters, final int batchSize) throws IllegalArgumentException, SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "listOfParameters",
                  "type": "List<?>",
                  "javadoc": "A list of parameter sets for the batch update",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the batch update"
                }
              ],
              "javadoc_summary": "Executes a large batch SQL update using the provided Connection with specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#executeLargeBatch()"
              ]
            },
            {
              "name": "execute",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean execute(final javax.sql.DataSource ds, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The DataSource to use for the SQL execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Object[]",
                  "javadoc": "Optional parameters for the SQL statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the DataSource or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the statement"
                }
              ],
              "javadoc_summary": "Executes a SQL statement using the provided DataSource with optional parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#execute()"
              ]
            },
            {
              "name": "execute",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean execute(final Connection conn, final String sql, final Object... parameters) throws IllegalArgumentException, SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The Connection to use for the SQL execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "The SQL string to execute",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameters",
                  "type": "Object[]",
                  "javadoc": "Optional parameters for the SQL statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the Connection or SQL string is {@code null} or empty"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while executing the statement"
                }
              ],
              "javadoc_summary": "Executes a SQL statement using the provided Connection with optional parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "PreparedStatement#execute()"
              ]
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet and returns it as a Dataset.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final int offset, final int count) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "offset",
                  "type": "int",
                  "javadoc": "The starting position in the ResultSet (0-based)",
                  "nullability": "unspecified"
                },
                {
                  "name": "count",
                  "type": "int",
                  "javadoc": "The maximum number of rows to extract",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet starting from the specified offset and up to the specified count.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final RowFilter filter) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "RowFilter",
                  "javadoc": "The RowFilter to apply while extracting data. This is a functional interface that tests each row; only rows for which {@code filter.test(rs)} returns {@code true} will be included in the result. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet using the specified RowFilter.",
              "contract": [],
              "examples": [],
              "see_also": [
                "RowFilter",
                "#extractData(ResultSet, RowFilter, RowExtractor)"
              ]
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final RowExtractor rowExtractor) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "The RowExtractor to apply while extracting data. This is a functional interface that receives the current ResultSet and an output row array, allowing modification of the row data before it's added to the Dataset. Must not be {@code null} .",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet using the specified RowExtractor.",
              "contract": [],
              "examples": [],
              "see_also": [
                "RowExtractor",
                "#extractData(ResultSet, RowFilter, RowExtractor)"
              ]
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final RowFilter filter, final RowExtractor rowExtractor) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "RowFilter",
                  "javadoc": "The RowFilter to apply for filtering rows. Only rows for which {@code filter.test(rs)} returns {@code true} will be processed by the extractor. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "applied to extract data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet using both RowFilter and RowExtractor.",
              "contract": [],
              "examples": [],
              "see_also": [
                "RowFilter",
                "RowExtractor",
                "#extractData(ResultSet, RowFilter)",
                "#extractData(ResultSet, RowExtractor)"
              ]
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final boolean closeResultSet) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeResultSet",
                  "type": "boolean",
                  "javadoc": "Whether to close the ResultSet after extraction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet and returns it as a Dataset.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final int offset, final int count, final boolean closeResultSet) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "offset",
                  "type": "int",
                  "javadoc": "The starting position in the ResultSet",
                  "nullability": "unspecified"
                },
                {
                  "name": "count",
                  "type": "int",
                  "javadoc": "The number of rows to extract",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeResultSet",
                  "type": "boolean",
                  "javadoc": "Whether to close the ResultSet after extraction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet with specified offset and count.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final int offset, final int count, final RowFilter filter, final boolean closeResultSet) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "offset",
                  "type": "int",
                  "javadoc": "The starting position (0-based) in the ResultSet, must be non-negative",
                  "nullability": "unspecified"
                },
                {
                  "name": "count",
                  "type": "int",
                  "javadoc": "The maximum number of rows to extract, must be non-negative",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "RowFilter",
                  "javadoc": "The RowFilter to apply while extracting data. Only rows for which {@code filter.test(rs)} returns {@code true} will be included. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeResultSet",
                  "type": "boolean",
                  "javadoc": "Whether to close the ResultSet after extraction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet with offset, count, and filter.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#extractData(ResultSet, int, int, RowFilter, RowExtractor, boolean)"
              ]
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final int offset, final int count, final RowExtractor rowExtractor, final boolean closeResultSet) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "offset",
                  "type": "int",
                  "javadoc": "The starting position (0-based) in the ResultSet, must be non-negative",
                  "nullability": "unspecified"
                },
                {
                  "name": "count",
                  "type": "int",
                  "javadoc": "The maximum number of rows to extract, must be non-negative",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "applied to extract data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeResultSet",
                  "type": "boolean",
                  "javadoc": "Whether to close the ResultSet after extraction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet with offset, count, and extractor.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#extractData(ResultSet, int, int, RowFilter, RowExtractor, boolean)"
              ]
            },
            {
              "name": "extractData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Dataset extractData(final ResultSet rs, final int offset, final int count, final RowFilter filter, final RowExtractor rowExtractor, final boolean closeResultSet) throws IllegalArgumentException, SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to extract data from, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "offset",
                  "type": "int",
                  "javadoc": "The starting position (0-based) in the ResultSet, must be non-negative",
                  "nullability": "unspecified"
                },
                {
                  "name": "count",
                  "type": "int",
                  "javadoc": "The maximum number of rows to extract, must be non-negative",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "RowFilter",
                  "javadoc": "The RowFilter to apply for filtering rows. Only rows for which {@code filter.test(rs)} returns {@code true} will be processed. Must not be {@code null} .",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowExtractor",
                  "type": "RowExtractor",
                  "javadoc": "applied to extract data from the current row of the {@code ResultSet} and populates the {@code outputRow} array.",
                  "nullability": "unspecified"
                },
                {
                  "name": "closeResultSet",
                  "type": "boolean",
                  "javadoc": "Whether to close the ResultSet after extraction completes (or if an error occurs)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If any argument is invalid (null or negative values)"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "If a SQL exception occurs while extracting data"
                }
              ],
              "javadoc_summary": "Extracts data from the provided ResultSet with all extraction options.",
              "contract": [],
              "examples": [],
              "see_also": [
                "RowFilter",
                "RowExtractor",
                "#extractData(ResultSet, RowFilter, RowExtractor)"
              ]
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Stream<Object[]> stream(final ResultSet resultSet)",
              "return_type": "Stream<Object[]>",
              "type_params": [],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to create a stream from",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a stream from the provided ResultSet.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> Stream<T> stream(final ResultSet resultSet, final Class<? extends T> targetClass) throws IllegalArgumentException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "The ResultSet to create a stream from",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetClass",
                  "type": "Class<? extends T>",
                  "javadoc": "The class of the result type. Column names from the ResultSet will be mapped to properties of this class",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "If the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Creates a stream from the provided ResultSet, mapping each row to the specified target class.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> Stream<T> stream(final ResultSet resultSet, final RowMapper<? extends T> rowMapper) throws IllegalArgumentException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet to create a stream from",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "RowMapper<? extends T>",
                  "javadoc": "the RowMapper to apply while extracting data. This mapper is called for each row in the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Creates a stream from the provided ResultSet using the specified RowMapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> Stream<T> stream(final ResultSet resultSet, final RowFilter rowFilter, final RowMapper<? extends T> rowMapper) throws IllegalArgumentException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet to create a stream from",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "RowFilter",
                  "javadoc": "the RowFilter to apply while filtering rows. Only rows for which this filter returns {@code true} will be included",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "RowMapper<? extends T>",
                  "javadoc": "the RowMapper to apply while extracting data from filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Creates a stream from the provided ResultSet using the specified RowFilter and RowMapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> Stream<T> stream(final ResultSet resultSet, final BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet to create a stream from",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to apply while extracting data. This mapper receives both the ResultSet and column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Creates a stream from the provided ResultSet using the specified BiRowMapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> Stream<T> stream(final ResultSet resultSet, final BiRowFilter rowFilter, final BiRowMapper<? extends T> rowMapper) throws IllegalArgumentException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet to create a stream from",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "BiRowFilter",
                  "javadoc": "the BiRowFilter to apply while filtering rows. Both ResultSet and column labels are provided",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "BiRowMapper<? extends T>",
                  "javadoc": "the BiRowMapper to apply while extracting data from filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Creates a stream from the provided ResultSet using the specified BiRowFilter and BiRowMapper.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code BiRowFilter hasNonNullValues = (rs, columnLabels) -> { for (String label : columnLabels) { if (rs.getObject(label) != null) return true; } return false; }; BiRowMapper<String> csvMapper = (rs, columnLabels) -> columnLabels.stream() .map(label -> rs.getString(label)) .collect(Collectors.joining(\",\")); JdbcUtil.stream(resultSet, hasNonNullValues, csvMapper) .onClose(Fn.closeQuietly(resultSet)) .forEach(csvRow -> System.out.println(csvRow)); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> Stream<T> stream(final ResultSet resultSet, final int columnIndex) throws IllegalArgumentException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet to create a stream from",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnIndex",
                  "type": "int",
                  "javadoc": "the index of the column to extract data from, starting from 1",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Creates a stream from the provided ResultSet using the specified column index.",
              "contract": [
                "This is useful when you only need values from a single column."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> Stream<T> stream(final ResultSet resultSet, final String columnName) throws IllegalArgumentException",
              "return_type": "Stream<T>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "resultSet",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet to create a stream from",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnName",
                  "type": "String",
                  "javadoc": "the name of the column to extract data from",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Creates a stream from the provided ResultSet using the specified column name.",
              "contract": [
                "This is useful when you only need values from a single column identified by name."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "streamAllResultSets",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Stream<Dataset> streamAllResultSets(final Statement stmt)",
              "return_type": "Stream<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "the Statement to extract ResultSets from",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Extracts all ResultSets from the provided Statement and returns them as a Stream of Dataset.",
              "contract": [
                "This is useful when executing stored procedures that return multiple result sets."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "streamAllResultSets",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"resource\") public static <R> Stream<R> streamAllResultSets(final Statement stmt, final ResultExtractor<R> resultExtractor) throws IllegalArgumentException",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "the Statement to extract ResultSets from",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "ResultExtractor<R>",
                  "javadoc": "the ResultExtractor to apply while extracting data from each ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Extracts all ResultSets from the provided Statement and returns them as a Stream.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "streamAllResultSets",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"resource\") public static <R> Stream<R> streamAllResultSets(final Statement stmt, final BiResultExtractor<R> resultExtractor) throws IllegalArgumentException",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "stmt",
                  "type": "Statement",
                  "javadoc": "the Statement to extract ResultSets from",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "BiResultExtractor<R>",
                  "javadoc": "the BiResultExtractor to apply while extracting data",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                }
              ],
              "javadoc_summary": "Extracts all ResultSets from the provided Statement and returns them as a Stream.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryByPage",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static Stream<Dataset> queryByPage(final javax.sql.DataSource ds, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, Dataset> paramSetter)",
              "return_type": "Stream<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to get the connection from",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query to run for each page. Must include ORDER BY and LIMIT/FETCH clauses",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super AbstractQuery, Dataset>",
                  "javadoc": "the BiParametersSetter to set parameters for the query; the second parameter is the result set for the previous page (null for first page)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .",
              "contract": [
                "The query must be ordered by at least one key/id and have a result size limitation (e.g., LIMIT pageSize).",
                "ORDER BY id LIMIT 1000\"; JdbcUtil.queryByPage(dataSource, query, 1000, (preparedQuery, previousPage) -> { if (previousPage == null) { preparedQuery.setLong(1, 0); } else { long lastId = previousPage.getLong(previousPage.size() - 1, \"id\"); preparedQuery.setLong(1, lastId); } }).forEach(page -> { System.out.println(\"Processing \" + page.size() + \" records\"); // Process the page }); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryByPage",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <R> Stream<R> queryByPage(final javax.sql.DataSource ds, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.ResultExtractor<R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to get the connection from",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query to run for each page",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super AbstractQuery, R>",
                  "javadoc": "the BiParametersSetter to set parameters for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<R>",
                  "javadoc": "the ResultExtractor to extract results from the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .",
              "contract": [
                "The query must be ordered by at least one key/id and have a result size limitation.",
                "ORDER BY order_id LIMIT 500\"; ResultExtractor<List<Order>> ordersExtractor = rs -> { List<Order> orders = new ArrayList<>(); while (rs.next()) { orders.add(new Order(rs.getLong(\"order_id\"), rs.getDate(\"order_date\"))); } return orders; }; JdbcUtil.queryByPage(dataSource, query, 500, (preparedQuery, previousOrders) -> { if (previousOrders == null) { preparedQuery.setDate(1, startDate); } else { Order lastOrder = previousOrders.get(previousOrders.size() - 1); preparedQuery.setDate(1, lastOrder.getOrderDate()); } }, ordersExtractor) .forEach(orders -> processOrderBatch(orders)); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryByPage",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <R> Stream<R> queryByPage(final javax.sql.DataSource ds, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.BiResultExtractor<R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to get the connection from",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query to run for each page",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super AbstractQuery, R>",
                  "javadoc": "the BiParametersSetter to set parameters for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<R>",
                  "javadoc": "the BiResultExtractor to extract results from the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .",
              "contract": [
                "The query must be ordered by at least one key/id and have a result size limitation."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryByPage",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static Stream<Dataset> queryByPage(final Connection conn, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, Dataset> paramSetter)",
              "return_type": "Stream<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to use for queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query to run for each page",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super AbstractQuery, Dataset>",
                  "javadoc": "the BiParametersSetter to set parameters for the query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .",
              "contract": [
                "The query must be ordered by at least one key/id and have a result size limitation."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryByPage",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <R> Stream<R> queryByPage(final Connection conn, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.ResultExtractor<R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to use for queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query to run for each page",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super AbstractQuery, R>",
                  "javadoc": "the BiParametersSetter to set parameters for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<R>",
                  "javadoc": "the ResultExtractor to extract results from the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryByPage",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <R> Stream<R> queryByPage(final Connection conn, final String query, final int pageSize, final Jdbc.BiParametersSetter<? super AbstractQuery, R> paramSetter, final Jdbc.BiResultExtractor<R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to use for queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query to run for each page",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super AbstractQuery, R>",
                  "javadoc": "the BiParametersSetter to set parameters for the query",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<R>",
                  "javadoc": "the BiResultExtractor to extract results from the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Runs a {@code Stream} with each element (page) loaded from the database table by running the specified SQL {@code query} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "doesTableExist",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean doesTableExist(final javax.sql.DataSource ds, final String tableName)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The data source to get the connection from",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table to check",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Checks if a table exists in the database.",
              "contract": [
                "Checks if a table exists in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.doesTableExist(ds, \"users\")) { System.out.println(\"Users table exists\"); } else { System.out.println(\"Users table does not exist\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "doesTableExist",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean doesTableExist(final Connection conn, final String tableName)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use for checking table existence",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table to check",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Checks if a table exists in the database.",
              "contract": [
                "Checks if a table exists in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.doesTableExist(connection, \"users\")) { System.out.println(\"Users table exists\"); } else { System.out.println(\"Users table does not exist\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createTableIfNotExists",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean createTableIfNotExists(final Connection conn, final String tableName, final String schema)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use for creating the table",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table to create",
                  "nullability": "unspecified"
                },
                {
                  "name": "schema",
                  "type": "String",
                  "javadoc": "The SQL schema definition (CREATE TABLE statement) for the table",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a table if it does not already exist in the database.",
              "contract": [
                "Creates a table if it does not already exist in the database.",
                "This method first checks if the table exists, and if not, executes the provided schema to create it."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "dropTableIfExists",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean dropTableIfExists(final Connection conn, final String tableName)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "The database connection to use for dropping the table",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table to drop",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Drops the specified table if it exists in the database.",
              "contract": [
                "Drops the specified table if it exists in the database.",
                "This method first checks if the table exists before attempting to drop it, preventing errors from trying to drop a non-existent table."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getDBLock",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static DBLock getDBLock(final javax.sql.DataSource ds, final String tableName)",
              "return_type": "DBLock",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "The data source to use for database connections",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "The name of the table used for storing lock information",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a new instance of {@code DBLock} for implementing global locks using a database table.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code DBLock lock = JdbcUtil.getDBLock(dataSource, \"distributed_locks\"); if (lock.acquire(\"job_processor\")) { try { // Perform exclusive operation } finally { lock.release(\"job_processor\"); } } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static ContinuableFuture<Void> asyncRun(final Throwables.Runnable<Exception> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Runnable<Exception>",
                  "javadoc": "The SQL action to be executed asynchronously",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the specified SQL action is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously runs the specified SQL action in a separate thread.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static Tuple2<ContinuableFuture<Void>, ContinuableFuture<Void>> asyncRun(final Throwables.Runnable<Exception> sqlAction1, final Throwables.Runnable<Exception> sqlAction2) throws IllegalArgumentException",
              "return_type": "Tuple2<ContinuableFuture<Void>, ContinuableFuture<Void>>",
              "type_params": [],
              "params": [
                {
                  "name": "sqlAction1",
                  "type": "Throwables.Runnable<Exception>",
                  "javadoc": "The first SQL action to be executed asynchronously",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction2",
                  "type": "Throwables.Runnable<Exception>",
                  "javadoc": "The second SQL action to be executed asynchronously",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if any of the SQL actions are {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously runs two SQL actions in separate threads.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static Tuple3<ContinuableFuture<Void>, ContinuableFuture<Void>, ContinuableFuture<Void>> asyncRun(final Throwables.Runnable<Exception> sqlAction1, final Throwables.Runnable<Exception> sqlAction2, final Throwables.Runnable<Exception> sqlAction3) throws IllegalArgumentException",
              "return_type": "Tuple3<ContinuableFuture<Void>, ContinuableFuture<Void>, ContinuableFuture<Void>>",
              "type_params": [],
              "params": [
                {
                  "name": "sqlAction1",
                  "type": "Throwables.Runnable<Exception>",
                  "javadoc": "The first SQL action to be executed asynchronously",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction2",
                  "type": "Throwables.Runnable<Exception>",
                  "javadoc": "The second SQL action to be executed asynchronously",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction3",
                  "type": "Throwables.Runnable<Exception>",
                  "javadoc": "The third SQL action to be executed asynchronously",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if any of the SQL actions are {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously runs three SQL actions in separate threads.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T> ContinuableFuture<Void> asyncRun(final T t, final Throwables.Consumer<? super T, Exception> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "t",
                  "type": "T",
                  "javadoc": "The parameter to be passed to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction",
                  "type": "Throwables.Consumer<? super T, Exception>",
                  "javadoc": "The SQL action to be executed with the parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the SQL action is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously runs the specified SQL action with the given parameter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T, U> ContinuableFuture<Void> asyncRun(final T t, final U u, final Throwables.BiConsumer<? super T, ? super U, Exception> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "U",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "t",
                  "type": "T",
                  "javadoc": "The first parameter to be passed to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "u",
                  "type": "U",
                  "javadoc": "The second parameter to be passed to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction",
                  "type": "Throwables.BiConsumer<? super T, ? super U, Exception>",
                  "javadoc": "The SQL action to be executed with the parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the SQL action is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously runs the specified SQL action with two parameters.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <A, B, C> ContinuableFuture<Void> asyncRun(final A a, final B b, final C c, final Throwables.TriConsumer<? super A, ? super B, ? super C, Exception> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [
                {
                  "name": "A",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "B",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "C",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "a",
                  "type": "A",
                  "javadoc": "The first parameter to be passed to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "b",
                  "type": "B",
                  "javadoc": "The second parameter to be passed to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "c",
                  "type": "C",
                  "javadoc": "The third parameter to be passed to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction",
                  "type": "Throwables.TriConsumer<? super A, ? super B, ? super C, Exception>",
                  "javadoc": "The SQL action to be executed with the parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the SQL action is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously runs the specified SQL action with three parameters.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <R> ContinuableFuture<R> asyncCall(final Callable<R> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Callable<R>",
                  "javadoc": "The SQL action that produces a result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the SQL action is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously calls the specified SQL action and returns a result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <R1, R2> Tuple2<ContinuableFuture<R1>, ContinuableFuture<R2>> asyncCall(final Callable<R1> sqlAction1, final Callable<R2> sqlAction2) throws IllegalArgumentException",
              "return_type": "Tuple2<ContinuableFuture<R1>, ContinuableFuture<R2>>",
              "type_params": [
                {
                  "name": "R1",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R2",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction1",
                  "type": "Callable<R1>",
                  "javadoc": "The first SQL action that produces a result",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction2",
                  "type": "Callable<R2>",
                  "javadoc": "The second SQL action that produces a result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if any of the SQL actions are {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously calls two SQL actions and returns their results.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <R1, R2, R3> Tuple3<ContinuableFuture<R1>, ContinuableFuture<R2>, ContinuableFuture<R3>> asyncCall(final Callable<R1> sqlAction1, final Callable<R2> sqlAction2, final Callable<R3> sqlAction3) throws IllegalArgumentException",
              "return_type": "Tuple3<ContinuableFuture<R1>, ContinuableFuture<R2>, ContinuableFuture<R3>>",
              "type_params": [
                {
                  "name": "R1",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R2",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R3",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction1",
                  "type": "Callable<R1>",
                  "javadoc": "The first SQL action that produces a result",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction2",
                  "type": "Callable<R2>",
                  "javadoc": "The second SQL action that produces a result",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction3",
                  "type": "Callable<R3>",
                  "javadoc": "The third SQL action that produces a result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if any of the SQL actions are {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously calls three SQL actions and returns their results.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T, R> ContinuableFuture<R> asyncCall(final T t, final Throwables.Function<? super T, ? extends R, Exception> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "t",
                  "type": "T",
                  "javadoc": "The parameter to pass to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction",
                  "type": "Throwables.Function<? super T, ? extends R, Exception>",
                  "javadoc": "The SQL action that takes a parameter and produces a result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the sqlAction is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously calls the specified SQL action with one parameter and returns a result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T, U, R> ContinuableFuture<R> asyncCall(final T t, final U u, final Throwables.BiFunction<? super T, ? super U, ? extends R, Exception> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "U",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "t",
                  "type": "T",
                  "javadoc": "The first parameter to pass to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "u",
                  "type": "U",
                  "javadoc": "The second parameter to pass to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction",
                  "type": "Throwables.BiFunction<? super T, ? super U, ? extends R, Exception>",
                  "javadoc": "The SQL action that takes two parameters and produces a result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the sqlAction is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously calls the specified SQL action with two parameters and returns a result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <A, B, C, R> ContinuableFuture<R> asyncCall(final A a, final B b, final C c, final Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, Exception> sqlAction) throws IllegalArgumentException",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "A",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "B",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "C",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "a",
                  "type": "A",
                  "javadoc": "The first parameter to pass to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "b",
                  "type": "B",
                  "javadoc": "The second parameter to pass to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "c",
                  "type": "C",
                  "javadoc": "The third parameter to pass to the SQL action",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlAction",
                  "type": "Throwables.TriFunction<? super A, ? super B, ? super C, ? extends R, Exception>",
                  "javadoc": "The SQL action that takes three parameters and produces a result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the sqlAction is {@code null}"
                }
              ],
              "javadoc_summary": "Asynchronously calls the specified SQL action with three parameters and returns a result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getOutParameters",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static OutParamResult getOutParameters(final CallableStatement stmt, final List<OutParam> outParams) throws IllegalArgumentException, SQLException",
              "return_type": "OutParamResult",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "CallableStatement",
                  "javadoc": "The CallableStatement from which to retrieve the output parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "outParams",
                  "type": "List<OutParam>",
                  "javadoc": "The list of OutParam objects representing the output parameters to retrieve",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the provided arguments are invalid"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a SQL exception occurs while retrieving the output parameters"
                }
              ],
              "javadoc_summary": "Retrieves the output parameters from the given CallableStatement.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getNamedParameters",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static List<String> getNamedParameters(final String sql)",
              "return_type": "List<String>",
              "type_params": [],
              "params": [
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "the SQL string containing named parameters (e.g., :paramName)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Extracts the named parameters from the given SQL string.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "parseSql",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static ParsedSql parseSql(final String sql)",
              "return_type": "ParsedSql",
              "type_params": [],
              "params": [
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "the SQL string to be parsed",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Parses the given SQL string and returns a ParsedSql object.",
              "contract": [],
              "examples": [],
              "see_also": [
                "ParsedSql#parse(String)"
              ]
            },
            {
              "name": "getInsertPropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Collection<String> getInsertPropNames(final Object entity)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "Object",
                  "javadoc": "the entity object to analyze",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns the property names suitable for INSERT operations for the given entity.",
              "contract": [
                "This method returns all property names that should be included in an INSERT statement, excluding properties marked with annotations like @ReadOnly, @Id (for auto-generated IDs), etc.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User(); Collection<String> propNames = JdbcUtil.getInsertPropNames(user); // Returns property names that should be included in INSERT statement } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getInsertPropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") public static Collection<String> getInsertPropNames(final Object entity, final Set<String> excludedPropNames)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "Object",
                  "javadoc": "the entity object to analyze",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedPropNames",
                  "type": "Set<String>",
                  "javadoc": "property names to exclude from the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns the property names suitable for INSERT operations for the given entity, excluding the specified property names.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getInsertPropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Collection<String> getInsertPropNames(final Class<?> entityClass)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to analyze",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns the property names suitable for INSERT operations for the given entity class.",
              "contract": [
                "This method analyzes the class structure to determine which properties should be included in INSERT statements.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Collection<String> propNames = JdbcUtil.getInsertPropNames(User.class); // Returns property names that should be included in INSERT statement for User entities } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getInsertPropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") public static Collection<String> getInsertPropNames(final Class<?> entityClass, final Set<String> excludedPropNames)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to analyze",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedPropNames",
                  "type": "Set<String>",
                  "javadoc": "property names to exclude from the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns the property names suitable for INSERT operations for the given entity class, excluding the specified property names.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getSelectPropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Collection<String> getSelectPropNames(final Class<?> entityClass)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to analyze",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Gets the property names suitable for SELECT operations for the given entity class.",
              "contract": [
                "This method returns all property names that should be included in a SELECT statement, excluding properties marked with @Transient or other exclusion annotations.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Collection<String> propNames = JdbcUtil.getSelectPropNames(User.class); // Returns property names that should be included in SELECT statement } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getSelectPropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Collection<String> getSelectPropNames(final Class<?> entityClass, final Set<String> excludedPropNames)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to analyze",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedPropNames",
                  "type": "Set<String>",
                  "javadoc": "property names to exclude from the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Gets the property names suitable for SELECT operations for the given entity class, excluding the specified property names.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getSelectPropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") public static Collection<String> getSelectPropNames(final Class<?> entityClass, final boolean includeSubEntityProperties, final Set<String> excludedPropNames)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to analyze",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeSubEntityProperties",
                  "type": "boolean",
                  "javadoc": "whether to include properties of sub-entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedPropNames",
                  "type": "Set<String>",
                  "javadoc": "property names to exclude from the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Gets the property names suitable for SELECT operations for the given entity class, with an option to include sub-entity properties and exclude specified property names.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getUpdatePropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Collection<String> getUpdatePropNames(final Class<?> entityClass)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to analyze",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Gets the property names suitable for UPDATE operations for the given entity class.",
              "contract": [
                "This method returns all property names that should be included in an UPDATE statement, excluding properties marked with @ReadOnly, @NonUpdatable, @Id, etc."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getUpdatePropNames",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") public static Collection<String> getUpdatePropNames(final Class<?> entityClass, final Set<String> excludedPropNames)",
              "return_type": "Collection<String>",
              "type_params": [],
              "params": [
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to analyze",
                  "nullability": "unspecified"
                },
                {
                  "name": "excludedPropNames",
                  "type": "Set<String>",
                  "javadoc": "property names to exclude from the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Gets the property names suitable for UPDATE operations for the given entity class, excluding the specified property names.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "blob2String",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String blob2String(final Blob blob) throws SQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "blob",
                  "type": "Blob",
                  "javadoc": "the Blob object to be converted to a String",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a SQL exception occurs while accessing the Blob"
                }
              ],
              "javadoc_summary": "Converts a Blob to a String using UTF-8 encoding and frees the Blob resources.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "blob2String",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String blob2String(final Blob blob, final Charset charset) throws SQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "blob",
                  "type": "Blob",
                  "javadoc": "the Blob object to be converted to a String",
                  "nullability": "unspecified"
                },
                {
                  "name": "charset",
                  "type": "Charset",
                  "javadoc": "the character encoding to use for the conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a SQL exception occurs while accessing the Blob"
                }
              ],
              "javadoc_summary": "Converts a Blob to a String using the specified character encoding and frees the Blob resources.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "writeBlobToFile",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long writeBlobToFile(final Blob blob, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "blob",
                  "type": "Blob",
                  "javadoc": "the Blob object containing the data to be written",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File object representing the output file",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a SQL exception occurs while accessing the Blob"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Writes the content of a Blob to a file and frees the Blob resources.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "clob2String",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static String clob2String(final Clob clob) throws SQLException",
              "return_type": "String",
              "type_params": [],
              "params": [
                {
                  "name": "clob",
                  "type": "Clob",
                  "javadoc": "the Clob object to be converted to a String",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a SQL exception occurs while accessing the Clob"
                }
              ],
              "javadoc_summary": "Converts a Clob to a String and frees the Clob resources.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "writeClobToFile",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long writeClobToFile(final Clob clob, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "clob",
                  "type": "Clob",
                  "javadoc": "the Clob object containing the data to be written",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File object representing the output file",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a SQL exception occurs while accessing the Clob"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O exception occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Writes the content of a Clob to a file and frees the Clob resources.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isNullOrDefault",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean isNullOrDefault(final Object value)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "value",
                  "type": "Object",
                  "javadoc": "the value to check",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Checks if the given value is {@code null} or equals the default value for its type.",
              "contract": [
                "Checks if the given value is {@code null} or equals the default value for its type."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "turnOffSqlLogGlobally",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void turnOffSqlLogGlobally()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Globally disables SQL logging across all threads in the application.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "turnOffSqlPerfLogGlobally",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void turnOffSqlPerfLogGlobally()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Globally disables SQL performance logging across all threads in the application.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "turnOffDaoMethodPerfLogGlobally",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void turnOffDaoMethodPerfLogGlobally()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Globally disables DAO method performance logging across all threads in the application.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "enableSqlLog",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void enableSqlLog()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Enables SQL logging for the current thread with the default maximum log length.",
              "contract": [
                "When enabled, all SQL statements executed in the current thread will be logged."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "enableSqlLog",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void enableSqlLog(final int maxSqlLogLength)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "maxSqlLogLength",
                  "type": "int",
                  "javadoc": "the maximum length of SQL statements in logs",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Enables SQL logging for the current thread with a specified maximum log length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "disableSqlLog",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void disableSqlLog()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Disables SQL logging for the current thread.",
              "contract": [
                "The maximum SQL log length setting is preserved for when logging is re-enabled."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isSqlLogEnabled",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean isSqlLogEnabled()",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Checks if SQL logging is enabled for the current thread.",
              "contract": [
                "Checks if SQL logging is enabled for the current thread.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.isSqlLogEnabled()) { System.out.println(\"SQL logging is active\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getSqlExtractor",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Throwables.Function<Statement, String, SQLException> getSqlExtractor()",
              "return_type": "Throwables.Function<Statement, String, SQLException>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Retrieves the current SQL extractor function used to extract SQL statements from Statement objects.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setSqlExtractor",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void setSqlExtractor(final Throwables.Function<Statement, String, SQLException> sqlExtractor)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "sqlExtractor",
                  "type": "Throwables.Function<Statement, String, SQLException>",
                  "javadoc": "the SQL extractor function to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Sets a custom SQL extractor function to extract SQL statements from Statement objects.",
              "contract": [
                "This is useful when using custom Statement implementations or when the default extraction method doesn't work for your JDBC driver.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code JdbcUtil.setSqlExtractor(statement -> { if (statement instanceof MyCustomStatement) { return ((MyCustomStatement) statement).getOriginalSql(); } return statement.toString(); }); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getSqlLogHandler",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static TriConsumer<String, Long, Long> getSqlLogHandler()",
              "return_type": "TriConsumer<String, Long, Long>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Retrieves the current SQL log handler that processes SQL statements and their execution times.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code TriConsumer<String, Long, Long> handler = JdbcUtil.getSqlLogHandler(); if (handler != null) { // Handler is configured } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setSqlLogHandler",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void setSqlLogHandler(final TriConsumer<String, Long, Long> sqlLogHandler)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "sqlLogHandler",
                  "type": "TriConsumer<String, Long, Long>",
                  "javadoc": "the handler that receives: SQL statement, start time (ms), end time (ms)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Sets a custom SQL log handler to process SQL statements and their execution times.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code JdbcUtil.setSqlLogHandler((sql, startTime, endTime) -> { long duration = endTime - startTime; if (duration > 1000) { // Log slow queries logger.warn(\"Slow query ({}ms): {}\", duration, sql); } // Send metrics to monitoring system metricsCollector.recordSqlExecution(sql, duration); }); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setMinExecutionTimeForSqlPerfLog",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void setMinExecutionTimeForSqlPerfLog(final long minExecutionTimeForSqlPerfLog)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "minExecutionTimeForSqlPerfLog",
                  "type": "long",
                  "javadoc": "the minimum execution time in milliseconds",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Sets the minimum execution time threshold for SQL performance logging in the current thread.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setMinExecutionTimeForSqlPerfLog",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void setMinExecutionTimeForSqlPerfLog(final long minExecutionTimeForSqlPerfLog, final int maxSqlLogLength)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "minExecutionTimeForSqlPerfLog",
                  "type": "long",
                  "javadoc": "the minimum execution time in milliseconds (use -1 to disable)",
                  "nullability": "unspecified"
                },
                {
                  "name": "maxSqlLogLength",
                  "type": "int",
                  "javadoc": "the maximum length of SQL statements in performance logs",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Sets the minimum execution time threshold for SQL performance logging in the current thread with a specified maximum SQL log length.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getMinExecutionTimeForSqlPerfLog",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long getMinExecutionTimeForSqlPerfLog()",
              "return_type": "long",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Gets the current minimum execution time threshold for SQL performance logging in the current thread.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "runWithSqlLogDisabled",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> void runWithSqlLogDisabled(final Throwables.Runnable<E> sqlAction) throws E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Runnable<E>",
                  "javadoc": "the action to execute without SQL logging",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "E",
                  "condition": "if the action throws an exception"
                }
              ],
              "javadoc_summary": "Executes the specified action with SQL logging temporarily disabled.",
              "contract": [
                "Note: The SQL action should not be executed in another thread as the logging flag is thread-local."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callWithSqlLogDisabled",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <R, E extends Exception> R callWithSqlLogDisabled(final Throwables.Callable<R, E> sqlAction) throws E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Callable<R, E>",
                  "javadoc": "the callable to execute without SQL logging",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "E",
                  "condition": "if the callable throws an exception"
                }
              ],
              "javadoc_summary": "Executes the specified callable with SQL logging temporarily disabled and returns its result.",
              "contract": [
                "Note: The SQL action should not be executed in another thread as the logging flag is thread-local."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isInTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static boolean isInTransaction(final javax.sql.DataSource ds)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to check for an active transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Checks if there is an active transaction for the given DataSource in the current thread.",
              "contract": [
                "Checks if there is an active transaction for the given DataSource in the current thread.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (JdbcUtil.isInTransaction(dataSource)) { // Execute operations within the existing transaction } else { // Start a new transaction SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); // ..."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "beginTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static SQLTransaction beginTransaction(final javax.sql.DataSource dataSource) throws UncheckedSQLException",
              "return_type": "SQLTransaction",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the {@link javax.sql.DataSource} for which to begin the transaction, must not be {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs while beginning the transaction"
                }
              ],
              "javadoc_summary": "Begins a new database transaction with the default isolation level for the specified DataSource.",
              "contract": [
                "<p> The transaction must be explicitly committed via {@code commit()} to persist changes, or rolled back via {@code rollback()} or {@code rollbackIfNotCommitted()} to discard changes.",
                "Always use a try-finally block to ensure the transaction is properly completed even if exceptions occur.",
                "</p> <p> <b> Spring Integration: </b> </p> <p> If Spring's transaction management is active, JdbcUtil will automatically participate in the Spring transaction instead of creating a new one.",
                "AND balance >= ?\", amount, accountId, amount); if (updatedRows == 0) { throw new InsufficientFundsException(\"Insufficient balance\"); } JdbcUtil.executeUpdate(dataSource, \"INSERT INTO transactions (account_id, amount, type) VALUES (?, ?, ?)\", accountId, amount, \"DEBIT\"); tran.commit(); } catch (Exception e) { // Transaction automatically rolled back in finally block logger.error(\"Transaction failed: \" + e.getMessage()); throw e; } finally { tran.rollbackIfNotCommitted(); } // Transaction shared across method calls public void processOrder(Order order) { SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); try { createOrder(order); // Shares this transaction updateInventory(order); // Shares this transaction sendNotification(order); // Shares this transaction tran.commit(); } finally { tran.rollbackIfNotCommitted(); } } private void createOrder(Order order) { // This automatically uses the transaction from processOrder() JdbcUtil.executeUpdate(dataSource, \"INSERT INTO orders (id, customer_id, total) VALUES (?, ?, ?)\", order.getId(), order.getCustomerId(), order.getTotal()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "#beginTransaction(javax.sql.DataSource, IsolationLevel)",
                "#beginTransaction(javax.sql.DataSource, IsolationLevel, boolean)",
                "SQLTransaction#commit()",
                "SQLTransaction#rollback()",
                "SQLTransaction#rollbackIfNotCommitted()"
              ]
            },
            {
              "name": "beginTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static SQLTransaction beginTransaction(final javax.sql.DataSource dataSource, final IsolationLevel isolationLevel) throws UncheckedSQLException",
              "return_type": "SQLTransaction",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource for which to begin the transaction",
                  "nullability": "unspecified"
                },
                {
                  "name": "isolationLevel",
                  "type": "IsolationLevel",
                  "javadoc": "the isolation level for the transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a SQL exception occurs while beginning the transaction"
                }
              ],
              "javadoc_summary": "Begins a new transaction with the specified isolation level for the given DataSource.",
              "contract": [
                "The transaction must be explicitly committed or rolled back."
              ],
              "examples": [],
              "see_also": [
                "#beginTransaction(javax.sql.DataSource, IsolationLevel, boolean)"
              ]
            },
            {
              "name": "beginTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static SQLTransaction beginTransaction(final javax.sql.DataSource dataSource, final IsolationLevel isolationLevel, final boolean isForUpdateOnly) throws UncheckedSQLException",
              "return_type": "SQLTransaction",
              "type_params": [],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource for which to begin the transaction",
                  "nullability": "unspecified"
                },
                {
                  "name": "isolationLevel",
                  "type": "IsolationLevel",
                  "javadoc": "the isolation level for the transaction",
                  "nullability": "unspecified"
                },
                {
                  "name": "isForUpdateOnly",
                  "type": "boolean",
                  "javadoc": "whether this transaction is only for update operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a SQL exception occurs while beginning the transaction"
                }
              ],
              "javadoc_summary": "Starts a global transaction which will be shared by all in-line database queries with the same DataSource in the same thread.",
              "contract": [
                "If a Spring transaction is already active with the specified DataSource, the Connection from the Spring transaction will be used."
              ],
              "examples": [],
              "see_also": [
                "JdbcUtil#getConnection(javax.sql.DataSource)",
                "JdbcUtil#releaseConnection(Connection, javax.sql.DataSource)"
              ]
            },
            {
              "name": "callInTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T, E extends Throwable> T callInTransaction(final javax.sql.DataSource dataSource, final Throwables.Callable<T, E> cmd) throws IllegalArgumentException, E",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource for the transaction",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Callable<T, E>",
                  "javadoc": "the callable to execute within the transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if dataSource or cmd is null"
                },
                {
                  "type": "E",
                  "condition": "if the callable throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given callable within a transaction and returns its result.",
              "contract": [
                "If the callable completes successfully, the transaction is committed.",
                "If an exception occurs, the transaction is rolled back."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callInTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T, E extends Throwable> T callInTransaction(final javax.sql.DataSource dataSource, final Throwables.Function<Connection, T, E> cmd) throws E",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource for the transaction",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Function<Connection, T, E>",
                  "javadoc": "the function to execute with the transaction's connection",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given function within a transaction, providing the transaction's connection.",
              "contract": [
                "If the function completes successfully, the transaction is committed.",
                "If an exception occurs, the transaction is rolled back."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "runInTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <E extends Throwable> void runInTransaction(final javax.sql.DataSource dataSource, final Throwables.Runnable<E> cmd) throws IllegalArgumentException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource for the transaction",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Runnable<E>",
                  "javadoc": "the runnable to execute within the transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if dataSource or cmd is null"
                },
                {
                  "type": "E",
                  "condition": "if the runnable throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given runnable within a transaction.",
              "contract": [
                "If the runnable completes successfully, the transaction is committed.",
                "If an exception occurs, the transaction is rolled back."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "runInTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <E extends Throwable> void runInTransaction(final javax.sql.DataSource dataSource, final Throwables.Consumer<Connection, E> cmd) throws IllegalArgumentException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource for the transaction",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Consumer<Connection, E>",
                  "javadoc": "the consumer to execute with the transaction's connection",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if dataSource or cmd is null"
                },
                {
                  "type": "E",
                  "condition": "if the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given consumer within a transaction, providing the transaction's connection.",
              "contract": [
                "If the consumer completes successfully, the transaction is committed.",
                "If an exception occurs, the transaction is rolled back."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callNotInStartedTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T, E extends Throwable> T callNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Callable<T, E> cmd) throws IllegalArgumentException, E",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Callable<T, E>",
                  "javadoc": "the callable to execute outside any transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if dataSource or cmd is null"
                },
                {
                  "type": "E",
                  "condition": "if the callable throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given callable outside any active transaction for the specified DataSource.",
              "contract": [
                "If a transaction is active in the current thread, a new connection (not part of the transaction) will be used to execute the callable."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callNotInStartedTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <T, E extends Throwable> T callNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Function<javax.sql.DataSource, T, E> cmd) throws IllegalArgumentException, E",
              "return_type": "T",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Function<javax.sql.DataSource, T, E>",
                  "javadoc": "the function to execute outside any transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if dataSource or cmd is null"
                },
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given function outside any active transaction for the specified DataSource.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "runNotInStartedTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <E extends Throwable> void runNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Runnable<E> cmd) throws IllegalArgumentException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Runnable<E>",
                  "javadoc": "the runnable to execute outside any transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if dataSource or cmd is null"
                },
                {
                  "type": "E",
                  "condition": "if the runnable throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given runnable outside any active transaction for the specified DataSource.",
              "contract": [
                "If a transaction is active in the current thread, a new connection (not part of the transaction) will be used to execute the runnable."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "runNotInStartedTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta public static <E extends Throwable> void runNotInStartedTransaction(final javax.sql.DataSource dataSource, final Throwables.Consumer<javax.sql.DataSource, E> cmd) throws IllegalArgumentException, E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "cmd",
                  "type": "Throwables.Consumer<javax.sql.DataSource, E>",
                  "javadoc": "the consumer to execute outside any transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if dataSource or cmd is null"
                },
                {
                  "type": "E",
                  "condition": "if the consumer throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given consumer outside any active transaction for the specified DataSource.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code JdbcUtil.runNotInStartedTransaction(dataSource, ds -> { // Use the DataSource for non-transactional operations try (Connection conn = ds.getConnection()) { // Perform operations that should not be part of current transaction } }); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "runWithoutUsingSpringTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> void runWithoutUsingSpringTransaction(final Throwables.Runnable<E> sqlAction) throws E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Runnable<E>",
                  "javadoc": "the runnable to execute without Spring transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "E",
                  "condition": "if the runnable throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given runnable without using Spring transaction management.",
              "contract": [
                "Note: The action should not be executed in another thread as the flag is thread-local."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callWithoutUsingSpringTransaction",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <R, E extends Exception> R callWithoutUsingSpringTransaction(final Throwables.Callable<R, E> sqlAction) throws E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Callable<R, E>",
                  "javadoc": "the callable to execute without Spring transaction",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "E",
                  "condition": "if the callable throws an exception"
                }
              ],
              "javadoc_summary": "Executes the given callable without using Spring transaction management and returns its result.",
              "contract": [
                "Note: The action should not be executed in another thread as the flag is thread-local."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setIdExtractorForDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T, ID, SB extends SQLBuilder, TD extends CrudDao<T, ID, SB, TD>> void setIdExtractorForDao( final Class<? extends CrudDao<T, ID, SB, TD>> daoInterface, final RowMapper<? extends ID> idExtractor) throws IllegalArgumentException",
              "return_type": "void",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "SB",
                  "bounds": [
                    "SQLBuilder"
                  ]
                },
                {
                  "name": "TD",
                  "bounds": [
                    "CrudDao<T, ID, SB, TD>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<? extends CrudDao<T, ID, SB, TD>>",
                  "javadoc": "the DAO interface class",
                  "nullability": "unspecified"
                },
                {
                  "name": "idExtractor",
                  "type": "RowMapper<? extends ID>",
                  "javadoc": "the RowMapper used to extract the ID from ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if daoInterface or idExtractor is null"
                }
              ],
              "javadoc_summary": "Sets the ID extractor for the specified DAO interface.",
              "contract": [
                "The extractor is used when retrieving generated keys after insert operations."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setIdExtractorForDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T, ID, SB extends SQLBuilder, TD extends CrudDao<T, ID, SB, TD>> void setIdExtractorForDao( final Class<? extends CrudDao<T, ID, SB, TD>> daoInterface, final BiRowMapper<? extends ID> idExtractor) throws IllegalArgumentException",
              "return_type": "void",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "ID",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "SB",
                  "bounds": [
                    "SQLBuilder"
                  ]
                },
                {
                  "name": "TD",
                  "bounds": [
                    "CrudDao<T, ID, SB, TD>"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<? extends CrudDao<T, ID, SB, TD>>",
                  "javadoc": "the DAO interface class",
                  "nullability": "unspecified"
                },
                {
                  "name": "idExtractor",
                  "type": "BiRowMapper<? extends ID>",
                  "javadoc": "the BiRowMapper used to extract the ID with column information",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if daoInterface or idExtractor is null"
                }
              ],
              "javadoc_summary": "Sets the ID extractor for the specified DAO interface using a BiRowMapper.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Custom ID extraction with column label awareness JdbcUtil.setIdExtractorForDao(UserDao.class, (rs, columnLabels) -> { if (columnLabels.contains(\"composite_id\")) { return UserIdParser.parse(rs.getString(\"composite_id\")); } return rs.getLong(\"id\"); }); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement, must not be {@code null} . The interface should extend {@link Dao} or {@link CrudDao} and define the entity type and ID type",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the {@link javax.sql.DataSource} to use for all database operations, must not be {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a dynamic Data Access Object (DAO) implementation for the specified interface and DataSource.",
              "contract": [
                "ORDER BY created_at DESC\") List<User> findByStatus(String status); @NamedSelect(\"SELECT * FROM users WHERE age >= :minAge AND city = :city\") Stream<User> findByAgeAndCity(@Bind(\"minAge\") int minAge, @Bind(\"city\") String city); } // Create and use the DAO UserDao userDao = JdbcUtil.createDao(UserDao.class, dataSource); // Use inherited CRUD operations User newUser = new User(\"john@example.com\", \"John Doe\"); userDao.save(newUser); // Use custom query methods Optional<User> user = userDao.findByEmail(\"john@example.com\"); if (user.isPresent()) { System.out.println(\"Found: \" + user.get().getName()); } // List all active users List<User> activeUsers = userDao.findByStatus(\"ACTIVE\"); // Stream results for large datasets try (Stream<User> stream = userDao.findByAgeAndCity(25, \"New York\")) { long count = stream .filter(u -> u.getEmail().endsWith(\"@company.com\")) .count(); } // Batch operations List<User> users = Arrays.asList(user1, user2, user3); userDao.batchSave(users); // Update operations user.get().setStatus(\"INACTIVE\"); userDao.update(user.get()); // Delete operations userDao.deleteById(userId); } </pre> <p> <b> Advanced DAO Features: </b> </p> <pre> {@code // Define a DAO with complex queries public interface OrderDao extends CrudDao<Order, Long, SQLBuilder.PSC, OrderDao> { // Aggregate queries @Select(\"SELECT COUNT(*) FROM orders WHERE status = ?\") long countByStatus(String status); @Select(\"SELECT SUM(total_amount) FROM orders WHERE customer_id = ?\") Optional<BigDecimal> getTotalByCustomer(Long customerId); // Complex joins (SQL defined externally in SQL mapper file) @NamedSelect(\"findOrdersWithCustomerDetails\") List<OrderWithCustomer> findOrdersWithCustomerDetails(@Bind(\"startDate\") Date start); // Async operations @Select(\"SELECT * FROM orders WHERE id = ?\") CompletableFuture<Optional<Order>> findByIdAsync(Long id); } OrderDao orderDao = JdbcUtil.createDao(OrderDao.class, dataSource); // Use aggregate queries long pendingCount = orderDao.countByStatus(\"PENDING\"); // Async operations CompletableFuture<Optional<Order>> future = orderDao.findByIdAsync(orderId); future.thenAccept(order -> { order.ifPresent(o -> System.out.println(\"Order: \" + o.getId())); }); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Dao",
                "CrudDao",
                "#createDao(Class, javax.sql.DataSource, SQLMapper)",
                "#createDao(Class, javax.sql.DataSource, Executor)"
              ]
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a DAO instance with a custom SQL mapper for query externalization.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated @SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache daoCache)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoCache",
                  "type": "Jdbc.DaoCache",
                  "javadoc": "the cache for DAO operations (should not be shared between DAOs)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use version without explicit cache parameter",
                "for_removal": false
              },
              "javadoc_summary": "Creates a DAO instance with a custom SQL mapper and DAO cache.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final Executor executor)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor for asynchronous operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a DAO instance with a custom executor for asynchronous operations.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Executor executor)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor for asynchronous operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a DAO instance with a custom SQL mapper and executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated @SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache daoCache, final Executor executor)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoCache",
                  "type": "Jdbc.DaoCache",
                  "javadoc": "the cache for DAO operations (should not be shared between DAOs)",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor for asynchronous operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use version without explicit cache parameter",
                "for_removal": false
              },
              "javadoc_summary": "Creates a DAO instance with all customization options.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the specific table name to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a DAO instance for a specific table name.",
              "contract": [
                "This is useful when the table name differs from the entity class name."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the specific table name to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a DAO instance for a specific table with a custom SQL mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated @SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache daoCache)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the specific table name to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "daoCache",
                  "type": "Jdbc.DaoCache",
                  "javadoc": "the cache for DAO operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use version without explicit cache parameter",
                "for_removal": false
              },
              "javadoc_summary": "Creates a DAO instance for a specific table with SQL mapper and cache.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final Executor executor)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the specific table name to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor for asynchronous operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a DAO instance for a specific table with a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Executor executor)",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the specific table name to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor for asynchronous operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a DAO instance for a specific table with SQL mapper and executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createDao",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated @SuppressWarnings(\"rawtypes\") public static <TD extends Dao> TD createDao(final Class<TD> daoInterface, final String targetTableName, final javax.sql.DataSource ds, final SQLMapper sqlMapper, final Jdbc.DaoCache cache, final Executor executor) throws IllegalArgumentException",
              "return_type": "TD",
              "type_params": [
                {
                  "name": "TD",
                  "bounds": [
                    "Dao"
                  ]
                }
              ],
              "params": [
                {
                  "name": "daoInterface",
                  "type": "Class<TD>",
                  "javadoc": "the DAO interface class to implement",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the specific table name to use",
                  "nullability": "unspecified"
                },
                {
                  "name": "ds",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to use for database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlMapper",
                  "type": "SQLMapper",
                  "javadoc": "the SQL mapper for externalizing queries",
                  "nullability": "unspecified"
                },
                {
                  "name": "cache",
                  "type": "Jdbc.DaoCache",
                  "javadoc": "the cache for DAO operations (should not be shared between DAOs)",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor for asynchronous operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if required parameters are invalid"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use version without explicit cache parameter",
                "for_removal": false
              },
              "javadoc_summary": "Creates a DAO instance with all customization options including table name.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "startDaoCacheOnCurrentThread",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Jdbc.DaoCache startDaoCacheOnCurrentThread()",
              "return_type": "Jdbc.DaoCache",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Enables DAO query result caching for the current thread.",
              "contract": [
                "Must be paired with {@link #closeDaoCacheOnCurrentThread()} to prevent memory leaks."
              ],
              "examples": [],
              "see_also": [
                "Jdbc.DaoCache#createByMap()",
                "#closeDaoCacheOnCurrentThread()"
              ]
            },
            {
              "name": "startDaoCacheOnCurrentThread",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Jdbc.DaoCache startDaoCacheOnCurrentThread(final Jdbc.DaoCache localThreadCache)",
              "return_type": "Jdbc.DaoCache",
              "type_params": [],
              "params": [
                {
                  "name": "localThreadCache",
                  "type": "Jdbc.DaoCache",
                  "javadoc": "the cache to use for the current thread",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Enables the specified DAO cache for the current thread.",
              "contract": [
                "Must be paired with {@link #closeDaoCacheOnCurrentThread()} to prevent memory leaks."
              ],
              "examples": [],
              "see_also": [
                "Jdbc.DaoCache#createByMap()",
                "Jdbc.DaoCache#createByMap(Map)",
                "#closeDaoCacheOnCurrentThread()"
              ]
            },
            {
              "name": "closeDaoCacheOnCurrentThread",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static void closeDaoCacheOnCurrentThread()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Closes and removes the DAO cache for the current thread.",
              "contract": [
                "This method should always be called in a finally block after starting a thread-local cache to prevent memory leaks."
              ],
              "examples": [],
              "see_also": [
                "#startDaoCacheOnCurrentThread()",
                "#startDaoCacheOnCurrentThread(Jdbc.DaoCache)"
              ]
            }
          ],
          "fields": [
            {
              "name": "DEFAULT_BATCH_SIZE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "200",
              "javadoc_summary": "Default batch size for batch operations."
            },
            {
              "name": "DEFAULT_FETCH_SIZE_FOR_BIG_RESULT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "1000",
              "javadoc_summary": "Default fetch size for retrieving large result sets."
            },
            {
              "name": "DEFAULT_FETCH_SIZE_FOR_STREAM",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "100",
              "javadoc_summary": "Default fetch size for stream-based result processing."
            },
            {
              "name": "DEFAULT_CACHE_CAPACITY",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "1000",
              "javadoc_summary": "Default capacity for internal caches."
            },
            {
              "name": "DEFAULT_CACHE_EVICT_DELAY",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "3 * 1000",
              "javadoc_summary": "Default cache evict delay in milliseconds."
            },
            {
              "name": "DEFAULT_CACHE_LIVE_TIME",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "30 * 60 * 1000",
              "javadoc_summary": "Default cache live time in milliseconds."
            },
            {
              "name": "DEFAULT_MAX_SQL_LOG_LENGTH",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "1024",
              "javadoc_summary": "Default maximum length for SQL logs."
            },
            {
              "name": "DEFAULT_MIN_EXECUTION_TIME_FOR_SQL_PERF_LOG",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "long",
              "value": "1000L",
              "javadoc_summary": "Default minimum execution time in milliseconds for SQL performance logging."
            },
            {
              "name": "DEFAULT_MIN_EXECUTION_TIME_FOR_DAO_METHOD_PERF_LOG",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "long",
              "value": "3000L",
              "javadoc_summary": "Default minimum execution time in milliseconds for DAO method performance logging."
            },
            {
              "name": "DEFAULT_CACHE_MAX_IDLE_TIME",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "int",
              "value": "3 * 60 * 1000",
              "javadoc_summary": "Default maximum idle time for cache entries in milliseconds."
            },
            {
              "name": "DEFAULT_SQL_EXTRACTOR",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Throwables.Function<Statement, String, SQLException>",
              "value": "(stmt)->{ Statement stmtToUse = stmt; String clsName = stmtToUse.getClass().getName(); if ((clsName.startsWith(\"com.zaxxer.hikari\") || clsName.startsWith(\"com.mchange.v2.c3p0\")) && stmt.isWrapperFor(Statement.class)) { stmtToUse = stmt.unwrap(Statement.class); clsName = stmtToUse.getClass().getName(); } if (clsName.startsWith(\"oracle.jdbc\") && (stmtToUse instanceof oracle.jdbc.internal.OraclePreparedStatement)) { try { return ((oracle.jdbc.internal.OraclePreparedStatement)stmtToUse).getOriginalSql(); } catch (final SQLException e) { } } return stmtToUse.toString(); }",
              "javadoc_summary": "Default SQL extractor function used to extract SQL statements from Statement objects."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.JdbcUtils",
          "name": "JdbcUtils",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "A comprehensive, enterprise-grade utility class providing advanced database import/export operations, data migration capabilities, and high-performance batch processing for seamless data movement between databases, CSV files, and in-memory datasets.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final javax.sql.DataSource sourceDataSource, final String insertSql) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the Dataset",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table using the provided DataSource and insert SQL statement.",
              "contract": [
                "The column order in the SQL statement must be consistent with the column order in the Dataset."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final Connection conn, final String insertSql) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the Dataset",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table using the provided Connection and insert SQL statement.",
              "contract": [
                "The column order in the SQL statement must be consistent with the column order in the Dataset."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Connection conn, final String insertSql) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be selected for import",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the selected columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports selected columns from a Dataset to a database table using the provided Connection and insert SQL statement.",
              "contract": [
                "Only the specified columns will be imported, and their order in the SQL must match the Dataset column order."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be selected for import",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the selected columns",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports selected columns from a Dataset to a database table with configurable batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Throwables.Predicate<? super Object[], E> filter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis) throws SQLException, E",
              "return_type": "int",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be selected for import",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super Object[], E>",
                  "javadoc": "a predicate to filter the rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the selected columns",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports filtered data from a Dataset to a database table with configurable batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final Map<String, ? extends Type> columnTypeMap) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the Dataset",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnTypeMap",
                  "type": "Map<String, ? extends Type>",
                  "javadoc": "a map specifying the types of the columns for type conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table with custom column type mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the Dataset",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnTypeMap",
                  "type": "Map<String, ? extends Type>",
                  "javadoc": "a map specifying the types of the columns for type conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table with custom column type mapping and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws SQLException, E",
              "return_type": "int",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super Object[], E>",
                  "javadoc": "a predicate to filter the rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders; column order must match the Dataset",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnTypeMap",
                  "type": "Map<String, ? extends Type>",
                  "javadoc": "a map specifying the types of the columns for type conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports filtered data from a Dataset to a database table with custom column type mapping and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>",
                  "javadoc": "a BiConsumer to set the parameters of the PreparedStatement for each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table with a custom statement setter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>",
                  "javadoc": "a BiConsumer to set the parameters of the PreparedStatement for each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table with a custom statement setter and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException, E",
              "return_type": "int",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super Object[], E>",
                  "javadoc": "a predicate to filter the rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>",
                  "javadoc": "a BiConsumer to set the parameters of the PreparedStatement for each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports filtered data from a Dataset to a database table with a custom statement setter and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final PreparedStatement stmt) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table using the provided PreparedStatement.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final PreparedStatement stmt) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be selected for import",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports selected columns from a Dataset to a database table using the provided PreparedStatement.",
              "contract": [
                "Only the specified columns will be imported, and their order must match the PreparedStatement parameters."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final Collection<String> selectColumnNames, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be selected for import",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports selected columns from a Dataset to a database table using the provided PreparedStatement with batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> int importData(final Dataset dataset, final Collection<String> selectColumnNames, final Throwables.Predicate<? super Object[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis) throws SQLException, E",
              "return_type": "int",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be selected for import",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super Object[], E>",
                  "javadoc": "a predicate to filter the rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports filtered data from selected columns of a Dataset to a database table using the provided PreparedStatement.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static int importData(final Dataset dataset, final PreparedStatement stmt, final Map<String, ? extends Type> columnTypeMap) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnTypeMap",
                  "type": "Map<String, ? extends Type>",
                  "javadoc": "a map specifying the types of the columns for type conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table using the provided PreparedStatement with custom column type mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public static int importData(final Dataset dataset, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnTypeMap",
                  "type": "Map<String, ? extends Type>",
                  "javadoc": "a map specifying the types of the columns for type conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table using the provided PreparedStatement with custom column type mapping and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@SuppressWarnings({ \"rawtypes\", \"null\" }) public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Map<String, ? extends Type> columnTypeMap) throws IllegalArgumentException, SQLException, E",
              "return_type": "int",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super Object[], E>",
                  "javadoc": "a predicate to filter the rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "columnTypeMap",
                  "type": "Map<String, ? extends Type>",
                  "javadoc": "a map specifying the types of the columns for type conversion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if batchSize is not greater than 0 or batchIntervalInMillis is negative"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports filtered data from a Dataset to a database table using the provided PreparedStatement with custom column type mapping and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final PreparedStatement stmt, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>",
                  "javadoc": "a BiConsumer to set the parameters of the PreparedStatement for each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table using the provided PreparedStatement with a custom statement setter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static int importData(final Dataset dataset, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>",
                  "javadoc": "a BiConsumer to set the parameters of the PreparedStatement for each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from a Dataset to a database table using the provided PreparedStatement with a custom statement setter and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> int importData(final Dataset dataset, final Throwables.Predicate<? super Object[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException> stmtSetter) throws IllegalArgumentException, SQLException, E",
              "return_type": "int",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "dataset",
                  "type": "Dataset",
                  "javadoc": "the Dataset containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super Object[], E>",
                  "javadoc": "a predicate to filter the rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super Object[], SQLException>",
                  "javadoc": "a BiConsumer to set the parameters of the PreparedStatement for each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if batchSize is not greater than 0 or batchIntervalInMillis is negative"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports filtered data from a Dataset to a database table using the provided PreparedStatement with a custom statement setter and batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importData(final File file, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super String, Object[], E>",
                  "javadoc": "a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a file to a database table using the provided DataSource and a line parser function.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importData(final File file, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super String, Object[], E>",
                  "javadoc": "a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a file to a database table using the provided Connection with batch processing and a line parser function.",
              "contract": [
                "This method provides control over batch size and interval for optimal performance when importing large files.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code File csvFile = new File(\"large_users.csv\"); String insertSql = \"INSERT INTO users (name, age, email) VALUES (?, ?, ?)\"; Function<String, Object[]> parser = line -> { String[] parts = line.split(\",\"); if (parts.length < 3) return null; // Skip invalid lines return new Object[] { parts[0], Integer.parseInt(parts[1]), parts[2] }; }; long rowsImported = JdbcUtils.importData(csvFile, connection, insertSql, 1000, 100, parser); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importData(final File file, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super String, Object[], E>",
                  "javadoc": "a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a file to a database table using the provided PreparedStatement with batch processing and a line parser function.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importData(final Reader reader, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.Function<? super String, Object[], E> line2Parameters) throws SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the Reader containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders",
                  "nullability": "unspecified"
                },
                {
                  "name": "line2Parameters",
                  "type": "Throwables.Function<? super String, Object[], E>",
                  "javadoc": "a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a Reader to a database table using the provided DataSource and a line parser function.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importData(final Reader reader, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> func) throws SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the Reader containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with placeholders",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "func",
                  "type": "Throwables.Function<? super String, Object[], E>",
                  "javadoc": "a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a Reader to a database table using the provided Connection with batch processing and a line parser function.",
              "contract": [
                "This method provides control over batch size and interval for optimal performance when importing large data streams."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importData(final Reader reader, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.Function<? super String, Object[], E> line2Parameters) throws IllegalArgumentException, SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the Reader containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be inserted in each batch",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch execution",
                  "nullability": "unspecified"
                },
                {
                  "name": "line2Parameters",
                  "type": "Throwables.Function<? super String, Object[], E>",
                  "javadoc": "a function to process each line and convert it to an array of objects for insertion; returns {@code null} to skip the line",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                },
                {
                  "type": "E",
                  "condition": "if the function throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a Reader to a database table using the provided PreparedStatement with batch processing and a line parser function.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Reader reader = new InputStreamReader(inputStream); PreparedStatement stmt = connection.prepareStatement(\"INSERT INTO logs (level, message, timestamp) VALUES (?, ?, ?)\"); Function<String, Object[]> parser = line -> { // Parse log format: [LEVEL] timestamp - message Pattern pattern = Pattern.compile(\"\\\\[(\\\\w+)\\\\] (\\\\d+) - (.+)\"); Matcher matcher = pattern.matcher(line); if (!matcher.matches()) return null; return new Object[] { matcher.group(1), matcher.group(3), new Timestamp(Long.parseLong(matcher.group(2))) }; }; long rowsImported = JdbcUtils.importData(reader, stmt, 1000, 0, parser); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> long importData(final Iterator<? extends T> iter, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "iter",
                  "type": "Iterator<? extends T>",
                  "javadoc": "the Iterator containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections from",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with parameter placeholders (?)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException>",
                  "javadoc": "a BiConsumer to map iterator elements to PreparedStatement parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from an Iterator to the database using the specified DataSource and SQL insert statement.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> long importData(final Iterator<? extends T> iter, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "iter",
                  "type": "Iterator<? extends T>",
                  "javadoc": "the Iterator containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement with parameter placeholders (?)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to accumulate before executing a batch insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the pause duration in milliseconds between batch executions",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException>",
                  "javadoc": "a BiConsumer to map iterator elements to PreparedStatement parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from an Iterator to the database using the provided Connection with configurable batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importData",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <T> long importData(final Iterator<? extends T> iter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "iter",
                  "type": "Iterator<? extends T>",
                  "javadoc": "the Iterator containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import (will not be closed)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to accumulate before executing a batch insert (must be greater than 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the pause duration in milliseconds between batch executions (0 for no pause)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super T, SQLException>",
                  "javadoc": "a BiConsumer to map iterator elements to PreparedStatement parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Imports data from an Iterator to the database using the provided PreparedStatement with configurable batch processing.",
              "contract": [
                "<p> This method is useful when you need to reuse a PreparedStatement or have specific statement configuration requirements.",
                "</p> <p> Performance tips: </p> <ul> <li> Larger batch sizes generally improve performance but consume more memory </li> <li> Batch intervals can help prevent database overload during massive imports </li> <li> Consider the database's maximum packet size when setting batch size </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import with transaction control and prepared statement reuse Connection conn = dataSource.getConnection(); conn.setAutoCommit(false); PreparedStatement stmt = conn.prepareStatement( \"INSERT INTO orders (order_id, customer_id, total, status) VALUES (?, ?, ?, ?)\"); try { // Import pending orders Iterator<Order> pendingOrders = getPendingOrders(); long pending = JdbcUtils.importData(pendingOrders, stmt, 1000, 0, (query, order) -> { query.setLong(1, order.getId()); query.setLong(2, order.getCustomerId()); query.setBigDecimal(3, order.getTotal()); query.setString(4, \"PENDING\"); }); // Reuse statement for completed orders Iterator<Order> completedOrders = getCompletedOrders(); long completed = JdbcUtils.importData(completedOrders, stmt, 1000, 0, (query, order) -> { query.setLong(1, order.getId()); query.setLong(2, order.getCustomerId()); query.setBigDecimal(3, order.getTotal()); query.setString(4, \"COMPLETED\"); }); conn.commit(); System.out.println(\"Imported \" + pending + \" pending and \" + completed + \" completed orders\"); } catch (Exception e) { conn.rollback(); throw e; } finally { stmt.close(); conn.close(); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long importCSV(final File file, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the CSV file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections from",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement (column order must match CSV column order)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading the file"
                }
              ],
              "javadoc_summary": "Imports data from a CSV file to the database using the specified DataSource.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long importCSV(final File file, final Connection conn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the CSV file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement (column order must match CSV column order)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to accumulate before executing a batch insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the pause duration in milliseconds between batch executions",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading the file"
                }
              ],
              "javadoc_summary": "Imports data from a CSV file to the database using the provided Connection with configurable batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long importCSV(final File file, final PreparedStatement stmt, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the CSV file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import (will not be closed)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading the file"
                }
              ],
              "javadoc_summary": "Imports data from a CSV file to the database using the provided PreparedStatement with default batch settings.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import with custom prepared statement configuration File csvFile = new File(\"transactions.csv\"); PreparedStatement stmt = conn.prepareStatement( \"INSERT INTO transactions (account_id, amount, type, date) VALUES (?, ?, ?, ?)\", Statement.RETURN_GENERATED_KEYS); long rowsImported = JdbcUtils.importCSV(csvFile, stmt, (query, row) -> { query.setLong(1, Long.parseLong(row[0])); query.setBigDecimal(2, new BigDecimal(row[1])); query.setString(3, row[2]); query.setDate(4, Date.valueOf(row[3])); }); // Can retrieve generated keys if needed ResultSet generatedKeys = stmt.getGeneratedKeys(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long importCSV(final File file, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the CSV file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import (will not be closed)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to accumulate before executing a batch insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the pause duration in milliseconds between batch executions",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading the file"
                }
              ],
              "javadoc_summary": "Imports data from a CSV file to the database using the provided PreparedStatement with configurable batch processing.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import large dataset with progress tracking File csvFile = new File(\"large_dataset.csv\"); PreparedStatement stmt = conn.prepareStatement( \"INSERT INTO records (id, data, timestamp) VALUES (?, ?, ?)\"); AtomicLong processedRows = new AtomicLong(0); long totalRows = JdbcUtils.importCSV(csvFile, stmt, 5000, 100, (query, row) -> { query.setLong(1, Long.parseLong(row[0])); query.setString(2, row[1]); query.setTimestamp(3, Timestamp.valueOf(row[2])); long processed = processedRows.incrementAndGet(); if (processed % 10000 == 0) { System.out.println(\"Processed \" + processed + \" rows...\"); } }); System.out.println(\"Import completed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importCSV(final File file, final Throwables.Predicate<? super String[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "file",
                  "type": "File",
                  "javadoc": "the CSV file containing the data to be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super String[], E>",
                  "javadoc": "a predicate to filter rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import (will not be closed)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to accumulate before executing a batch insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the pause duration in milliseconds between batch executions",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading the file"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a CSV file to the database with row filtering capability.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long importCSV(final Reader reader, final javax.sql.DataSource sourceDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the Reader to read the CSV data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections from",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL insert statement (column order must match CSV column order)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading from the reader"
                }
              ],
              "javadoc_summary": "Imports data from a CSV Reader to the database using the specified DataSource.",
              "contract": [
                "This method is useful when the CSV data comes from a source other than a file."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long importCSV(final Reader reader, final PreparedStatement stmt, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the Reader to read the CSV data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import (will not be closed)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading from the reader"
                }
              ],
              "javadoc_summary": "Imports data from a CSV Reader to the database using the provided PreparedStatement with default batch settings.",
              "contract": [
                "The Reader will be wrapped in a BufferedReader for optimal performance if not already buffered."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long importCSV(final Reader reader, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the Reader to read the CSV data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import (will not be closed)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to accumulate before executing a batch insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the pause duration in milliseconds between batch executions",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading from the reader"
                }
              ],
              "javadoc_summary": "Imports data from a CSV Reader to the database using the provided PreparedStatement with configurable batch processing.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "importCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static <E extends Exception> long importCSV(final Reader reader, final Throwables.Predicate<? super String[], E> filter, final PreparedStatement stmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException> stmtSetter) throws IllegalArgumentException, SQLException, IOException, E",
              "return_type": "long",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Exception"
                  ]
                }
              ],
              "params": [
                {
                  "name": "reader",
                  "type": "Reader",
                  "javadoc": "the Reader to read the CSV data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "filter",
                  "type": "Throwables.Predicate<? super String[], E>",
                  "javadoc": "a predicate to filter rows; only rows returning {@code true} will be imported",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to be used for the import (will not be closed)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to accumulate before executing a batch insert (must be greater than 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the pause duration in milliseconds between batch executions (must be >= 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super String[], SQLException>",
                  "javadoc": "a BiConsumer to set PreparedStatement parameters from CSV row values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if batchSize is not positive or batchIntervalInMillis is negative"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while reading from the reader"
                },
                {
                  "type": "E",
                  "condition": "if the filter throws an exception"
                }
              ],
              "javadoc_summary": "Imports data from a CSV Reader to the database with row filtering capability and configurable batch processing.",
              "contract": [
                "<p> This method combines all import features: </p> <ul> <li> Custom data source (Reader) </li> <li> Row filtering before import </li> <li> Configurable batch processing </li> <li> Custom value mapping </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Import CSV data with complex filtering and validation Reader reader = new FileReader(\"user_data.csv\"); PreparedStatement stmt = conn.prepareStatement( \"INSERT INTO users (id, email, age, country) VALUES (?, ?, ?, ?)\"); // Complex filter: valid email, age >= 18, allowed countries Set<String> allowedCountries = Set.of(\"US\", \"CA\", \"UK\", \"AU\"); Predicate<String[]> complexFilter = row -> { // Validate email format (simple check) if (!row[1].contains(\"@\")) return false; // Check age >= 18 try { if (Integer.parseInt(row[2]) < 18) return false; } catch (NumberFormatException e) { return false; } // Check allowed countries return allowedCountries.contains(row[3]); }; long rowsImported = JdbcUtils.importCSV(reader, complexFilter, stmt, 2000, 0, (query, row) -> { query.setLong(1, Long.parseLong(row[0])); query.setString(2, row[1].toLowerCase()); // normalize email query.setInt(3, Integer.parseInt(row[2])); query.setString(4, row[3]); }); System.out.println(\"Imported \" + rowsImported + \" valid users\"); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final javax.sql.DataSource sourceDataSource, final String querySql, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections from",
                  "nullability": "unspecified"
                },
                {
                  "name": "querySql",
                  "type": "String",
                  "javadoc": "the SQL query to execute for retrieving data",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File to write the CSV data to (will be created if doesn't exist)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Exports data from the database to a CSV file using the specified DataSource and SQL query.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final Connection conn, final String querySql, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "querySql",
                  "type": "String",
                  "javadoc": "the SQL query to execute for retrieving data",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File to write the CSV data to (will be created if doesn't exist)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Exports data from the database to a CSV file using the provided Connection and SQL query.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final Connection conn, final String querySql, final Collection<String> selectColumnNames, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "querySql",
                  "type": "String",
                  "javadoc": "the SQL query to execute for retrieving data",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "collection of column names to include in export (null for all columns)",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File to write the CSV data to (will be created if doesn't exist)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Exports selected columns from the database to a CSV file using the provided Connection and SQL query.",
              "contract": [
                "This method allows you to specify which columns from the query result should be included in the CSV.",
                "This is useful when you want to exclude sensitive or unnecessary columns from the export."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final PreparedStatement stmt, final File out) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to execute (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "out",
                  "type": "File",
                  "javadoc": "the File to write the CSV data to (will be created if doesn't exist)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Exports data from the database to a CSV file using the provided PreparedStatement.",
              "contract": [
                "<p> This method is useful when you need to set parameters on the statement before execution or when you want to reuse a prepared statement for multiple exports."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final PreparedStatement stmt, final Collection<String> selectColumnNames, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "stmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement to execute (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "collection of column names to include in export (null for all columns)",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File to write the CSV data to (will be created if doesn't exist)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Exports selected columns from the database to a CSV file using the provided PreparedStatement.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final ResultSet rs, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet containing the data to export (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File to write the CSV data to (will be created if doesn't exist)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Exports data from a ResultSet to a CSV file.",
              "contract": [
                "<p> This is the lowest-level export method, useful when you already have a ResultSet from a complex operation or need maximum control over the export process."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final ResultSet rs, final Collection<String> selectColumnNames, final File output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet containing the data to export (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "collection of column names to include in export (null for all columns)",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "File",
                  "javadoc": "the File to write the CSV data to (will be created if doesn't exist)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing to the file"
                }
              ],
              "javadoc_summary": "Exports selected columns from a ResultSet to a CSV file.",
              "contract": [
                "<p> Column names are case-sensitive and must match exactly with the column labels in the ResultSet.",
                "If a specified column is not found in the ResultSet, an IllegalArgumentException will be thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final javax.sql.DataSource sourceDataSource, final String querySql, final Writer output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the DataSource to obtain database connections from",
                  "nullability": "unspecified"
                },
                {
                  "name": "querySql",
                  "type": "String",
                  "javadoc": "the SQL query to execute for retrieving data",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "Writer",
                  "javadoc": "the Writer to write the CSV data to (will not be closed by this method)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing"
                }
              ],
              "javadoc_summary": "Exports data from the database to a CSV Writer using the specified DataSource and SQL query.",
              "contract": [
                "This method is useful when you need to write CSV data to a custom destination."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final Connection conn, final String querySql, final Writer output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "conn",
                  "type": "Connection",
                  "javadoc": "the Connection to the database (will not be closed by this method)",
                  "nullability": "unspecified"
                },
                {
                  "name": "querySql",
                  "type": "String",
                  "javadoc": "the SQL query to execute for retrieving data",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "Writer",
                  "javadoc": "the Writer to write the CSV data to (will not be closed by this method)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs while writing"
                }
              ],
              "javadoc_summary": "Exports data from the database to a CSV Writer using the provided Connection and SQL query.",
              "contract": [
                "The Writer should be flushed after this method returns to ensure all data is written."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final ResultSet rs, final Writer output) throws SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet containing the data to be exported",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "Writer",
                  "javadoc": "the Writer to write the CSV data to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                }
              ],
              "javadoc_summary": "Exports data from a ResultSet to a CSV Writer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exportCSV",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long exportCSV(final ResultSet rs, final Collection<String> selectColumnNames, final Writer output) throws IllegalArgumentException, SQLException, IOException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "rs",
                  "type": "ResultSet",
                  "javadoc": "the ResultSet containing the data to be exported",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be selected for export; if {@code null} , all columns are exported",
                  "nullability": "unspecified"
                },
                {
                  "name": "output",
                  "type": "Writer",
                  "javadoc": "the Writer to write the CSV data to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if any specified column name is not found in the ResultSet"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.io.IOException",
                  "condition": "if an I/O error occurs"
                }
              ],
              "javadoc_summary": "Exports data from a ResultSet to a CSV file with column selection.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String tableName) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "the name of the table to copy",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the table doesn't exist"
                }
              ],
              "javadoc_summary": "Copies all data from a table in the source data source to a table with the same name in the target data source.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the target data source",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or either table doesn't exist"
                }
              ],
              "javadoc_summary": "Copies all data from a table in the source data source to a table in the target data source.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName, final int batchSize) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the target data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to copy in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies all data from a table in the source data source to a table in the target data source with a specified batch size for performance tuning.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the target data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to copy",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or any specified column doesn't exist"
                }
              ],
              "javadoc_summary": "Copies specified columns from a table in the source data source to a table in the target data source.",
              "contract": [
                "<p> This method is useful when you need to copy only a subset of columns or when the target table has a different structure than the source table."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final javax.sql.DataSource targetDataSource, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames, final int batchSize) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the table in the target data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to copy",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to copy in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies specified columns from a table in the source data source to a table in the target data source with a custom batch size for performance tuning.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final javax.sql.DataSource targetDataSource, final String insertSql) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target data source (must have matching parameter placeholders)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or SQL statements are invalid"
                }
              ],
              "javadoc_summary": "Copies data from a source data source to a target data source using custom SQL queries.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final int fetchSize, final javax.sql.DataSource targetDataSource, final String insertSql, final int batchSize) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "fetchSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch at a time (should be larger than batchSize)",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to copy in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data from a source data source to a target data source using custom SQL queries with specified fetch and batch sizes for performance optimization.",
              "contract": [
                "For optimal performance, fetch size should be larger than batch size."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final javax.sql.DataSource targetDataSource, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>",
                  "javadoc": "a bi-consumer to set parameters on the prepared statement from the result set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data from a source data source to a target data source using custom SQL queries and a custom statement setter for parameter mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final javax.sql.DataSource sourceDataSource, final String selectSql, final int fetchSize, final javax.sql.DataSource targetDataSource, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source from which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "fetchSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch at a time (should be larger than batchSize)",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetDataSource",
                  "type": "javax.sql.DataSource",
                  "javadoc": "the data source to which to copy data",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target data source",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to copy in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch (0 for no delay)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>",
                  "javadoc": "a bi-consumer to set parameters on the prepared statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data from a source data source to a target data source with full control over all aspects of the copy operation including SQL queries, performance settings, and parameter mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final Connection targetConn, final String tableName) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "the name of the table to copy data from and to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies all data from a table with the same name between two database connections.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the source table to copy data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the target table to copy data to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies all data from a source table to a target table using the specified connections.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName, final int batchSize) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the source table to copy data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the target table to copy data to",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to copy in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies all data from a source table to a target table using the specified connections with a custom batch size for performance tuning.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the source table to copy data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the target table to copy data to",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be copied",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or any specified column doesn't exist"
                }
              ],
              "javadoc_summary": "Copies specified columns from a source table to a target table using the provided connections.",
              "contract": [
                "<p> This method is useful when copying a subset of columns or when the target table has a different structure than the source table."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final Connection targetConn, final String sourceTableName, final String targetTableName, final Collection<String> selectColumnNames, final int batchSize) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "sourceTableName",
                  "type": "String",
                  "javadoc": "the name of the source table to copy data from",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetTableName",
                  "type": "String",
                  "javadoc": "the name of the target table to copy data to",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectColumnNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of column names to be copied",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be copied in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies specified columns from a source table to a target table using the provided connections with a custom batch size for performance optimization.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final String selectSql, final Connection targetConn, final String insertSql) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target database",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data between databases using custom SQL queries and existing connections.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final String selectSql, final int fetchSize, final Connection targetConn, final String insertSql, final int batchSize) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "fetchSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch at a time from the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be copied in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data between databases using custom SQL queries with specified fetch and batch sizes.",
              "contract": [
                "For optimal performance, fetch size should be larger than batch size."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final String selectSql, final Connection targetConn, final String insertSql, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>",
                  "javadoc": "the custom statement setter to set the parameters of the prepared statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data between databases using custom SQL queries and a custom statement setter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final Connection sourceConn, final String selectSql, final int fetchSize, final Connection targetConn, final String insertSql, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "sourceConn",
                  "type": "Connection",
                  "javadoc": "the connection to the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectSql",
                  "type": "String",
                  "javadoc": "the SQL query to select data from the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "fetchSize",
                  "type": "int",
                  "javadoc": "the number of rows to fetch at a time from the source database",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetConn",
                  "type": "Connection",
                  "javadoc": "the connection to the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertSql",
                  "type": "String",
                  "javadoc": "the SQL query to insert data into the target database",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to be copied in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch (0 for no delay)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>",
                  "javadoc": "the custom statement setter to set the parameters of the prepared statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data between databases with full control over all aspects of the operation.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "copy",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static long copy(final PreparedStatement selectStmt, final PreparedStatement insertStmt, final int batchSize, final long batchIntervalInMillis, final Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException> stmtSetter) throws SQLException",
              "return_type": "long",
              "type_params": [],
              "params": [
                {
                  "name": "selectStmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement used to select data from the source",
                  "nullability": "unspecified"
                },
                {
                  "name": "insertStmt",
                  "type": "PreparedStatement",
                  "javadoc": "the PreparedStatement used to insert data into the target",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of rows to process in each batch (must be greater than 0)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchIntervalInMillis",
                  "type": "long",
                  "javadoc": "the interval in milliseconds between each batch (0 for no delay)",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtSetter",
                  "type": "Throwables.BiConsumer<? super PreparedQuery, ? super ResultSet, SQLException>",
                  "javadoc": "a BiConsumer that sets the parameters for the PreparedStatement from the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Copies data from a source PreparedStatement to a target PreparedStatement with full control over batch processing and parameter mapping.",
              "contract": [
                "<p> This low-level method provides direct control over prepared statements and is useful when you need to reuse statements or have complex statement preparation requirements."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "createParamSetter",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Beta @SequentialOnly @Stateful public static Throwables.BiConsumer<PreparedQuery, ResultSet, SQLException> createParamSetter(final ColumnGetter<?> columnGetterForAll)",
              "return_type": "Throwables.BiConsumer<PreparedQuery, ResultSet, SQLException>",
              "type_params": [],
              "params": [
                {
                  "name": "columnGetterForAll",
                  "type": "ColumnGetter<?>",
                  "javadoc": "the ColumnGetter to use for extracting values from all columns",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Creates a parameter setter for a PreparedQuery using the provided ColumnGetter.",
              "contract": [
                "This is particularly useful when you need custom value extraction logic across all columns.",
                "It should not be reused across different ResultSets with different column counts or used in parallel operations."
              ],
              "examples": [],
              "see_also": [
                "#copy(Connection, String, Connection, String, Throwables.BiConsumer)"
              ]
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.JoinInfo",
          "name": "JoinInfo",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "Manages join relationships between entities in JDBC operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "getSelectSQLBuilderAndParamSetter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Tuple2<Function<Collection<String>, String>, Jdbc.BiParametersSetter<PreparedStatement, Object>> getSelectSQLBuilderAndParamSetter( final Class<? extends SQLBuilder> sbc)",
              "return_type": "Tuple2<Function<Collection<String>, String>, Jdbc.BiParametersSetter<PreparedStatement, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "sbc",
                  "type": "Class<? extends SQLBuilder>",
                  "javadoc": "the SQL builder class type (PSC, PAC, or PLC)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves the SQL builder and parameter setter for single entity select operations.",
              "contract": [],
              "examples": [],
              "see_also": [
                "SQLBuilder.PSC",
                "SQLBuilder.PAC",
                "SQLBuilder.PLC"
              ]
            },
            {
              "name": "getBatchSelectSQLBuilderAndParamSetter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Tuple2<BiFunction<Collection<String>, Integer, String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>> getBatchSelectSQLBuilderAndParamSetter( //NOSONAR final Class<? extends SQLBuilder> sbc)",
              "return_type": "Tuple2<BiFunction<Collection<String>, Integer, String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>>",
              "type_params": [],
              "params": [
                {
                  "name": "sbc",
                  "type": "Class<? extends SQLBuilder>",
                  "javadoc": "the SQL builder class type (PSC, PAC, or PLC)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves the SQL builder and parameter setter for batch select operations.",
              "contract": [],
              "examples": [],
              "see_also": [
                "SQLBuilder.PSC",
                "SQLBuilder.PAC",
                "SQLBuilder.PLC"
              ]
            },
            {
              "name": "getDeleteSqlAndParamSetter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Tuple3<String, String, Jdbc.BiParametersSetter<PreparedStatement, Object>> getDeleteSqlAndParamSetter(final Class<? extends SQLBuilder> sbc)",
              "return_type": "Tuple3<String, String, Jdbc.BiParametersSetter<PreparedStatement, Object>>",
              "type_params": [],
              "params": [
                {
                  "name": "sbc",
                  "type": "Class<? extends SQLBuilder>",
                  "javadoc": "the SQL builder class type (PSC, PAC, or PLC)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves the SQL and parameter setter for delete operations.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code JoinInfo joinInfo = JoinInfo.getPropJoinInfo(EmployeeDao.class, Employee.class, \"employees\", \"projects\"); Tuple3<String, String, Jdbc.BiParametersSetter<PreparedStatement, Object>> deleteSql = joinInfo.getDeleteSqlAndParamSetter(PSC.class); String deleteSql = deleteSql._1; // Main delete SQL String middleTableDeleteSql = deleteSql._2; // Join table delete SQL (if many-to-many) Jdbc.BiParametersSetter<PreparedStatement, Object> paramSetter = deleteSql._3; } </pre>"
              ],
              "examples": [],
              "see_also": [
                "SQLBuilder.PSC",
                "SQLBuilder.PAC",
                "SQLBuilder.PLC"
              ]
            },
            {
              "name": "getBatchDeleteSQLBuilderAndParamSetter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Tuple3<IntFunction<String>, IntFunction<String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>> getBatchDeleteSQLBuilderAndParamSetter( //NOSONAR final Class<? extends SQLBuilder> sbc)",
              "return_type": "Tuple3<IntFunction<String>, IntFunction<String>, Jdbc.BiParametersSetter<PreparedStatement, Collection<?>>>",
              "type_params": [],
              "params": [
                {
                  "name": "sbc",
                  "type": "Class<? extends SQLBuilder>",
                  "javadoc": "the SQL builder class type (PSC, PAC, or PLC)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves the SQL builder and parameter setter for batch delete operations.",
              "contract": [],
              "examples": [],
              "see_also": [
                "SQLBuilder.PSC",
                "SQLBuilder.PAC",
                "SQLBuilder.PLC"
              ]
            },
            {
              "name": "setJoinPropEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void setJoinPropEntities(final Collection<?> entities, final Collection<?> joinPropEntities)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<?>",
                  "javadoc": "the source entities to populate with joined entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinPropEntities",
                  "type": "Collection<?>",
                  "javadoc": "the joined entities to be set on the source entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Sets join property entities for a collection of source entities.",
              "contract": [
                "If the join property is declared as a {@code List} and the grouped value is already a {@code List} , the list is assigned directly; otherwise a new collection of the declared type is created and populated."
              ],
              "examples": [],
              "see_also": [
                "#setJoinPropEntities(Collection, Map)"
              ]
            },
            {
              "name": "setJoinPropEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public void setJoinPropEntities(final Collection<?> entities, final Map<Object, List<Object>> groupedPropEntities)",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<?>",
                  "javadoc": "the source entities to populate with joined entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "groupedPropEntities",
                  "type": "Map<Object, List<Object>>",
                  "javadoc": "a map of grouped entities keyed by their join keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Sets join property entities for a collection of source entities using pre-grouped entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isManyToManyJoin",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public boolean isManyToManyJoin()",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Checks if this join relationship is a many-to-many join.",
              "contract": [
                "Checks if this join relationship is a many-to-many join.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code JoinInfo joinInfo = JoinInfo.getPropJoinInfo(EmployeeDao.class, Employee.class, \"employees\", \"projects\"); if (joinInfo.isManyToManyJoin()) { // Handle many-to-many relationship with join table System.out.println(\"This is a many-to-many relationship\"); } else { // Handle one-to-many or one-to-one relationship System.out.println(\"This is a direct relationship\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "getEntityJoinInfo",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static Map<String, JoinInfo> getEntityJoinInfo(final Class<?> daoClass, final Class<?> entityClass, final String tableName)",
              "return_type": "Map<String, JoinInfo>",
              "type_params": [],
              "params": [
                {
                  "name": "daoClass",
                  "type": "Class<?>",
                  "javadoc": "the DAO class associated with the entity, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to inspect for join properties, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "the database table name for the entity, must not be {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves all join information for the specified entity class.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get all join info for Employee entity Map<String, JoinInfo> joinInfoMap = JoinInfo.getEntityJoinInfo( EmployeeDao.class, Employee.class, \"employees\" ); // Iterate through all join properties for (Map.Entry<String, JoinInfo> entry : joinInfoMap.entrySet()) { String propName = entry.getKey(); JoinInfo joinInfo = entry.getValue(); System.out.println(\"Join property: \" + propName); if (joinInfo.isManyToManyJoin()) { System.out.println(\" - Many-to-many relationship\"); } else { System.out.println(\" - One-to-many relationship\"); } } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "JoinedBy",
                "DaoConfig"
              ]
            },
            {
              "name": "getPropJoinInfo",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static JoinInfo getPropJoinInfo(final Class<?> daoClass, final Class<?> entityClass, final String tableName, final String joinEntityPropName)",
              "return_type": "JoinInfo",
              "type_params": [],
              "params": [
                {
                  "name": "daoClass",
                  "type": "Class<?>",
                  "javadoc": "the DAO class associated with the entity, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class containing the join property, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "the database table name for the entity, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the name of the property with the {@code @JoinedBy} annotation, must not be {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves join information for a specific property in an entity.",
              "contract": [],
              "examples": [],
              "see_also": [
                "JoinedBy",
                "#getEntityJoinInfo(Class, Class, String)"
              ]
            },
            {
              "name": "getJoinEntityPropNamesByType",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "public static List<String> getJoinEntityPropNamesByType(final Class<?> daoClass, final Class<?> entityClass, final String tableName, final Class<?> joinPropEntityClass)",
              "return_type": "List<String>",
              "type_params": [],
              "params": [
                {
                  "name": "daoClass",
                  "type": "Class<?>",
                  "javadoc": "the DAO class associated with the entity, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityClass",
                  "type": "Class<?>",
                  "javadoc": "the entity class to search for join properties, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "tableName",
                  "type": "String",
                  "javadoc": "the database table name for the entity, must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinPropEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the joined entity to search for, must not be {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Retrieves all property names in an entity that join to a specific entity type.",
              "contract": [
                "<p> This is useful when you need to discover all relationships between two entity types, especially when there might be multiple join properties pointing to the same entity class.",
                "use joinInfo } // Check if entity has any joins to a specific type if (!projectJoinProps.isEmpty()) { System.out.println(\"Employee has \" + projectJoinProps.size() + \" relationship(s) with Project\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "JoinedBy",
                "#getEntityJoinInfo(Class, Class, String)"
              ]
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.NamedQuery",
          "name": "NamedQuery",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "A JDBC wrapper class that provides named parameter support for SQL queries, similar to Spring's NamedParameterJdbcTemplate.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "setNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNull(final String parameterName, final int sqlType) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set to NULL (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to SQL NULL.",
              "contract": [
                "If the parameter appears multiple times in the query, all occurrences will be set to NULL."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNull(final String parameterName, final int sqlType, final String typeName) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set to NULL (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type code defined in {@link java.sql.Types}",
                  "nullability": "unspecified"
                },
                {
                  "name": "typeName",
                  "type": "String",
                  "javadoc": "the SQL type name (for SQL user-defined or REF types)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to SQL NULL with a specified SQL type and type name.",
              "contract": [],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBoolean(final String parameterName, final boolean x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "boolean",
                  "javadoc": "the boolean value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a boolean value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBoolean(final String parameterName, final Boolean x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Boolean",
                  "javadoc": "the Boolean value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Boolean value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setByte(final String parameterName, final byte x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "byte",
                  "javadoc": "the byte value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a byte value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setByte(final String parameterName, final Byte x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Byte",
                  "javadoc": "the Byte value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Byte value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setShort(final String parameterName, final short x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "short",
                  "javadoc": "the short value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a short value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setShort(final String parameterName, final Short x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Short",
                  "javadoc": "the Short value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Short value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setInt(final String parameterName, final int x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "int",
                  "javadoc": "the int value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an int value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setInt(final String parameterName, final Integer x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Integer",
                  "javadoc": "the Integer value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an Integer value.",
              "contract": [
                "<p> This method handles {@code null} values by setting the parameter to SQL NULL if the provided value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public NamedQuery setInt(final String parameterName, final char x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "char",
                  "javadoc": "the char value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "generally {@code char} should be saved as {@code String} in db. Use {@link #setString(String, char)} instead.",
                "for_removal": false
              },
              "javadoc_summary": "Sets the specified named parameter to a char value by converting it to an int.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#setString(String, char)"
              ]
            },
            {
              "name": "setInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public NamedQuery setInt(final String parameterName, final Character x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Character",
                  "javadoc": "the Character value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "generally {@code char} should be saved as {@code String} in db. Use {@link #setString(String, Character)} instead.",
                "for_removal": false
              },
              "javadoc_summary": "Sets the specified named parameter to a Character value by converting it to an int.",
              "contract": [
                "<p> This method handles {@code null} values by setting the parameter to SQL NULL if the provided value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "#setString(String, Character)"
              ]
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setLong(final String parameterName, final long x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "long",
                  "javadoc": "the long value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a long value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setLong(final String parameterName, final Long x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Long",
                  "javadoc": "the Long value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Long value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setLong(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BigInteger value by converting it to a long.",
              "contract": [
                "If the BigInteger value is too large to fit in a long, an ArithmeticException will be thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setFloat(final String parameterName, final float x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "float",
                  "javadoc": "the float value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a float value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setFloat(final String parameterName, final Float x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Float",
                  "javadoc": "the Float value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Float value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setDouble(final String parameterName, final double x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "double",
                  "javadoc": "the double value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a double value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setDouble(final String parameterName, final Double x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Double",
                  "javadoc": "the Double value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Double value.",
              "contract": [
                "If the value is {@code null} , the parameter will be set to SQL NULL."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBigDecimal(final String parameterName, final BigDecimal x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigDecimal",
                  "javadoc": "the BigDecimal value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BigDecimal value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigDecimal",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBigDecimal(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BigInteger value by converting it to BigDecimal.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBigIntegerAsString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta public NamedQuery setBigIntegerAsString(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BigInteger value by converting it to String.",
              "contract": [
                "This is useful when the numeric value exceeds the range of standard numeric types."
              ],
              "examples": [],
              "see_also": [
                "#setString(String, BigInteger)",
                "#setBigDecimal(String, BigInteger)",
                "#setLong(String, BigInteger)"
              ]
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setString(final String parameterName, final String x) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "String",
                  "javadoc": "the String value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a String value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setString(final String parameterName, final CharSequence x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "CharSequence",
                  "javadoc": "the CharSequence value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a CharSequence value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setString(final String parameterName, final char x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "char",
                  "javadoc": "the char value to set",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a single character value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setString(final String parameterName, final Character x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Character",
                  "javadoc": "the Character value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a Character value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setString(final String parameterName, final BigInteger x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "BigInteger",
                  "javadoc": "the BigInteger value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BigInteger value as a String.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNString(final String parameterName, final String x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "String",
                  "javadoc": "the String value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a national character string value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNString(final String parameterName, final CharSequence x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "CharSequence",
                  "javadoc": "the CharSequence value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a national character string value from a CharSequence.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setDate(final String parameterName, final java.sql.Date x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Date",
                  "javadoc": "the java.sql.Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Date value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setDate(final String parameterName, final java.util.Date x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the java.util.Date value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.util.Date value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setDate(final String parameterName, final LocalDate x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalDate",
                  "javadoc": "the LocalDate value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a LocalDate value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTime(final String parameterName, final java.sql.Time x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Time",
                  "javadoc": "the java.sql.Time value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Time value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTime(final String parameterName, final java.util.Date x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the java.util.Date value containing the time to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a time value using a java.util.Date.",
              "contract": [
                "If the provided Date is already a java.sql.Time instance, it is used directly without conversion."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTime(final String parameterName, final LocalTime x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalTime",
                  "javadoc": "the LocalTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a time value using a LocalTime.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTimestamp(final String parameterName, final java.sql.Timestamp x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Timestamp",
                  "javadoc": "the java.sql.Timestamp value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Timestamp value.",
              "contract": [
                "Timestamps are typically used for recording when events occur in the database."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTimestamp(final String parameterName, final java.util.Date x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.util.Date",
                  "javadoc": "the java.util.Date value to convert and set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a timestamp value using a java.util.Date.",
              "contract": [
                "If the provided Date is already a java.sql.Timestamp instance, it is used directly without conversion."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTimestamp(final String parameterName, final LocalDateTime x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "LocalDateTime",
                  "javadoc": "the LocalDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a timestamp value using a LocalDateTime.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTimestamp(final String parameterName, final ZonedDateTime x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "ZonedDateTime",
                  "javadoc": "the ZonedDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a timestamp value using a ZonedDateTime.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTimestamp(final String parameterName, final OffsetDateTime x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "OffsetDateTime",
                  "javadoc": "the OffsetDateTime value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a timestamp value using an OffsetDateTime.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setTimestamp(final String parameterName, final Instant x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Instant",
                  "javadoc": "the Instant value to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a timestamp value using an Instant.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBytes(final String parameterName, final byte[] x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "byte[]",
                  "javadoc": "the byte array to set, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a byte array value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setAsciiStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setAsciiStream(final String parameterName, final InputStream x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "InputStream",
                  "javadoc": "the InputStream containing ASCII data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an ASCII stream value.",
              "contract": [
                "The stream should contain only ASCII characters.",
                "Note that the stream will be read when the query is executed, not when this method is called."
              ],
              "examples": [],
              "see_also": [
                "#setAsciiStream(String, InputStream, long)"
              ]
            },
            {
              "name": "setAsciiStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setAsciiStream(final String parameterName, final InputStream x, final long length) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "InputStream",
                  "javadoc": "the InputStream containing ASCII data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to an ASCII stream value with a specified length.",
              "contract": [
                "<p> This method is used to set very large ASCII values when the length is known."
              ],
              "examples": [],
              "see_also": [
                "#setAsciiStream(String, InputStream)"
              ]
            },
            {
              "name": "setBinaryStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBinaryStream(final String parameterName, final InputStream x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "InputStream",
                  "javadoc": "the InputStream containing binary data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a binary stream value.",
              "contract": [
                "The stream will be read when the query is executed, not when this method is called."
              ],
              "examples": [],
              "see_also": [
                "#setBinaryStream(String, InputStream, long)"
              ]
            },
            {
              "name": "setBinaryStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBinaryStream(final String parameterName, final InputStream x, final long length) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "InputStream",
                  "javadoc": "the InputStream containing binary data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a binary stream value with a specified length.",
              "contract": [
                "<p> This method is used to set very large binary values when the length is known."
              ],
              "examples": [],
              "see_also": [
                "#setBinaryStream(String, InputStream)"
              ]
            },
            {
              "name": "setCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setCharacterStream(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader containing character data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a character stream value.",
              "contract": [
                "The Reader should contain Unicode character data."
              ],
              "examples": [],
              "see_also": [
                "#setCharacterStream(String, Reader, long)"
              ]
            },
            {
              "name": "setCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setCharacterStream(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader containing character data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a character stream value with a specified length.",
              "contract": [
                "<p> This method is used to set very large character values when the length is known."
              ],
              "examples": [],
              "see_also": [
                "#setCharacterStream(String, Reader)"
              ]
            },
            {
              "name": "setNCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNCharacterStream(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader containing national character data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a national character stream value.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#setNCharacterStream(String, Reader, long)"
              ]
            },
            {
              "name": "setNCharacterStream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNCharacterStream(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader containing national character data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a national character stream value with a specified length.",
              "contract": [
                "<p> This method is used to set very large NCHAR, NVARCHAR, or NCLOB values when the length is known."
              ],
              "examples": [],
              "see_also": [
                "#setNCharacterStream(String, Reader)"
              ]
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBlob(final String parameterName, final java.sql.Blob x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Blob",
                  "javadoc": "the java.sql.Blob object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Blob value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBlob(final String parameterName, final InputStream x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "InputStream",
                  "javadoc": "the InputStream containing the BLOB data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BLOB value using an InputStream.",
              "contract": [
                "This is convenient when you have binary data in a stream format."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setBlob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setBlob(final String parameterName, final InputStream x, final long length) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "InputStream",
                  "javadoc": "the InputStream containing the BLOB data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of bytes to read from the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a BLOB value using an InputStream with a specified length.",
              "contract": [
                "This is more efficient when the size is known and ensures exactly the specified amount of data is read."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setClob(final String parameterName, final java.sql.Clob x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter to be set (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Clob",
                  "javadoc": "the java.sql.Clob object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the SQL query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets the specified named parameter to a java.sql.Clob value.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setClob(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader object containing the CLOB data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets a CLOB (Character Large Object) parameter using a Reader for the specified parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setClob(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader object containing the CLOB data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, this method is called on a closed PreparedStatement, or the length is less than zero"
                }
              ],
              "javadoc_summary": "Sets a CLOB (Character Large Object) parameter using a Reader with a specified length for the parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNClob(final String parameterName, final java.sql.NClob x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.NClob",
                  "javadoc": "the NClob object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets an NCLOB (National Character Large Object) parameter for the specified parameter name.",
              "contract": [
                "<p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNClob(final String parameterName, final Reader x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader object containing the NCLOB data, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets an NCLOB (National Character Large Object) parameter using a Reader for the specified parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setNClob",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setNClob(final String parameterName, final Reader x, final long length) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Reader",
                  "javadoc": "the Reader object containing the NCLOB data",
                  "nullability": "unspecified"
                },
                {
                  "name": "length",
                  "type": "long",
                  "javadoc": "the number of characters in the stream",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, this method is called on a closed PreparedStatement, or the length is less than zero"
                }
              ],
              "javadoc_summary": "Sets an NCLOB (National Character Large Object) parameter using a Reader with a specified length.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setURL",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setURL(final String parameterName, final URL x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "URL",
                  "javadoc": "the URL object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets a URL parameter for the specified parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setSQLXML",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setSQLXML(final String parameterName, final java.sql.SQLXML x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.SQLXML",
                  "javadoc": "the SQLXML object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets an SQL XML parameter for the specified parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setRowId",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setRowId(final String parameterName, final java.sql.RowId x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.RowId",
                  "javadoc": "the RowId object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets a RowId parameter for the specified parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setRef",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setRef(final String parameterName, final java.sql.Ref x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Ref",
                  "javadoc": "the Ref object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets a Ref (SQL REF) parameter for the specified parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setArray",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setArray(final String parameterName, final java.sql.Array x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "java.sql.Array",
                  "javadoc": "the Array object, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets an Array parameter for the specified parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setObject(final String parameterName, final Object x) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the parameter value, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, this method is called on a closed PreparedStatement, or the given object cannot be converted to a SQL type"
                }
              ],
              "javadoc_summary": "Sets an Object parameter for the specified parameter name, using the default SQL type mapping.",
              "contract": [
                "Common mappings include: <ul> <li> String \\u2192 VARCHAR/CHAR </li> <li> Integer/Long \\u2192 INTEGER/BIGINT </li> <li> BigDecimal \\u2192 NUMERIC/DECIMAL </li> <li> Date/Timestamp \\u2192 DATE/TIMESTAMP </li> <li> Boolean \\u2192 BOOLEAN/BIT </li> <li> byte[] \\u2192 BINARY/VARBINARY </li> </ul> <p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setObject(final String parameterName, final Object x, final int sqlType) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the parameter value, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type (from java.sql.Types) to be used",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type"
                }
              ],
              "javadoc_summary": "Sets an Object parameter with a specified SQL type for the parameter name.",
              "contract": [
                "<p> This method allows explicit control over the SQL type used when setting the parameter value.",
                "Use this when the default type mapping is not sufficient or when you need to ensure a specific SQL type.",
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setObject(final String parameterName, final Object x, final int sqlType, final int scaleOrLength) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the parameter value",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "int",
                  "javadoc": "the SQL type (from java.sql.Types) to be used",
                  "nullability": "unspecified"
                },
                {
                  "name": "scaleOrLength",
                  "type": "int",
                  "javadoc": "for numeric types, the number of digits after the decimal point; for character/binary types, the length",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type"
                }
              ],
              "javadoc_summary": "Sets an Object parameter with a specified SQL type and scale/length for the parameter name.",
              "contract": [
                "<p> This method provides the most control over parameter setting, allowing specification of both SQL type and additional type-specific information: <ul> <li> For numeric types (DECIMAL, NUMERIC): scaleOrLength represents the number of digits after the decimal point </li> <li> For character types (CHAR, VARCHAR): scaleOrLength represents the length of the string </li> <li> For binary types (BINARY, VARBINARY): scaleOrLength represents the length in bytes </li> </ul> <p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": [
                "java.sql.Types"
              ]
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setObject(final String parameterName, final Object x, final SQLType sqlType) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the parameter value, or {@code null} to set SQL NULL",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQLType to be used",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type"
                }
              ],
              "javadoc_summary": "Sets an Object parameter with a specified SQLType for the parameter name.",
              "contract": [
                "If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setObject(final String parameterName, final Object x, final SQLType sqlType, final int scaleOrLength) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "Object",
                  "javadoc": "the object containing the parameter value",
                  "nullability": "unspecified"
                },
                {
                  "name": "sqlType",
                  "type": "SQLType",
                  "javadoc": "the SQLType to be used",
                  "nullability": "unspecified"
                },
                {
                  "name": "scaleOrLength",
                  "type": "int",
                  "javadoc": "for numeric types, the number of digits after the decimal point; for character/binary types, the length",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs, this method is called on a closed PreparedStatement, or the object cannot be converted to the specified SQL type"
                }
              ],
              "javadoc_summary": "Sets an Object parameter with a specified SQLType and scale/length for the parameter name.",
              "contract": [
                "<p> This method provides the most control when using JDBC 4.2 SQLType, allowing specification of both SQL type and additional type-specific information.",
                "<p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setObject",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> NamedQuery setObject(final String parameterName, final T x, final Type<T> type) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameterName",
                  "type": "String",
                  "javadoc": "the name of the parameter (without the ':' prefix)",
                  "nullability": "unspecified"
                },
                {
                  "name": "x",
                  "type": "T",
                  "javadoc": "the object containing the parameter value",
                  "nullability": "unspecified"
                },
                {
                  "name": "type",
                  "type": "Type<T>",
                  "javadoc": "the Type handler to use for setting the parameter",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Sets an Object parameter using a custom Type handler for the parameter name.",
              "contract": [
                "This is particularly useful for complex type mappings or when working with custom data types.",
                "<p> If the parameter name appears multiple times in the query, all occurrences will be set to the same value."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setParameters(final Map<String, ?> parameters) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameters",
                  "type": "Map<String, ?>",
                  "javadoc": "a map containing parameter names (without ':' prefix) as keys and their values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if the parameters map is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets multiple parameters from a Map containing parameter names and their values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") public NamedQuery setParameters(final Object parameters) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "parameters",
                  "type": "Object",
                  "javadoc": "an object containing the parameters (bean, map, collection, array, or single value)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parameters is {@code null} or of an unsupported type"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets parameters from various types of objects including beans, maps, collections, arrays, or single values.",
              "contract": [
                "<p> This flexible method accepts different parameter sources: <ul> <li> <b> Bean/Entity objects </b> : Properties matching parameter names will be used </li> <li> <b> Map </b> : Entries with keys matching parameter names will be used </li> <li> <b> Collection/Array </b> : Elements will be assigned to parameters in positional order </li> <li> <b> EntityId </b> : Values with keys matching parameter names will be used </li> <li> <b> Single value </b> : Used only if the query has exactly one parameter </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Using a bean User user = new User(\"John\", 30, \"john@example.com\"); query.setParameters(user); // Using a Map Map<String, Object> params = Map.of(\"name\", \"John\", \"age\", 30); query.setParameters(params); // Using an array (parameters set by position) query.setParameters(new Object[] {\"John\", 30, \"john@example.com\"}); // Using a single value (for queries with one parameter) query.setParameters(\"John\"); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "JdbcUtil#getNamedParameters(String)"
              ]
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public NamedQuery setParameters(final Object entity, final Collection<String> parameterNames) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "Object",
                  "javadoc": "the entity object containing the parameter values",
                  "nullability": "unspecified"
                },
                {
                  "name": "parameterNames",
                  "type": "Collection<String>",
                  "javadoc": "a collection of parameter names to be set from the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if entity or parameterNames is {@code null} , if entity is not a bean class, if a property is not found in the entity, or if a parameter name is not found in the query"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets specific parameters from an entity object using only the specified parameter names.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Beans#getPropNameList(Class)",
                "Beans#getPropNames(Class, Collection)",
                "JdbcUtil#getNamedParameters(String)"
              ]
            },
            {
              "name": "setParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <T> NamedQuery setParameters(final T parameters, final Jdbc.TriParametersSetter<? super NamedQuery, ? super T> parametersSetter) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [
                {
                  "name": "T",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "parameters",
                  "type": "T",
                  "javadoc": "the parameters object to pass to the setter",
                  "nullability": "unspecified"
                },
                {
                  "name": "parametersSetter",
                  "type": "Jdbc.TriParametersSetter<? super NamedQuery, ? super T>",
                  "javadoc": "a function that sets parameters on the query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if parametersSetter is null"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Sets parameters using a custom parameter setter function.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code UserSearchCriteria criteria = new UserSearchCriteria(); criteria.setMinAge(25); criteria.setMaxAge(35); criteria.setActive(true); query.setParameters(criteria, (sql, q, c) -> { q.setInt(\"min_age\", c.getMinAge()); q.setInt(\"max_age\", c.getMaxAge()); if (c.isActive() != null) { q.setBoolean(\"is_active\", c.isActive()); } }); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public NamedQuery addBatchParameters(final Collection<?> batchParameters) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Collection<?>",
                  "javadoc": "a collection of parameter objects for batch processing",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if batchParameters is {@code null} or contains invalid parameter objects"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Adds a collection of parameter sets for batch execution.",
              "contract": [
                "Each element in the collection should be a parameter object compatible with {@link #setParameters(Object)} , such as: <ul> <li> Bean objects with properties matching parameter names </li> <li> Maps with keys matching parameter names </li> <li> Arrays or Collections for positional parameters </li> </ul> <p> After adding batch parameters, call {@code executeBatch()} to execute the batch."
              ],
              "examples": [],
              "see_also": [
                "#setParameters(Object)",
                "#addBatch()"
              ]
            },
            {
              "name": "addBatchParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @Override @SuppressWarnings(\"rawtypes\") public NamedQuery addBatchParameters(final Iterator<?> batchParameters) throws IllegalArgumentException, SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "batchParameters",
                  "type": "Iterator<?>",
                  "javadoc": "an iterator providing parameter objects for batch processing",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if batchParameters is {@code null} or contains invalid parameter objects"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or this method is called on a closed PreparedStatement"
                }
              ],
              "javadoc_summary": "Adds a batch of parameters from an iterator for batch execution.",
              "contract": [
                "Each element provided by the iterator should be a parameter object compatible with {@link #setParameters(Object)} , such as: <ul> <li> Bean objects with properties matching parameter names </li> <li> Maps with keys matching parameter names </li> <li> Arrays or Collections for positional parameters </li> </ul> <p> After adding batch parameters, call {@code executeBatch()} to execute the batch."
              ],
              "examples": [],
              "see_also": [
                "#setParameters(Object)",
                "#addBatchParameters(Collection)",
                "#addBatch()"
              ]
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.OP",
          "name": "OP",
          "kind": "enum",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enum representing various database operations that can be performed through AbstractQuery.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": [
            {
              "name": "exists",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Checks whether any records exist that match the query criteria."
            },
            {
              "name": "findOnlyOne",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves exactly one record from the query results."
            },
            {
              "name": "findFirst",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves the first record from the query results."
            },
            {
              "name": "list",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves all matching records as a List."
            },
            {
              "name": "query",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "General query operation that returns results based on the method return type."
            },
            {
              "name": "stream",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Returns query results as a Stream for lazy evaluation and processing."
            },
            {
              "name": "queryForSingle",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves a single value from the query result."
            },
            {
              "name": "queryForUnique",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves a unique single value from the query result."
            },
            {
              "name": "listAll",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves all ResultSets from a stored procedure call as Lists."
            },
            {
              "name": "queryAll",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves all ResultSets from a stored procedure call as Datasets."
            },
            {
              "name": "streamAll",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Retrieves all ResultSets from a stored procedure call as Streams."
            },
            {
              "name": "executeAndGetOutParameters",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Executes a stored procedure and retrieves OUT parameters."
            },
            {
              "name": "update",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Executes an UPDATE, INSERT, or DELETE statement and returns the number of affected rows."
            },
            {
              "name": "largeUpdate",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Executes an UPDATE, INSERT, or DELETE statement that may affect a large number of rows."
            },
            {
              "name": "DEFAULT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OP",
              "value": "new OP()",
              "javadoc_summary": "Default operation that lets the framework automatically determine the appropriate operation based on the SQL statement type and method signature."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.OnDeleteAction",
          "name": "OnDeleteAction",
          "kind": "enum",
          "modifiers": [
            "public"
          ],
          "deprecated": {
            "is_deprecated": true,
            "message": "Foreign key actions should be defined and implemented at the database server level, not in application code. Use proper database schema definitions instead.",
            "for_removal": false
          },
          "javadoc_summary": "Represents foreign key constraint actions that can be performed when a referenced row is deleted.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated public int value()",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "This enum is deprecated. Use database-level foreign key constraints instead.",
                "for_removal": false
              },
              "javadoc_summary": "Returns the raw integer value associated with this {@code OnDeleteAction} .",
              "contract": [
                "<p> The integer values are: </p> <ul> <li> {@link #NO_ACTION} : 0 </li> <li> {@link #SET_NULL} : 1 </li> <li> {@link #CASCADE} : 2 </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Example: Storing the action value OnDeleteAction action = OnDeleteAction.CASCADE; int actionValue = action.value(); System.out.println(\"Action code: \" + actionValue); // Prints: Action code: 2 // Example: Using value for conditional logic if (action.value() == 0) { System.out.println(\"No cascading delete will occur\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "static",
              "modifiers": [
                "public",
                "static"
              ],
              "signature": "@Deprecated public static OnDeleteAction get(final String name)",
              "return_type": "OnDeleteAction",
              "type_params": [],
              "params": [
                {
                  "name": "name",
                  "type": "String",
                  "javadoc": "the string representation of the delete action (case-insensitive). Expected values are \"noAction\", \"setNull\", or \"cascade\". Cannot be null.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "This enum is deprecated. Use database-level foreign key constraints instead.",
                "for_removal": false
              },
              "javadoc_summary": "Returns the {@code OnDeleteAction} enum constant that corresponds to the given string name.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": [
            {
              "name": "NO_ACTION",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OnDeleteAction",
              "value": "new OnDeleteAction(0)",
              "javadoc_summary": "No action is taken when the referenced row is deleted."
            },
            {
              "name": "SET_NULL",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OnDeleteAction",
              "value": "new OnDeleteAction(1)",
              "javadoc_summary": "When the referenced row is deleted, the foreign key columns in child rows are set to NULL."
            },
            {
              "name": "CASCADE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "OnDeleteAction",
              "value": "new OnDeleteAction(2)",
              "javadoc_summary": "When the referenced row is deleted, all child rows that reference it are also deleted."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.PreparedQuery",
          "name": "PreparedQuery",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "A wrapper class for {@link PreparedStatement} that provides a fluent API for executing parameterized SQL queries.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Propagation",
          "name": "Propagation",
          "kind": "enum",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enumeration that represents transaction propagation behaviors.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": [
            {
              "name": "REQUIRED",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Propagation",
              "value": "new Propagation()",
              "javadoc_summary": "Support a current transaction, create a new one if none exists."
            },
            {
              "name": "SUPPORTS",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Propagation",
              "value": "new Propagation()",
              "javadoc_summary": "Support a current transaction, execute non-transactionally if none exists."
            },
            {
              "name": "MANDATORY",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Propagation",
              "value": "new Propagation()",
              "javadoc_summary": "Support a current transaction, throw an exception if none exists."
            },
            {
              "name": "REQUIRES_NEW",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Propagation",
              "value": "new Propagation()",
              "javadoc_summary": "Create a new transaction, and suspend the current transaction if one exists."
            },
            {
              "name": "NOT_SUPPORTED",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Propagation",
              "value": "new Propagation()",
              "javadoc_summary": "Execute non-transactionally, suspend the current transaction if one exists."
            },
            {
              "name": "NEVER",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Propagation",
              "value": "new Propagation()",
              "javadoc_summary": "Execute non-transactionally, throw an exception if a transaction exists."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.SQLTransaction",
          "name": "SQLTransaction",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "Represents a SQL transaction that manages database transaction lifecycle and connection state.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "id",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public String id()",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the unique identifier of this transaction.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "connection",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public Connection connection()",
              "return_type": "Connection",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the JDBC connection associated with this transaction.",
              "contract": [
                "This connection should not be closed manually as it will be managed by the transaction."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isolationLevel",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public IsolationLevel isolationLevel()",
              "return_type": "IsolationLevel",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the isolation level of this transaction.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran = JdbcUtil.beginTransaction(dataSource, IsolationLevel.SERIALIZABLE); IsolationLevel level = tran.isolationLevel(); if (level == IsolationLevel.SERIALIZABLE) { // Handle high isolation scenario } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "IsolationLevel"
              ]
            },
            {
              "name": "status",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public Transaction.Status status()",
              "return_type": "Transaction.Status",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the current status of this transaction.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); Transaction.Status status = tran.status(); if (status == Transaction.Status.ACTIVE) { // Transaction is still active and can be committed or rolled back } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Transaction.Status"
              ]
            },
            {
              "name": "isActive",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public boolean isActive()",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Checks if this transaction is currently active.",
              "contract": [
                "Checks if this transaction is currently active.",
                "A transaction is active if it has not been committed, rolled back, or marked for rollback.",
                "<p> This is a convenience method equivalent to checking if the status equals {@link Status#ACTIVE} .",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran = JdbcUtil.beginTransaction(dataSource); if (tran.isActive()) { // Safe to perform operations within this transaction performDatabaseOperations(); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "commit",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public void commit() throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if an SQL error occurs during the commit"
                }
              ],
              "javadoc_summary": "Commits the current transaction, making all changes permanent.",
              "contract": [
                "After a successful commit, the transaction is no longer active and the connection will be automatically reset and closed (if applicable).",
                "<p> If the transaction is marked for rollback only, it will be rolled back instead of committed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "rollback",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @Override public void rollback() throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if an SQL error occurs during the rollback"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "replaced by {@link #rollbackIfNotCommitted()}",
                "for_removal": false
              },
              "javadoc_summary": "Rolls back the current transaction, undoing all changes made within the transaction scope.",
              "contract": [
                "After a successful rollback, the transaction is no longer active and the connection will be automatically reset and closed (if applicable)."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "rollbackIfNotCommitted",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public void rollbackIfNotCommitted() throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if an SQL error occurs during the rollback"
                }
              ],
              "javadoc_summary": "Rolls back the transaction if it has not been committed successfully.",
              "contract": [
                "Rolls back the transaction if it has not been committed successfully.",
                "This method is safe to call multiple times and will only perform a rollback if the transaction is still active or in a failed commit state.",
                "It will do nothing if the transaction has already been committed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "runNotInMe",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <E extends Throwable> void runNotInMe(final Throwables.Runnable<E> cmd) throws E",
              "return_type": "void",
              "type_params": [
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cmd",
                  "type": "Throwables.Runnable<E>",
                  "javadoc": "the {@code Runnable} to be executed outside of this transaction, must not be {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "E",
                  "condition": "if the {@code Runnable} throws an exception"
                }
              ],
              "javadoc_summary": "Executes the specified {@code Runnable} outside of this transaction context.",
              "contract": [
                "<p> This is useful when you need to perform operations that should not be part of the current transaction, such as logging or audit operations that should not be rolled back with the main transaction."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callNotInMe",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "public <R, E extends Throwable> R callNotInMe(final Throwables.Callable<R, E> cmd) throws E",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                },
                {
                  "name": "E",
                  "bounds": [
                    "Throwable"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cmd",
                  "type": "Throwables.Callable<R, E>",
                  "javadoc": "the {@code Callable} to be executed outside of this transaction, must not be {@code null}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "E",
                  "condition": "if the {@code Callable} throws an exception"
                }
              ],
              "javadoc_summary": "Executes the specified {@code Callable} outside of this transaction context.",
              "contract": [
                "<p> This is useful when you need to perform operations that should not be part of the current transaction and return a result, such as querying data that should not be affected by uncommitted changes."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "close",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public void close()",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Closes this transaction by calling {@link #rollbackIfNotCommitted()} .",
              "contract": [],
              "examples": [],
              "see_also": [
                "#rollbackIfNotCommitted()"
              ]
            },
            {
              "name": "hashCode",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public int hashCode()",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the hash code value for this transaction.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "equals",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public boolean equals(final Object obj)",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "obj",
                  "type": "Object",
                  "javadoc": "the reference object with which to compare",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Indicates whether some other object is \"equal to\" this transaction.",
              "contract": [
                "Two transactions are considered equal if they have the same timed ID.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code SQLTransaction tran1 = JdbcUtil.beginTransaction(dataSource); SQLTransaction tran2 = tran1; if (tran1.equals(tran2)) { // Same transaction instance } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "toString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override public String toString()",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns a string representation of this transaction.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Transaction",
          "name": "Transaction",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Represents a database transaction that provides methods for managing transactional operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "id",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String id()",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the unique identifier of this transaction.",
              "contract": [
                "The identifier is typically generated when the transaction is created and remains constant throughout the transaction's lifecycle."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isolationLevel",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "IsolationLevel isolationLevel()",
              "return_type": "IsolationLevel",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the isolation level of this transaction.",
              "contract": [
                "<p> Common isolation levels include: </p> <ul> <li> READ_UNCOMMITTED - Allows dirty reads </li> <li> READ_COMMITTED - Prevents dirty reads </li> <li> REPEATABLE_READ - Prevents dirty and non-repeatable reads </li> <li> SERIALIZABLE - Prevents all phenomena </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code IsolationLevel level = transaction.isolationLevel(); if (level == IsolationLevel.SERIALIZABLE) { // Handle high isolation scenario } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "status",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Status status()",
              "return_type": "Status",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the current status of this transaction.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Status status = transaction.status(); if (status == Status.ACTIVE) { // Transaction is still active and can be committed or rolled back } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Status"
              ]
            },
            {
              "name": "isActive",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean isActive()",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Checks if this transaction is currently active.",
              "contract": [
                "Checks if this transaction is currently active.",
                "A transaction is considered active if it has been started but not yet committed or rolled back.",
                "<p> This is a convenience method equivalent to checking if the status equals {@link Status#ACTIVE} .",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code if (transaction.isActive()) { // Safe to perform operations within this transaction performDatabaseOperations(); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "commit",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void commit() throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if an SQL error occurs during the commit, or if the transaction is not in an active state"
                }
              ],
              "javadoc_summary": "Commits the current transaction, making all changes permanent.",
              "contract": [
                "<p> If the commit fails, the transaction status will be set to {@link Status#FAILED_COMMIT} and an exception will be thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "rollback",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void rollback() throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if an SQL error occurs during the rollback, or if the transaction is not in an active state"
                }
              ],
              "javadoc_summary": "Rolls back the current transaction, undoing all changes made within the transaction scope.",
              "contract": [
                "<p> If the rollback fails, the transaction status will be set to {@link Status#FAILED_ROLLBACK} and an exception will be thrown."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "rollbackIfNotCommitted",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void rollbackIfNotCommitted() throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if an SQL error occurs during the rollback attempt"
                }
              ],
              "javadoc_summary": "Rolls back the transaction if it has not been committed successfully.",
              "contract": [
                "Rolls back the transaction if it has not been committed successfully.",
                "This method is safe to call multiple times and will only perform a rollback if the transaction is still active or in a failed commit state."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Transaction.Status",
          "name": "Status",
          "kind": "enum",
          "modifiers": [
            "public",
            "static"
          ],
          "javadoc_summary": "Enumeration representing the various states a transaction can be in during its lifecycle.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": [
            {
              "name": "ACTIVE",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Status",
              "value": "new Status()",
              "javadoc_summary": "The transaction is active and can accept operations."
            },
            {
              "name": "MARKED_ROLLBACK",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Status",
              "value": "new Status()",
              "javadoc_summary": "The transaction has been marked for rollback only."
            },
            {
              "name": "COMMITTED",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Status",
              "value": "new Status()",
              "javadoc_summary": "The transaction has been successfully committed."
            },
            {
              "name": "FAILED_COMMIT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Status",
              "value": "new Status()",
              "javadoc_summary": "The transaction commit operation failed."
            },
            {
              "name": "ROLLED_BACK",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Status",
              "value": "new Status()",
              "javadoc_summary": "The transaction has been successfully rolled back."
            },
            {
              "name": "FAILED_ROLLBACK",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Status",
              "value": "new Status()",
              "javadoc_summary": "The transaction rollback operation failed."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.Transaction.Action",
          "name": "Action",
          "kind": "enum",
          "modifiers": [
            "public",
            "static"
          ],
          "javadoc_summary": "Enumeration representing the possible actions that can be performed on a transaction.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": [
            {
              "name": "COMMIT",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Action",
              "value": "new Action()",
              "javadoc_summary": "Indicates that the transaction should be committed."
            },
            {
              "name": "ROLLBACK",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "Action",
              "value": "new Action()",
              "javadoc_summary": "Indicates that the transaction should be rolled back."
            }
          ]
        },
        {
          "fqn": "com.landawn.abacus.jdbc.cs",
          "name": "cs",
          "kind": "class",
          "modifiers": [
            "public",
            "final"
          ],
          "javadoc_summary": "Constants container class providing standardized parameter and field names used throughout the Abacus JDBC framework.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": [
            {
              "name": "ResultSet",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"ResultSet\"",
              "javadoc_summary": "Parameter name for ResultSet objects in query processing."
            },
            {
              "name": "action",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"action\"",
              "javadoc_summary": "Parameter name for action callbacks and operations."
            },
            {
              "name": "afterInvokeAction",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"afterInvokeAction\"",
              "javadoc_summary": "Parameter name for actions to be executed after method invocation."
            },
            {
              "name": "autoGeneratedKeyExtractor",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"autoGeneratedKeyExtractor\"",
              "javadoc_summary": "Parameter name for extractors that retrieve auto-generated keys from insert operations."
            },
            {
              "name": "batchParameters",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"batchParameters\"",
              "javadoc_summary": "Parameter name for collections of parameters used in batch operations."
            },
            {
              "name": "batchSize",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"batchSize\"",
              "javadoc_summary": "Parameter name for the size of batches in batch processing operations."
            },
            {
              "name": "beforeInvokeAction",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"beforeInvokeAction\"",
              "javadoc_summary": "Parameter name for actions to be executed before method invocation."
            },
            {
              "name": "closeHandler",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"closeHandler\"",
              "javadoc_summary": "Parameter name for handlers responsible for resource cleanup and closing operations."
            },
            {
              "name": "cmd",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"cmd\"",
              "javadoc_summary": "Parameter name for command objects or command specifications."
            },
            {
              "name": "columnGetter",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"columnGetter\"",
              "javadoc_summary": "Parameter name for functions that extract values from database columns."
            },
            {
              "name": "columnIndex",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"columnIndex\"",
              "javadoc_summary": "Parameter name for zero-based column index in result sets."
            },
            {
              "name": "columnName",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"columnName\"",
              "javadoc_summary": "Parameter name for database column names."
            },
            {
              "name": "cond",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"cond\"",
              "javadoc_summary": "Parameter name for condition objects used in query filtering."
            },
            {
              "name": "conn",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"conn\"",
              "javadoc_summary": "Parameter name for database Connection objects."
            },
            {
              "name": "consumer",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"consumer\"",
              "javadoc_summary": "Parameter name for Consumer functional interfaces that process single elements."
            },
            {
              "name": "consumerForAll",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"consumerForAll\"",
              "javadoc_summary": "Parameter name for Consumer functional interfaces that process all elements in a collection."
            },
            {
              "name": "count",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"count\"",
              "javadoc_summary": "Parameter name for count values or counting operations."
            },
            {
              "name": "daoInterface",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"daoInterface\"",
              "javadoc_summary": "Parameter name for Data Access Object interface classes."
            },
            {
              "name": "dataSource",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"dataSource\"",
              "javadoc_summary": "Parameter name for DataSource objects used to obtain database connections."
            },
            {
              "name": "defaultColumnGetter",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"defaultColumnGetter\"",
              "javadoc_summary": "Parameter name for default column value extraction functions."
            },
            {
              "name": "downstream",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"downstream\"",
              "javadoc_summary": "Parameter name for downstream collectors or operations in stream processing."
            },
            {
              "name": "entity",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"entity\"",
              "javadoc_summary": "Parameter name for entity objects representing database records or domain models."
            },
            {
              "name": "entityClass",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"entityClass\"",
              "javadoc_summary": "Parameter name for Class objects representing entity types."
            },
            {
              "name": "executor",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"executor\"",
              "javadoc_summary": "Parameter name for Executor objects used for asynchronous task execution."
            },
            {
              "name": "filter",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"filter\"",
              "javadoc_summary": "Parameter name for filter predicates used to test and exclude elements."
            },
            {
              "name": "func",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"func\"",
              "javadoc_summary": "Parameter name for function objects or functional interfaces."
            },
            {
              "name": "getter",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"getter\"",
              "javadoc_summary": "Parameter name for getter functions that extract values from objects."
            },
            {
              "name": "handler",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"handler\"",
              "javadoc_summary": "Parameter name for handler objects that process events or manage operations."
            },
            {
              "name": "handlerClass",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"handlerClass\"",
              "javadoc_summary": "Parameter name for Class objects representing handler types."
            },
            {
              "name": "idExtractor",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"idExtractor\"",
              "javadoc_summary": "Parameter name for functions that extract unique identifier values from entities."
            },
            {
              "name": "isDefaultIdTester",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"isDefaultIdTester\"",
              "javadoc_summary": "Parameter name for predicates that test whether an ID value is the default/unset value."
            },
            {
              "name": "isolationLevel",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"isolationLevel\"",
              "javadoc_summary": "Parameter name for database transaction isolation level settings."
            },
            {
              "name": "keyExtractor",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"keyExtractor\"",
              "javadoc_summary": "Parameter name for functions that extract key values for grouping or mapping operations."
            },
            {
              "name": "mergeFunction",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"mergeFunction\"",
              "javadoc_summary": "Parameter name for binary functions that merge duplicate values in map operations."
            },
            {
              "name": "multimapSupplier",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"multimapSupplier\"",
              "javadoc_summary": "Parameter name for suppliers that create multimap instances for collecting grouped values."
            },
            {
              "name": "n",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"n\"",
              "javadoc_summary": "Parameter name for numeric values, typically representing count, limit, or size."
            },
            {
              "name": "namedSql",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"namedSql\"",
              "javadoc_summary": "Parameter name for SQL queries that use named parameters instead of positional parameters."
            },
            {
              "name": "offset",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"offset\"",
              "javadoc_summary": "Parameter name for offset values used in pagination and result limiting."
            },
            {
              "name": "orElseAction",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"orElseAction\"",
              "javadoc_summary": "Parameter name for alternative actions to execute when the primary action cannot be performed."
            },
            {
              "name": "parameterNames",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"parameterNames\"",
              "javadoc_summary": "Parameter name for collections of parameter names used in named SQL queries."
            },
            {
              "name": "parameters",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"parameters\"",
              "javadoc_summary": "Parameter name for collections of parameter values used in SQL query execution."
            },
            {
              "name": "parametersSetter",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"parametersSetter\"",
              "javadoc_summary": "Parameter name for functions that set multiple parameters on PreparedStatement objects."
            },
            {
              "name": "propNamesToRefresh",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"propNamesToRefresh\"",
              "javadoc_summary": "Parameter name for collections of property names that should be refreshed after database operations."
            },
            {
              "name": "qualifier",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"qualifier\"",
              "javadoc_summary": "Parameter name for qualifier strings used to distinguish or categorize objects."
            },
            {
              "name": "register",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"register\"",
              "javadoc_summary": "Parameter name for registration operations or registry objects."
            },
            {
              "name": "resultExtractor",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"resultExtractor\"",
              "javadoc_summary": "Parameter name for functions that extract results from ResultSet objects."
            },
            {
              "name": "resultExtractor1",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"resultExtractor1\"",
              "javadoc_summary": "Parameter name for the first result extractor function in multi-extractor operations."
            },
            {
              "name": "resultExtractor2",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"resultExtractor2\"",
              "javadoc_summary": "Parameter name for the second result extractor function in multi-extractor operations."
            },
            {
              "name": "resultExtractor3",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"resultExtractor3\"",
              "javadoc_summary": "Parameter name for the third result extractor function in multi-extractor operations."
            },
            {
              "name": "resultSet",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"resultSet\"",
              "javadoc_summary": "Parameter name for ResultSet objects (lowercase variant of ResultSet constant)."
            },
            {
              "name": "returnColumnIndexes",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"returnColumnIndexes\"",
              "javadoc_summary": "Parameter name for arrays of column indexes to be returned from insert operations."
            },
            {
              "name": "returnColumnNames",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"returnColumnNames\"",
              "javadoc_summary": "Parameter name for arrays of column names to be returned from insert operations."
            },
            {
              "name": "rowConsumer",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"rowConsumer\"",
              "javadoc_summary": "Parameter name for consumer functions that process individual rows from result sets."
            },
            {
              "name": "rowExtractor",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"rowExtractor\"",
              "javadoc_summary": "Parameter name for functions that extract complete row data from ResultSet objects."
            },
            {
              "name": "rowFilter",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"rowFilter\"",
              "javadoc_summary": "Parameter name for predicates that filter rows during result set processing."
            },
            {
              "name": "rowMapper",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"rowMapper\"",
              "javadoc_summary": "Parameter name for functions that map ResultSet rows to domain objects."
            },
            {
              "name": "rowMapper1",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"rowMapper1\"",
              "javadoc_summary": "Parameter name for the first row mapper function in multi-mapper operations."
            },
            {
              "name": "rowMapper2",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"rowMapper2\"",
              "javadoc_summary": "Parameter name for the second row mapper function in multi-mapper operations."
            },
            {
              "name": "rowMapper3",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"rowMapper3\"",
              "javadoc_summary": "Parameter name for the third row mapper function in multi-mapper operations."
            },
            {
              "name": "sql",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"sql\"",
              "javadoc_summary": "Parameter name for SQL query strings."
            },
            {
              "name": "sqlAction",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"sqlAction\"",
              "javadoc_summary": "Parameter name for action functions that operate on SQL query results."
            },
            {
              "name": "sqlAction1",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"sqlAction1\"",
              "javadoc_summary": "Parameter name for the first SQL action function in multi-action operations."
            },
            {
              "name": "sqlAction2",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"sqlAction2\"",
              "javadoc_summary": "Parameter name for the second SQL action function in multi-action operations."
            },
            {
              "name": "sqlAction3",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"sqlAction3\"",
              "javadoc_summary": "Parameter name for the third SQL action function in multi-action operations."
            },
            {
              "name": "stmt",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"stmt\"",
              "javadoc_summary": "Parameter name for Statement or PreparedStatement objects."
            },
            {
              "name": "stmtCreator",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"stmtCreator\"",
              "javadoc_summary": "Parameter name for functions that create Statement or PreparedStatement objects."
            },
            {
              "name": "stmtSetter",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"stmtSetter\"",
              "javadoc_summary": "Parameter name for functions that configure Statement or PreparedStatement objects."
            },
            {
              "name": "supplier",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"supplier\"",
              "javadoc_summary": "Parameter name for supplier functions that provide objects or values on demand."
            },
            {
              "name": "targetClass",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"targetClass\"",
              "javadoc_summary": "Parameter name for Class objects representing target types for mapping or conversion operations."
            },
            {
              "name": "targetType",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"targetType\"",
              "javadoc_summary": "Parameter name for Type objects representing target types for generic operations."
            },
            {
              "name": "type",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"type\"",
              "javadoc_summary": "Parameter name for type specifications or Type objects."
            },
            {
              "name": "uniquePropNamesForQuery",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"uniquePropNamesForQuery\"",
              "javadoc_summary": "Parameter name for collections of unique property names used in query construction."
            },
            {
              "name": "url",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"url\"",
              "javadoc_summary": "Parameter name for URL strings, typically database connection URLs."
            },
            {
              "name": "valueExtractor",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"valueExtractor\"",
              "javadoc_summary": "Parameter name for functions that extract values from objects or result sets."
            },
            {
              "name": "selectPropName",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"selectPropName\"",
              "javadoc_summary": "Parameter name for property names used in select queries."
            },
            {
              "name": "targetValueType",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"targetValueType\"",
              "javadoc_summary": "Parameter name for specifying the target value type in mapping or conversion operations."
            },
            {
              "name": "id",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"id\"",
              "javadoc_summary": "Parameter name for identifier fields or properties."
            },
            {
              "name": "propNamesToInsert",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"propNamesToInsert\"",
              "javadoc_summary": "Parameter name for property values used in insert operations."
            },
            {
              "name": "propNamesToSave",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"propNamesToSave\"",
              "javadoc_summary": "Parameter name for property values used in save operations."
            },
            {
              "name": "propNamesToUpdate",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"propNamesToUpdate\"",
              "javadoc_summary": "Parameter name for property values used in update operations."
            },
            {
              "name": "propsToUpdate",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"propsToUpdate\"",
              "javadoc_summary": "Parameter name for property values to update, typically a map from property name to its new value, used by update operations to provide partial updates."
            },
            {
              "name": "namedInsertSql",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"namedInsertSql\"",
              "javadoc_summary": "Parameter name for named insert SQL statements."
            },
            {
              "name": "joinEntityPropName",
              "modifiers": [
                "public",
                "static",
                "final"
              ],
              "type": "String",
              "value": "\"joinEntityPropName\"",
              "javadoc_summary": "Parameter name for join entity property names used in join operations."
            }
          ]
        }
      ]
    },
    {
      "name": "com.landawn.abacus.jdbc.annotation",
      "types": [
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.Bind",
          "name": "Bind",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Binds a method parameter to a named parameter in SQL queries.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the parameter name to be used in the SQL query.",
              "contract": [
                "If not specified (empty string), the parameter name will be used."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.BindList",
          "name": "BindList",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Binds a collection or array parameter to a SQL query, automatically expanding it into the appropriate number of parameter placeholders.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the parameter name to be used in the SQL query.",
              "contract": [
                "If not specified (empty string), the parameter name will be used.",
                "The string passed to {@code value} must exactly match the template variable used in the {@code @Query} SQL (for example, {@code @BindList(\"ids\")} must correspond to {@code ...",
                "<p> The parameter should be referenced in the SQL using curly braces: {@code {paramName}} </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Explicit name @Query(\"SELECT * FROM users WHERE id IN ({userIds})\") List<User> find(@BindList(\"userIds\") List<Long> ids); // Using parameter name (when value is not specified) @Query(\"SELECT * FROM users WHERE id IN ({ids})\") List<User> find(@BindList List<Long> ids); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prefixForNonEmpty",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta String prefixForNonEmpty() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies a prefix to add before the parameter placeholder when the collection is non-empty.",
              "contract": [
                "Specifies a prefix to add before the parameter placeholder when the collection is non-empty."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "suffixForNonEmpty",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta String suffixForNonEmpty() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies a suffix to add after the parameter placeholder when the collection is non-empty.",
              "contract": [
                "Specifies a suffix to add after the parameter placeholder when the collection is non-empty."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.Cache",
          "name": "Cache",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enables caching at the DAO level for database query results.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "capacity",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int capacity() default JdbcUtil.DEFAULT_BATCH_SIZE",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the maximum number of entries the cache can hold.",
              "contract": [
                "When the cache reaches this capacity, the least recently used entries will be evicted to make room for new entries."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "evictDelay",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "long evictDelay() default JdbcUtil.DEFAULT_CACHE_EVICT_DELAY",
              "return_type": "long",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the time delay (in milliseconds) after which cached entries will be evicted.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "impl",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Class<? extends DaoCache> impl() default Jdbc.DefaultDaoCache.class",
              "return_type": "Class<? extends DaoCache>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the implementation class for the DAO cache.",
              "contract": [
                "The implementation must extend {@link DaoCache} and have a public constructor that accepts two parameters: {@code (int capacity, long evictDelay)} ."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.CacheResult",
          "name": "CacheResult",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enables method-level result caching for DAO query methods.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "disabled",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean disabled() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Disables caching when set to {@code true} .",
              "contract": [
                "Disables caching when set to {@code true} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "liveTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "long liveTime() default JdbcUtil.DEFAULT_CACHE_LIVE_TIME",
              "return_type": "long",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the maximum time (in milliseconds) a cached entry can live.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "maxIdleTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "long maxIdleTime() default JdbcUtil.DEFAULT_CACHE_MAX_IDLE_TIME",
              "return_type": "long",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the maximum idle time (in milliseconds) for a cached entry.",
              "contract": [
                "If an entry is not accessed within this time, it expires and is removed.",
                "This is useful for frequently accessed data that should expire if unused.",
                "<p> The entry expires when either {@code liveTime} or {@code maxIdleTime} is exceeded, whichever comes first.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Expire if not accessed for 10 minutes @CacheResult(liveTime = 3600000, maxIdleTime = 600000) @Query(\"SELECT * FROM user_sessions WHERE token = :token\") UserSession getSession(@Bind(\"token\") String token); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "minSize",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int minSize() default 0",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the minimum size requirement for caching collection results.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Only cache if result has at least 10 items @CacheResult(minSize = 10) @Query(\"SELECT * FROM products WHERE category = :category\") List<Product> findByCategory(@Bind(\"category\") String category); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "maxSize",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int maxSize() default Integer.MAX_VALUE",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the maximum size limit for caching collection results.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Don't cache if result has more than 1000 items @CacheResult(maxSize = 1000) @Query(\"SELECT * FROM orders WHERE date >= :startDate\") List<Order> findOrdersSince(@Bind(\"startDate\") Date date); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "transfer",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String transfer() default \"none\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the serialization strategy for cache storage and retrieval.",
              "contract": [
                "This determines how objects are copied when stored in or retrieved from cache."
              ],
              "examples": [],
              "see_also": [
                "<a href=\"https://github.com/EsotericSoftware/kryo\">,Kryo Serialization,</a>"
              ]
            },
            {
              "name": "filter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String[] filter() default { \"query\", \"queryFor\", \"list\", \"get\", \"batchGet\", \"find\", \"findFirst\", \"findOnlyOne\", \"exist\", \"notExist\", \"count\" }",
              "return_type": "String[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies filter patterns for methods when the annotation is applied at the class level.",
              "contract": [
                "Specifies filter patterns for methods when the annotation is applied at the class level.",
                "</p> <p> This filter is ignored when the annotation is applied at the method level."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.DaoConfig",
          "name": "DaoConfig",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Provides DAO-level configuration options that affect query generation and execution behavior.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "addLimitForSingleQuery",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean addLimitForSingleQuery() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Controls whether to automatically add LIMIT clause to single-result query methods.",
              "contract": [
                "When {@code true} , methods that return a single result will have {@code LIMIT 1} (or equivalent) added to their SQL queries for better performance.",
                "<p> Single query methods include: </p> <ul> <li> {@code queryForSingleXxx()} methods </li> <li> {@code queryForUniqueResult()} </li> <li> {@code findFirst()} </li> <li> {@code findOnlyOne()} </li> <li> {@code exists()} </li> <li> {@code count()} (when not using COUNT in SQL) </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code @DaoConfig(addLimitForSingleQuery = true) public interface ProductDao extends CrudDao<Product, Long> { @Query(\"SELECT * FROM products WHERE code = :code\") Product findByCode(@Bind(\"code\") String code); // Executed as: SELECT * FROM products WHERE code = ?"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callGenerateIdForInsertIfIdNotSet",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean callGenerateIdForInsertIfIdNotSet() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Controls whether to automatically call {@code generateId()} for entity inserts when the ID field is not set or has a default value.",
              "contract": [
                "Controls whether to automatically call {@code generateId()} for entity inserts when the ID field is not set or has a default value.",
                "The ID is considered \"not set\" when it's null or has the default value for its type (0 for numeric types, null for objects)."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "callGenerateIdForInsertWithSqlIfIdNotSet",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean callGenerateIdForInsertWithSqlIfIdNotSet() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Controls whether to automatically call {@code generateId()} for SQL-based entity inserts when the ID field is not set or has a default value.",
              "contract": [
                "Controls whether to automatically call {@code generateId()} for SQL-based entity inserts when the ID field is not set or has a default value.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code @DaoConfig(callGenerateIdForInsertWithSqlIfIdNotSet = true) public interface OrderDao extends CrudDao<Order, Long> { default void insertWithAudit(Order order) { String sql = \"INSERT INTO orders (id, customer_id, total, created_by) \" + \"VALUES (:id, :customerId, :total, CURRENT_USER())\"; insert(sql, order); // generateId() called if order.id not set } } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "allowJoiningByNullOrDefaultValue",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean allowJoiningByNullOrDefaultValue() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Controls whether joins can be performed using null or default values in join conditions.",
              "contract": [
                "When false (default), joins with null values are skipped for safety.",
                "When true, allows joins even when the joining column contains null.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code @DaoConfig(allowJoiningByNullOrDefaultValue = true) public interface CustomerDao extends CrudDao<Customer, Long> { // Allows join even if preferred_contact_id is null @Query(\"SELECT c.*, p.* FROM customers c \" + \"LEFT JOIN contacts p ON c.preferred_contact_id = p.id\") @MergedById List<Customer> findAllWithPreferredContacts(); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "fetchColumnByEntityClassForDatasetQuery",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean fetchColumnByEntityClassForDatasetQuery() default true",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Controls whether Dataset queries should fetch only columns that match entity class properties.",
              "contract": [
                "Controls whether Dataset queries should fetch only columns that match entity class properties.",
                "When true (default), Dataset queries will only include columns that correspond to properties in the target entity class, similar to {@link FetchColumnByEntityClass} ."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.FetchColumnByEntityClass",
          "name": "FetchColumnByEntityClass",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Controls whether query results should be fetched based on the entity class properties when the return type is a Dataset or similar structure.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean value() default true",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies whether to fetch only columns that match entity class properties.",
              "contract": [
                "<p> When {@code true} (default): </p> <ul> <li> Only columns with matching properties in the entity class are fetched </li> <li> Provides better performance by reducing data transfer </li> <li> Results in cleaner Dataset with only relevant columns </li> </ul> <p> When {@code false} : </p> <ul> <li> All columns from the query result are fetched </li> <li> Useful when you need additional calculated or joined columns </li> <li> May include columns that don't map to entity properties </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Entity class public class User { private Long id; private String name; private String email; // Getters and setters } // DAO method @Query(\"SELECT id, name, email, COUNT(*) as login_count FROM users GROUP BY id, name, email\") @FetchColumnByEntityClass(false) // Need to fetch login_count Dataset getUserLoginStats(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.Handler",
          "name": "Handler",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Defines an interceptor handler for DAO methods or entire DAO interfaces.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "qualifier",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String qualifier() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies a qualifier to distinguish between multiple handlers of the same type.",
              "contract": [
                "This is useful when you need different configurations of the same handler class."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "type",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") Class<? extends Jdbc.Handler<? extends Dao>> type() default EmptyHandler.class",
              "return_type": "Class<? extends Jdbc.Handler<? extends Dao>>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the handler implementation class.",
              "contract": [
                "The class must extend {@link Jdbc.Handler} with the appropriate DAO type parameter.",
                "<p> The handler lifecycle methods are called in this order: </p> <ol> <li> {@code beforeInvoke()} - Before the actual method invocation </li> <li> Actual DAO method execution </li> <li> {@code afterInvoke()} - After successful completion (with result) </li> <li> {@code onError()} - If an exception occurs (instead of afterInvoke) </li> </ol> <p> Example handler implementation: </p> <pre> {@code public class SecurityHandler extends Jdbc.Handler<BaseDao> { @Override public void beforeInvoke(BaseDao dao, Method method, Object[] args) { // Check user permissions if (!hasPermission(method)) { throw new SecurityException(\"Access denied\"); } } @Override public Object afterInvoke(Object result, BaseDao dao, Method method, Object[] args) { // Can modify or filter results return filterSensitiveData(result); } } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "filter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String[] filter() default { \".*\" }",
              "return_type": "String[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies filter patterns for methods when the annotation is applied at the class level.",
              "contract": [
                "Specifies filter patterns for methods when the annotation is applied at the class level.",
                "</p> <p> This filter is ignored when the annotation is applied at the method level."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "isForInvokeFromOutsideOfDaoOnly",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean isForInvokeFromOutsideOfDaoOnly() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies whether this handler should only be applied to external invocations of the DAO.",
              "contract": [
                "Specifies whether this handler should only be applied to external invocations of the DAO.",
                "When {@code true} , the handler will not be triggered for internal method calls within the DAO.",
                "<p> This is useful for handlers that should only apply when the DAO is called from outside code, not when DAO methods call each other internally."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.HandlerList",
          "name": "HandlerList",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Container annotation for multiple {@link Handler} annotations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Handler[] value()",
              "return_type": "Handler[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the array of {@link Handler} annotations contained in this list.",
              "contract": [
                "<p> When multiple handlers are applied to a DAO or method, they form a chain of interceptors, with each handler having the opportunity to: </p> <ul> <li> Modify input parameters before invocation </li> <li> Prevent the actual method execution </li> <li> Transform or filter the results </li> <li> Handle exceptions in custom ways </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Accessing HandlerList programmatically via reflection HandlerList handlers = MyDao.class.getAnnotation(HandlerList.class); if (handlers != null) { for (Handler handler : handlers.value()) { System.out.println(\"Handler type: \" + handler.type()); System.out.println(\"Filter: \" + Arrays.toString(handler.filter())); } } // Multiple handlers are automatically wrapped in HandlerList @Handler(type = LoggingHandler.class) @Handler(type = SecurityHandler.class) @Handler(type = CacheHandler.class) public interface UserDao extends CrudDao<User, Long> { // The compiler wraps these in a HandlerList annotation } } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.MappedByKey",
          "name": "MappedByKey",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Transforms query results into a Map structure where each result row is keyed by a specified field.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@link #keyName()} for explicit and clear field name declaration",
                "for_removal": false
              },
              "javadoc_summary": "Legacy attribute for specifying the key field name.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "keyName",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String keyName() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the name of the field to use as the map key.",
              "contract": [
                "This field must exist in the query result set.",
                "The field can be: </p> <ul> <li> A database column name </li> <li> An entity property name (if using entity mapping) </li> <li> An alias defined in the SQL query </li> </ul> <p> Examples: </p> <pre> {@code // Using database column name @Query(\"SELECT user_id, user_name, email FROM users\") @MappedByKey(keyName = \"user_id\") Map<Long, Map<String, Object>> getUsers(); // Using entity property name @Query(\"SELECT * FROM products WHERE category = :category\") @MappedByKey(keyName = \"productCode\") // Maps to product_code column Map<String, Product> getProductsByCategory(@Bind(\"category\") String category); // Using SQL alias @Query(\"SELECT id, name, price * 0.9 as discounted_price FROM products\") @MappedByKey(keyName = \"discounted_price\") Map<BigDecimal, Product> getProductsByDiscountPrice(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "mapClass",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@SuppressWarnings(\"rawtypes\") Class<? extends Map> mapClass() default HashMap.class",
              "return_type": "Class<? extends Map>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the Map implementation class to use for the result.",
              "contract": [
                "The class must have a no-argument constructor."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.MergedById",
          "name": "MergedById",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Merges multiple result rows into single entities based on ID fields.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "The framework automatically detects ID fields from entity metadata. Use {@code @MergedById} without the value parameter.",
                "for_removal": false
              },
              "javadoc_summary": "Specifies the ID field(s) to use for merging rows.",
              "contract": [
                "</p> <p> The automatic ID detection works for: </p> <ul> <li> Single ID fields annotated with {@code @Id} </li> <li> Composite keys using {@code @Id} on multiple fields </li> <li> Standard naming conventions (e.g., \"id\" field name) </li> </ul> <p> Example with composite key (legacy usage): </p> <pre> {@code // Old way (deprecated) - manually specify composite key @Query(\"SELECT * FROM order_items WHERE order_date = :date\") @MergedById(\"orderId, productId\") List<OrderItem> findByDate(@Bind(\"date\") Date date); // New way (recommended) - let framework detect ID fields @Query(\"SELECT * FROM order_items WHERE order_date = :date\") @MergedById List<OrderItem> findByDate(@Bind(\"date\") Date date); // OrderItem class should have @Id annotations on orderId and productId fields } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.NonDBOperation",
          "name": "NonDBOperation",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Marks methods in DAO interfaces that should not be treated as database operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.OnDelete",
          "name": "OnDelete",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "deprecated": {
            "is_deprecated": true,
            "message": "This annotation won't be implemented. Define ON DELETE behavior in database schema instead.",
            "for_removal": false
          },
          "javadoc_summary": "Specifies cascading delete behavior for entity relationships.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "action",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated OnDeleteAction action() default OnDeleteAction.NO_ACTION",
              "return_type": "OnDeleteAction",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Define ON DELETE actions in database foreign key constraints",
                "for_removal": false
              },
              "javadoc_summary": "Specifies the action to take when a referenced entity is deleted.",
              "contract": [
                "Specifies the action to take when a referenced entity is deleted.",
                "<p> <strong> Note: </strong> This functionality should be implemented at the database level using foreign key constraints rather than in the application layer.",
                "</p> <p> Available actions correspond to standard SQL ON DELETE behaviors: </p> <ul> <li> {@link OnDeleteAction#NO_ACTION} - Default, no automatic action </li> <li> {@link OnDeleteAction#CASCADE} - Delete dependent records </li> <li> {@link OnDeleteAction#SET_NULL} - Set foreign key to NULL </li> <li> SET_DEFAULT - Set foreign key to default value (not currently supported) </li> <li> RESTRICT - Prevent deletion if dependencies exist (use NO_ACTION instead) </li> </ul>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.OutParameter",
          "name": "OutParameter",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Declares an output parameter for stored procedure calls.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "name",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String name() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the name of the output parameter.",
              "contract": [
                "<p> Either {@code name} or {@code position} must be specified, but not both.",
                "</p> <p> The parameter name should match the name used in the stored procedure call syntax."
              ],
              "examples": [],
              "see_also": [
                "CallableStatement#registerOutParameter(String, int)"
              ]
            },
            {
              "name": "position",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int position() default -1",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the position of the output parameter.",
              "contract": [
                "Either {@code name} or {@code position} must be specified, but not both."
              ],
              "examples": [],
              "see_also": [
                "CallableStatement#registerOutParameter(int, int)"
              ]
            },
            {
              "name": "sqlType",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int sqlType()",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the SQL type of the output parameter.",
              "contract": [
                "This must be one of the constants defined in {@link java.sql.Types} .",
                "<p> Common SQL types include: </p> <ul> <li> {@link Types#VARCHAR} - String values </li> <li> {@link Types#INTEGER} - Integer values </li> <li> {@link Types#DECIMAL} or {@link Types#NUMERIC} - Decimal numbers </li> <li> {@link Types#DATE} , {@link Types#TIME} , {@link Types#TIMESTAMP} - Date/time values </li> <li> {@link Types#BOOLEAN} - Boolean values </li> <li> {@link Types#CLOB} - Character large objects </li> <li> {@link Types#BLOB} - Binary large objects </li> </ul> <p> The SQL type must match the actual type of the output parameter in the stored procedure."
              ],
              "examples": [],
              "see_also": [
                "Types"
              ]
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.OutParameterList",
          "name": "OutParameterList",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Container annotation for multiple {@link OutParameter} annotations on a single method.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OutParameter[] value()",
              "return_type": "OutParameter[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "The array of {@link OutParameter} annotations contained in this list.",
              "contract": [
                "<p> This array is automatically populated when using multiple {@link OutParameter} annotations on a method due to the {@link java.lang.annotation.Repeatable} mechanism."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.PerfLog",
          "name": "PerfLog",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Enables performance logging for SQL operations and DAO methods.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "minExecutionTimeForSql",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "long minExecutionTimeForSql() default JdbcUtil.DEFAULT_MIN_EXECUTION_TIME_FOR_SQL_PERF_LOG",
              "return_type": "long",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the minimum execution time threshold (in milliseconds) for logging SQL performance.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "maxSqlLogLength",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int maxSqlLogLength() default JdbcUtil.DEFAULT_MAX_SQL_LOG_LENGTH",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the maximum length of SQL statements in performance logs.",
              "contract": [
                "<p> This is useful for maintaining readable logs when dealing with complex queries or queries with large parameter lists."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "minExecutionTimeForOperation",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "long minExecutionTimeForOperation() default JdbcUtil.DEFAULT_MIN_EXECUTION_TIME_FOR_DAO_METHOD_PERF_LOG",
              "return_type": "long",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the minimum execution time threshold (in milliseconds) for logging DAO method performance.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "filter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String[] filter() default { \".*\" }",
              "return_type": "String[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies filter patterns for methods when the annotation is applied at the class level.",
              "contract": [
                "Specifies filter patterns for methods when the annotation is applied at the class level.",
                "</p> <p> This filter is ignored when the annotation is applied at the method level."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.PrefixFieldMapping",
          "name": "PrefixFieldMapping",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Maps database column prefixes to object field paths for result set mapping.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the mapping between column prefixes and object field paths.",
              "contract": [
                "<p> Format: {@code \"prefix1=fieldPath1, prefix2=fieldPath2, ...\"} </p> <p> Rules: </p> <ul> <li> Prefixes should match the column aliases used in the SQL query </li> <li> Field paths can be simple field names or nested paths (e.g., \"address.city\") </li> <li> The prefix must be separated from the column name by a dot (e.g., {@code d.id} ); underscores are not supported </li> <li> The prefix is removed from the column name before mapping to the field </li> <li> Columns without matching prefixes are mapped normally </li> </ul> <p> Example mappings: </p> <pre> {@code // Simple prefix mapping @PrefixFieldMapping(\"addr=address\") // addr.street -> address.street // addr.city -> address.city // Multiple prefix mappings @PrefixFieldMapping(\"u=user, o=order, p=payment\") // u.name -> user.name // o.id -> order.id // p.amount -> payment.amount // Nested field mapping @PrefixFieldMapping(\"bill=billing.address, ship=shipping.address\") // bill.street -> billing.address.street // ship.street -> shipping.address.street } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.Query",
          "name": "Query",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Defines a generic SQL query operation for a DAO method.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String[] value() default {}",
              "return_type": "String[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the SQL statement to execute.",
              "contract": [
                "<p> The SQL can include: </p> <ul> <li> Named parameters using {@code :paramName} syntax for value binding </li> <li> Template variables using {@code {variableName}} syntax when {@link #fragmentContainsNamedParameters()} is {@code true} </li> <li> Standard SQL features like JOINs, subqueries, CTEs (Common Table Expressions), window functions, etc.",
                "</li> <li> Database-specific SQL extensions and functions </li> </ul> <p> Named parameter examples: </p> <pre> {@code // Simple parameter binding @Query(\"SELECT * FROM users WHERE age > :minAge\") List<User> findByAge(@Bind(\"minAge\") int minAge); // Multiple parameters @Query(\"SELECT * FROM users WHERE age BETWEEN :minAge AND :maxAge\") List<User> findByAgeRange(@Bind(\"minAge\") int min, @Bind(\"maxAge\") int max); // Nested property access @Query(\"SELECT * FROM orders WHERE user_id = :user.id AND status = :status\") List<Order> findOrders(@Bind(\"user\") User user, @Bind(\"status\") String status); // IN clause with collection @Query(\"SELECT * FROM users WHERE id IN (:ids)\") List<User> findByIds(@Bind(\"ids\") List<Long> ids); } </pre> <p> Complex SQL examples: </p> <pre> {@code // JOIN with aggregation @Query(\"SELECT u.*, COUNT(o.id) as order_count \" + \"FROM users u LEFT JOIN orders o ON u.id = o.user_id \" + \"WHERE u.created_date > :startDate \" + \"GROUP BY u.id HAVING COUNT(o.id) > :minOrders\") List<UserStats> findUserStats(@Bind(\"startDate\") Date startDate, @Bind(\"minOrders\") int minOrders); // Common Table Expression (CTE) @Query(\"WITH recent_orders AS ( \" + \" SELECT user_id, COUNT(*) as order_count \" + \" FROM orders WHERE order_date > :since \" + \" GROUP BY user_id \" + \") \" + \"SELECT u.*, ro.order_count \" + \"FROM users u JOIN recent_orders ro ON u.id = ro.user_id\") List<UserOrderSummary> findActiveUserSummary(@Bind(\"since\") Date since); // Window function @Query(\"SELECT *, ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) as rank \" + \"FROM employees WHERE department = :dept\") List<Employee> rankEmployeesByDepartment(@Bind(\"dept\") String department); } </pre> <p> Note: Either {@code value} or {@link #id()} should be specified, but not both.",
                "If neither is specified, the framework may attempt to derive the SQL based on the method name and entity mapping."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "id",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String[] id() default {}",
              "return_type": "String[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the ID of a SQL statement defined in an external SQL mapper.",
              "contract": [
                "It must be a valid Java identifier as per {@link RegExUtil#JAVA_IDENTIFIER_MATCHER} .",
                "// </sql> } </pre> <p> Note: Either {@link #value()} or {@code id} should be specified, but not both."
              ],
              "examples": [],
              "see_also": [
                "RegExUtil#JAVA_IDENTIFIER_MATCHER"
              ]
            },
            {
              "name": "op",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OP op() default OP.DEFAULT",
              "return_type": "OP",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the operation type for this query.",
              "contract": [
                "<p> The operation type influences: </p> <ul> <li> Result set processing strategy </li> <li> Return type handling and conversion </li> <li> Performance optimizations applied by the framework </li> <li> Expected behavior for edge cases (e.g., empty results) </li> </ul> <p> Common operation types: </p> <ul> <li> {@link OP#DEFAULT} - Framework determines operation based on SQL and return type (recommended for most cases) </li> <li> {@link OP#list} - Returns all results as a List </li> <li> {@link OP#stream} - Returns results as a Stream for lazy processing </li> <li> {@link OP#findFirst} - Returns the first result wrapped in Optional </li> <li> {@link OP#findOnlyOne} - Returns exactly one result, throws exception if zero or multiple found </li> <li> {@link OP#exists} - Returns boolean indicating if any results exist </li> <li> {@link OP#queryForSingle} - Returns a single scalar value </li> <li> {@link OP#queryForUnique} - Returns a unique single value or null </li> <li> {@link OP#update} - Executes UPDATE/INSERT/DELETE and returns row count </li> <li> {@link OP#largeUpdate} - For updates affecting potentially > Integer.MAX_VALUE rows </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Existence check @Query(value = \"SELECT 1 FROM users WHERE email = :email\", op = OP.exists) boolean emailExists(@Bind(\"email\") String email); // Single scalar value @Query(value = \"SELECT COUNT(*) FROM users WHERE active = true\", op = OP.queryForSingle) long countActiveUsers(); // First result from ordered query @Query(value = \"SELECT * FROM users ORDER BY created_date DESC\", op = OP.findFirst) Optional<User> findLatestUser(); // Exactly one result (throws if not exactly one) @Query(value = \"SELECT * FROM users WHERE id = :id\", op = OP.findOnlyOne) User getUserById(@Bind(\"id\") Long id); // Stream for large result sets @Query(value = \"SELECT * FROM large_table\", op = OP.stream, fetchSize = 1000) Stream<Record> streamAllRecords(); // Explicit update operation @Query(value = \"DELETE FROM audit_logs WHERE created_date < :cutoff\", op = OP.update) int purgeOldLogs(@Bind(\"cutoff\") Date cutoff); } </pre> <p> When to specify explicitly: </p> <ul> <li> For existence checks: use {@code OP.exists} for performance </li> <li> For scalar aggregates: use {@code OP.queryForSingle} </li> <li> When you need strict validation: use {@code OP.findOnlyOne} </li> <li> For large result sets: use {@code OP.stream} with appropriate fetch size </li> </ul> <p> Note: In most cases, {@link OP#DEFAULT} is sufficient as the framework intelligently determines the appropriate operation based on the SQL statement type and method return type."
              ],
              "examples": [],
              "see_also": [
                "OP"
              ]
            },
            {
              "name": "isProcedure",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean isProcedure() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Indicates whether the SQL statement is a stored procedure call.",
              "contract": [
                "When {@code true} , the framework treats the SQL as a callable statement and handles input/output parameters accordingly.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Stored procedure call with output parameter @Query(value = \"{call calculate_bonus(?, ?, ?)}\", isProcedure = true) @OutParameter(position = 3, sqlType = Types.DECIMAL) BigDecimal calculateBonus(@Bind(\"employeeId\") long employeeId, @Bind(\"performanceScore\") int score); } </pre> <p> When to use: </p> <ul> <li> Calling stored procedures or functions in the database </li> <li> When the SQL syntax follows the callable statement format (e.g., {@code {call procedure_name(?, ?)}} ) </li> <li> When using output parameters that need to be registered and retrieved </li> </ul>"
              ],
              "examples": [],
              "see_also": [
                "OutParameter",
                "OutParameterList"
              ]
            },
            {
              "name": "isBatch",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean isBatch() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Indicates whether this query should be executed as a batch operation.",
              "contract": [
                "Indicates whether this query should be executed as a batch operation.",
                "When {@code true} , the method should accept collection-type parameters and execute the query multiple times with different parameter sets in a single batch for better performance.",
                "<p> Batch operations significantly improve performance when executing the same SQL statement multiple times with different parameters by: </p> <ul> <li> Reducing network round trips to the database </li> <li> Allowing the database to optimize execution plans </li> <li> Minimizing parsing and compilation overhead </li> <li> Enabling better resource utilization </li> </ul> <p> When to use batch operations: </p> <ul> <li> Inserting multiple records (most common use case) </li> <li> Updating multiple records with different values </li> <li> Deleting multiple records based on different criteria </li> <li> Any scenario where the same SQL runs many times with different parameters </li> </ul> <p> Basic batch insert examples: </p> <pre> {@code // Batch insert with entity list @Query(value = \"INSERT INTO users (name, email, status) \" + \"VALUES (:name, :email, :status)\", isBatch = true) int[] batchInsertUsers(List<User> users); // Returns array of affected row counts // Batch insert with parallel parameter lists @Query(value = \"INSERT INTO products (code, name, price) \" + \"VALUES (:code, :name, :price)\", isBatch = true, batchSize = 500) int[] batchInsertProducts(@Bind(\"code\") List<String> codes, @Bind(\"name\") List<String> names, @Bind(\"price\") List<BigDecimal> prices); } </pre> <p> Batch update examples: </p> <pre> {@code // Batch update with entity list @Query(value = \"UPDATE users SET status = :status WHERE id = :id\", isBatch = true) int[] batchUpdateStatus(List<User> users); // Batch update with parallel lists @Query(value = \"UPDATE inventory SET quantity = :quantity WHERE product_id = :productId\", isBatch = true) int[] batchUpdateInventory(@Bind(\"productId\") List<Long> productIds, @Bind(\"quantity\") List<Integer> quantities); } </pre> <p> Batch delete example: </p> <pre> {@code @Query(value = \"DELETE FROM temp_records WHERE id = :id\", isBatch = true) int[] batchDelete(@Bind(\"id\") List<Long> ids); } </pre> <p> Advanced batch examples: </p> <pre> {@code // Large batch with custom batch size @Query(value = \"INSERT INTO event_log (timestamp, event_type, data) \" + \"VALUES (:timestamp, :eventType, :data)\", isBatch = true, batchSize = 1000) int[] batchLogEvents(List<EventLog> events); // Processes 1000 records per database round trip // Batch with timeout for large operations @Query(value = \"INSERT INTO historical_data (date, metric, value) \" + \"VALUES (:date, :metric, :value)\", isBatch = true, batchSize = 5000, queryTimeout = 300) int[] importHistoricalData(@Bind(\"date\") List<Date> dates, @Bind(\"metric\") List<String> metrics, @Bind(\"value\") List<Double> values); // Complex batch operation with multiple fields @Query(value = \"INSERT INTO orders (user_id, product_id, quantity, price, order_date) \" + \"VALUES (:userId, :productId, :quantity, :price, :orderDate)\", isBatch = true) int[] batchCreateOrders(List<Order> orders); } </pre> <p> Return type requirements: </p> <ul> <li> {@code int[]} - Array of affected row counts (one per batch item) - most common </li> <li> {@code void} - No return value needed </li> <li> {@code int} - Total affected rows across all batches </li> </ul> <p> Parameter requirements: </p> <ul> <li> At least one parameter must be a {@code Collection} or {@code List} </li> <li> All collection parameters must have the same size </li> <li> Framework iterates through collections in parallel, creating one batch item per index </li> <li> Single (non-collection) parameters are used for all batch items </li> </ul> <p> Parameter combination example: </p> <pre> {@code // Mix of collection and single parameters @Query(value = \"INSERT INTO user_actions (user_id, action, category, timestamp) \" + \"VALUES (:userId, :action, :category, :timestamp)\", isBatch = true) int[] logUserActions(@Bind(\"userId\") List<Long> userIds, // varies per batch item @Bind(\"action\") List<String> actions, // varies per batch item @Bind(\"category\") String category, // same for all items @Bind(\"timestamp\") Date timestamp); // same for all items } </pre> <p> Performance considerations: </p> <ul> <li> Use {@link #batchSize()} to control how many items are sent per database round trip </li> <li> Larger batch sizes reduce round trips but increase memory usage </li> <li> Optimal batch size depends on network latency, row size, and database configuration </li> <li> Consider database transaction log size and timeout limits </li> <li> Batch operations are typically 10-100 faster than individual operations </li> </ul> <p> Error handling: </p> <ul> <li> If any batch item fails, the entire batch typically fails (depends on database/driver) </li> <li> Some drivers support {@code Statement.EXECUTE_FAILED} in the result array </li> <li> Consider wrapping batch operations in transactions for atomicity </li> <li> Validate data before batching to minimize mid-batch failures </li> </ul> <p> Best practices: </p> <ul> <li> Use batch operations for bulk data loading and imports </li> <li> Set appropriate {@link #batchSize()} based on your data and environment </li> <li> Use {@link #queryTimeout()} for long-running batch operations </li> <li> Monitor memory usage with large batches </li> <li> Consider using transactions to ensure all-or-nothing semantics </li> <li> Validate collection parameters have matching sizes </li> </ul>"
              ],
              "examples": [],
              "see_also": [
                "#batchSize()"
              ]
            },
            {
              "name": "isSingleParameter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean isSingleParameter() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Indicates whether a single method parameter that is a collection or array should be treated as a single value rather than being expanded for batch operations or IN clauses.",
              "contract": [
                "Indicates whether a single method parameter that is a collection or array should be treated as a single value rather than being expanded for batch operations or IN clauses.",
                "<p> Default behavior ( {@code isSingleParameter = false} ): </p> <ul> <li> Collections/arrays in IN clauses are expanded: {@code WHERE id IN (:ids)} with {@code List<Long> ids} </li> <li> For batch operations, collections represent multiple rows to process </li> </ul> <p> When {@code isSingleParameter = true} : </p> <ul> <li> The collection/array is passed as a single value to the database </li> <li> Useful for database-native array types (e.g., PostgreSQL arrays) </li> <li> Useful for JSON array columns </li> <li> Useful for blob/clob data that happens to be an array </li> </ul> <p> Common use cases: </p> <pre> {@code // PostgreSQL array containment operator @Query(value = \"SELECT * FROM products WHERE tags @> :tags\", isSingleParameter = true) List<Product> findByTags(@Bind(\"tags\") String[] tags); // PostgreSQL array equality @Query(value = \"SELECT * FROM events WHERE participants = :participants\", isSingleParameter = true) List<Event> findByExactParticipants(@Bind(\"participants\") Long[] participants); // JSON array column @Query(value = \"INSERT INTO configs (name, options) VALUES (:name, :options::jsonb)\", isSingleParameter = true) int insertConfig(@Bind(\"name\") String name, @Bind(\"options\") String[] options); // Array intersection @Query(value = \"SELECT * FROM items WHERE categories && :categories\", isSingleParameter = true) List<Item> findByCategoryOverlap(@Bind(\"categories\") String[] categories); } </pre> <p> Contrast with default behavior: </p> <pre> {@code // Default: collection is expanded for IN clause @Query(value = \"SELECT * FROM users WHERE id IN (:ids)\") List<User> findByIds(@Bind(\"ids\") List<Long> ids); // Becomes: SELECT * FROM users WHERE id IN (?, ?, ?, ...) // With isSingleParameter: collection passed as single array value @Query(value = \"SELECT * FROM users WHERE id = ANY(:ids)\", isSingleParameter = true) List<User> findByIdsArray(@Bind(\"ids\") Long[] ids); // PostgreSQL: id = ANY($1) where $1 is an array parameter } </pre> <p> Important notes: </p> <ul> <li> Only applicable when the method has a single collection/array parameter or when specifically needed for one parameter </li> <li> Database must support the native array or collection type being used </li> <li> Not commonly needed for standard SQL; primarily for database-specific features </li> </ul>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "fragmentContainsNamedParameters",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta boolean fragmentContainsNamedParameters() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Indicates whether the SQL statement contains template variables defined by the {@link SqlFragment} or {@link SqlFragmentList} annotations that will be replaced with query fragments containing named parameters.",
              "contract": [],
              "examples": [],
              "see_also": [
                "SqlFragment",
                "SqlFragmentList"
              ]
            },
            {
              "name": "autoSetSysTimeParam",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta boolean autoSetSysTimeParam() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Enables automatic timestamp parameter injection for the query.",
              "contract": [
                "When {@code true} , named parameters {@code :sysTime} or {@code :now} are automatically set to the current system timestamp and named parameters {@code :sysDate} are automatically set to the current system date, without requiring it to be passed as a method parameter.",
                "</p> <p> Basic examples: </p> <pre> {@code // Finding currently active records @Query(value = \"SELECT * FROM promotions \" + \"WHERE start_date <= :sysTime AND end_date >= :sysDate\", autoSetSysTimeParam = true) List<Promotion> findActivePromotions(); // :sysTime and :sysDate are automatically set to current timestamp and date // Audit logging @Query(value = \"INSERT INTO audit_log (action, user_id, timestamp) \" + \"VALUES (:action, :userId, :sysTime)\", autoSetSysTimeParam = true) int logAction(@Bind(\"action\") String action, @Bind(\"userId\") Long userId); // Updating with timestamp @Query(value = \"UPDATE users SET last_login = :sysTime WHERE id = :id\", autoSetSysTimeParam = true) int updateLastLogin(@Bind(\"id\") Long id); } </pre> <p> Advanced examples: </p> <pre> {@code // Complex time-based filtering @Query(value = \"SELECT e.* FROM events e \" + \"WHERE e.start_time <= :sysTime \" + \" AND e.end_time >= :sysTime \" + \" AND e.category = :category\", autoSetSysTimeParam = true) List<Event> findCurrentEvents(@Bind(\"category\") String category); // Combining with other parameters @Query(value = \"SELECT * FROM subscriptions \" + \"WHERE user_id = :userId \" + \" AND start_date <= :sysTime \" + \" AND (end_date IS NULL OR end_date >= :sysTime)\", autoSetSysTimeParam = true) List<Subscription> findActiveSubscriptions(@Bind(\"userId\") Long userId); // Data archival based on current time @Query(value = \"INSERT INTO archive_logs \" + \"SELECT *, :sysTime as archived_at FROM logs \" + \"WHERE created_date < :cutoffDate\", autoSetSysTimeParam = true) int archiveOldLogs(@Bind(\"cutoffDate\") Date cutoffDate); // Scheduled task execution tracking @Query(value = \"UPDATE scheduled_tasks \" + \"SET last_run = :sysTime, next_run = :sysTime + INTERVAL :intervalMinutes MINUTE \" + \"WHERE task_id = :taskId\", autoSetSysTimeParam = true) int updateTaskExecution(@Bind(\"taskId\") String taskId, @Bind(\"intervalMinutes\") int interval); } </pre> <p> Multiple timestamp usage: </p> <pre> {@code // Using :sysTime multiple times in the same query @Query(value = \"INSERT INTO user_sessions (user_id, created_at, last_activity) \" + \"VALUES (:userId, :sysTime, :sysTime)\", autoSetSysTimeParam = true) int createSession(@Bind(\"userId\") Long userId); // Combining automatic and manual timestamps @Query(value = \"SELECT * FROM bookings \" + \"WHERE booking_date >= :startDate \" + \" AND booking_date <= :sysDate\", autoSetSysTimeParam = true) List<Booking> findBookingsSince(@Bind(\"startDate\") Date startDate); } </pre> <p> Important considerations: </p> <ul> <li> The {@code :sysTime} parameter is set once when the query is executed, ensuring consistency across the query </li> <li> The timestamp is obtained from the application server's system time, not the database server </li> <li> For database server time, use SQL functions like {@code CURRENT_TIMESTAMP} or {@code NOW()} instead </li> <li> The timestamp format and precision depend on the database column type and JDBC driver </li> <li> Cannot manually override the {@code :sysTime} parameter when this is enabled </li> </ul> <p> When not to use this feature: </p> <ul> <li> When you need explicit control over the timestamp value </li> <li> When you need database server time instead of application time </li> <li> When the timestamp should be passed in from external sources </li> <li> When you need different timestamps for different parts of a complex operation </li> </ul>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryTimeout",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int queryTimeout() default -1",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the query timeout in seconds.",
              "contract": [
                "If the query execution exceeds this timeout, it will be cancelled and a timeout exception will be thrown.",
                "<p> Setting an appropriate timeout is important for: </p> <ul> <li> Preventing resource exhaustion from long-running queries </li> <li> Meeting Service Level Agreement (SLA) requirements </li> <li> Detecting and failing fast on inefficient queries </li> <li> Protecting the application from database performance issues </li> <li> Preventing connection pool starvation </li> </ul> <p> Timeout guidelines (in seconds): </p> <ul> <li> {@code -1} (default) - Uses the default timeout configured in the connection or DataSource </li> <li> {@code 0} - No timeout (wait indefinitely - not recommended) </li> <li> {@code 1-5} - For simple, well-indexed queries that should be very fast </li> <li> {@code 10-30} - For complex queries with joins or aggregations </li> <li> {@code 60+} - For batch operations, data migrations, or reporting queries </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code // Quick lookup that should complete fast @Query(value = \"SELECT * FROM users WHERE id = :id\", queryTimeout = 2) User getUserById(@Bind(\"id\") Long id); // Complex reporting query @Query(value = \"SELECT ..."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "fetchSize",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int fetchSize() default -1",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the JDBC fetch size for the query.",
              "contract": [
                "<p> The fetch size is a hint to the JDBC driver about the number of rows that should be fetched from the database when more rows are needed.",
                "Higher values significantly improve performance for large result sets </li> <li> <strong> SQL Server: </strong> Adaptive fetch size based on packet size </li> </ul> <p> Important notes: </p> <ul> <li> Fetch size is a hint; drivers may ignore or adjust it </li> <li> Very large fetch sizes can cause OutOfMemoryError if rows are large </li> <li> Optimal fetch size depends on network latency, row size, and available memory </li> <li> For {@code Stream} return types, fetch size enables {@code true} lazy loading </li> <li> Profile and test with realistic data to find optimal values </li> <li> Consider using different fetch sizes for different environments (dev vs."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSize",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int batchSize() default JdbcUtil.DEFAULT_BATCH_SIZE",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the number of items to process in each database round trip for batch operations.",
              "contract": [
                "Only applicable when {@link #isBatch()} is {@code true} .",
                "batchSize = 100 - Total database round trips: 10,000 / 100 = 100 trips - Each trip processes 100 INSERT statements - Memory per trip: ~100  row size - More round trips but less memory per trip </pre> <p> Factors to consider when choosing batch size: </p> <ul> <li> <strong> Row size: </strong> Larger rows require smaller batch sizes to avoid memory issues </li> <li> <strong> Network latency: </strong> High latency benefits from larger batches </li> <li> <strong> Database limits: </strong> Some databases have maximum transaction sizes or statement counts </li> <li> <strong> Available memory: </strong> Limited memory requires smaller batches </li> <li> <strong> Concurrent operations: </strong> Consider memory usage across all concurrent operations </li> <li> <strong> Error handling: </strong> Smaller batches may be easier to retry on partial failures </li> </ul> <p> Database-specific considerations: </p> <ul> <li> <strong> PostgreSQL: </strong> Can handle very large batches efficiently; consider 1000-5000 </li> <li> <strong> MySQL: </strong> May have max_allowed_packet limit; typically 500-2000 </li> <li> <strong> Oracle: </strong> Efficient with batches of 100-1000 </li> <li> <strong> SQL Server: </strong> Generally efficient with 500-1000 </li> </ul> <p> Memory usage estimation: </p> <pre> Approximate memory per batch = batchSize  averageRowSize  2 (2 accounts for driver buffering and object overhead) Example calculations: - Small rows (100 bytes) =5000 \\u2192 ~1MB per batch - Medium rows (1KB) =1000 \\u2192 ~2MB per batch - Large rows (10KB) =100 \\u2192 ~2MB per batch - Very large rows (100KB) =10 \\u2192 ~2MB per batch </pre> <p> Best practices: </p> <ul> <li> Start with the default and measure performance </li> <li> Profile with realistic data volumes and row sizes </li> <li> Monitor memory usage under load </li> <li> Consider different values for different environments (dev vs.",
                "prod) </li> <li> Document the rationale for non-default batch sizes </li> <li> Test with edge cases (very small and very large datasets) </li> </ul> <p> Common anti-patterns to avoid: </p> <ul> <li> Using batch size of 1 (defeats the purpose of batching) </li> <li> Using extremely large batch sizes without memory testing </li> <li> Ignoring database-specific limitations </li> <li> Not adjusting batch size when row size changes significantly </li> </ul>"
              ],
              "examples": [],
              "see_also": [
                "#isBatch()",
                "JdbcUtil#DEFAULT_BATCH_SIZE"
              ]
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.RefreshCache",
          "name": "RefreshCache",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Controls cache refresh behavior for DAO methods that modify data.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "disabled",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean disabled() default false",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies whether cache refresh is disabled for the annotated element.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "filter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String[] filter() default { \"update\", \"delete\", \"deleteById\", \"insert\", \"save\", \"add\", \"remove\", \"upsert\", \"batchUpdate\", \"batchDelete\", \"batchDeleteByIds\", \"batchInsert\", \"batchSave\", \"batchAdd\", \"batchRemove\", \"batchUpsert\", \"execute\" }",
              "return_type": "String[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies filter patterns for methods when the annotation is applied at the class level.",
              "contract": [
                "Specifies filter patterns for methods when the annotation is applied at the class level.",
                "</p> <p> This filter is ignored when the annotation is applied at the method level."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.SqlFragment",
          "name": "SqlFragment",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Defines a query template variable for dynamic query construction.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the name of the query template variable to be replaced.",
              "contract": [
                "If not specified (empty string), the parameter name will be used.",
                "<p> The value can be: </p> <ul> <li> A simple placeholder name (e.g., \"tableName\") </li> <li> A custom placeholder with default value syntax (e.g., \"{where -> WHERE active = true}\") </li> </ul> <p> Simple placeholder example: </p> <pre> {@code @Query(\"SELECT * FROM {schema}.{table} WHERE id = :id\") User findById( @SqlFragment(\"schema\") String schemaName, @SqlFragment(\"table\") String tableName, @Bind(\"id\") long id ); } </pre> <p> Custom placeholder with default: </p> <pre> {@code // Custom syntax allows for more complex replacements @Query(\"SELECT * FROM users {filter -> WHERE active = true}\") List<User> findUsers(@SqlFragment(\"{filter -> WHERE active = true}\") String customFilter); // Usage: findUsers(\"WHERE role = 'ADMIN'\"); // Replaces the entire {filter -> ...} block findUsers(null); // Uses the default \"WHERE active = true\" } </pre> <p> Using parameter name when value is empty: </p> <pre> {@code @Query(\"SELECT {columns} FROM users\") List<Map<String, Object>> findWithColumns(@SqlFragment String columns); // The parameter name \"columns\" is used as the placeholder name } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.SqlFragmentList",
          "name": "SqlFragmentList",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Defines a named query template variable from a collection or array parameter.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the name of the query template variable to be replaced.",
              "contract": [
                "If not specified (empty string), the parameter name will be used.",
                "<p> The variable should be referenced in the query template using curly braces: {@code {variableName}} </p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Explicit name @Query(\"SELECT {cols} FROM users\") List<User> findWithColumns(@SqlFragmentList(\"cols\") List<String> columnList); // Using parameter name (when value is not specified) @Query(\"SELECT {columns} FROM users\") List<User> findWithColumns(@SqlFragmentList List<String> columns); } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.SqlLogEnabled",
          "name": "SqlLogEnabled",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Controls SQL statement logging for DAO methods or classes.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean value() default true",
              "return_type": "boolean",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies whether SQL logging is enabled or disabled.",
              "contract": [
                "<p> When set to {@code true} (default), SQL statements will be logged.",
                "When set to {@code false} , SQL logging is disabled regardless of other settings."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "maxSqlLogLength",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int maxSqlLogLength() default JdbcUtil.DEFAULT_MAX_SQL_LOG_LENGTH",
              "return_type": "int",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the maximum length of SQL statements in logs.",
              "contract": [
                "<p> This is particularly useful when dealing with: </p> <ul> <li> Large INSERT statements with many values </li> <li> Complex queries with multiple joins </li> <li> Queries with large IN clauses </li> <li> Statements with embedded large text or binary data </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code @SqlLogEnabled(maxSqlLogLength = 500) void insertBatchData(List<Data> largeDataset); @SqlLogEnabled(maxSqlLogLength = 2048) // Allow longer logs for complex queries List<Report> generateComplexReport(); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "filter",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String[] filter() default { \".*\" }",
              "return_type": "String[]",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies filter patterns for methods when the annotation is applied at the class level.",
              "contract": [
                "Specifies filter patterns for methods when the annotation is applied at the class level.",
                "</p> <p> This filter is ignored when the annotation is applied at the method level."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.SqlMapper",
          "name": "SqlMapper",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Associates a DAO interface with an external SQL mapper XML file.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "value",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String value() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the path to the SQL mapper XML file.",
              "contract": [
                "The path is relative to the classpath root and should include the file extension.",
                "<p> If not specified (empty string), the default mapper file location will be used."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.SqlScript",
          "name": "SqlScript",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Marks a {@code static final String} field (typically inside a DAO interface's nested helper class) as an embeddable SQL script that can be referenced by {@code @Query(id = \"...\")} .",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "id",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "String id() default \"\"",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Supplies an optional identifier that overrides the annotated field name when the SQL is registered.",
              "contract": [
                "Supplies an optional identifier that overrides the annotated field name when the SQL is registered.",
                "When left empty the declaration name (for example {@code sql_listUserWithBiggerId} ) becomes the key, but setting a custom id makes it possible to share the same SQL across differently named constants or shorten the token referenced from {@link Query} ."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.annotation.Transactional",
          "name": "Transactional",
          "kind": "annotation",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Declares transaction boundaries for DAO methods.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [],
          "constructors": [],
          "methods": [
            {
              "name": "propagation",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Propagation propagation() default Propagation.REQUIRED",
              "return_type": "Propagation",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the transaction propagation behavior.",
              "contract": [
                "<p> Common propagation behaviors: </p> <ul> <li> {@link Propagation#REQUIRED} (default) - Join existing transaction or create new one </li> <li> {@link Propagation#REQUIRES_NEW} - Always create a new transaction </li> <li> {@link Propagation#SUPPORTS} - Use transaction if exists, otherwise non-transactional </li> <li> {@link Propagation#MANDATORY} - Must execute within existing transaction </li> <li> {@link Propagation#NOT_SUPPORTED} - Execute non-transactionally, suspend existing </li> <li> {@link Propagation#NEVER} - Execute non-transactionally, fail if transaction exists </li> </ul> <p> Example scenarios: </p> <pre> {@code // Main business operation - needs transaction @Transactional(propagation = Propagation.REQUIRED) void processOrder(Order order) { ..."
              ],
              "examples": [],
              "see_also": [
                "Propagation"
              ]
            },
            {
              "name": "isolation",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "IsolationLevel isolation() default IsolationLevel.DEFAULT",
              "return_type": "IsolationLevel",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Specifies the transaction isolation level.",
              "contract": [],
              "examples": [],
              "see_also": [
                "IsolationLevel"
              ]
            }
          ],
          "fields": []
        }
      ]
    },
    {
      "name": "com.landawn.abacus.jdbc.dao",
      "types": [
        {
          "fqn": "com.landawn.abacus.jdbc.dao.CrudDao",
          "name": "CrudDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "The CrudDao interface provides comprehensive CRUD (Create, Read, Update, Delete) operations for entity management.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "CrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "idExtractor",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"SameReturnValue\") @NonDBOperation default Jdbc.BiRowMapper<ID> idExtractor()",
              "return_type": "Jdbc.BiRowMapper<ID>",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Returns the functional interface of {@code Jdbc.BiRowMapper} that extracts the ID from a database row.",
              "contract": [
                "<p> Override this method to provide a custom ID extractor if the default behavior doesn't suit your needs."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "generateId",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation default ID generateId() throws SQLException, UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the operation is not supported (default behavior)"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is deprecated as ID generation should typically be handled by the database",
                "for_removal": false
              },
              "javadoc_summary": "Generates a new ID for entity insertion.",
              "contract": [
                "<p> This method should be overridden by implementations that support ID generation."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "ID insert(final T entityToInsert) throws SQLException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (must not be null)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs or the entity is null"
                }
              ],
              "javadoc_summary": "Inserts the specified entity into the database and returns the generated ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws SQLException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (must not be null)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement. If {@code null} or empty, all properties will be inserted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Inserts the specified entity with only the specified properties.",
              "contract": [
                "This is useful when you want to insert an entity with only certain fields populated."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "ID insert(final String namedInsertSql, final T entityToInsert) throws SQLException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity whose properties will be bound to the named parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Inserts an entity using a custom named SQL insert statement.",
              "contract": [
                "The SQL should use named parameters that match the entity's property names."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<ID> batchInsert(final Collection<? extends T> entities) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert of multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert of multiple entities with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert with only specified properties for all entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert with only specified properties and custom batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities whose properties will be bound to the named parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert using a custom named SQL statement with default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws SQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities whose properties will be bound to the named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert using a custom named SQL statement with specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalBoolean queryForBoolean(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalBoolean",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a boolean value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalBoolean if no record is found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean(\"isActive\", userId); if (isActive.isPresent() && isActive.getAsBoolean()) { System.out.println(\"User is active\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForBoolean()"
              ]
            },
            {
              "name": "queryForChar",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalChar queryForChar(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalChar",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a char value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalChar if no record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForChar()"
              ]
            },
            {
              "name": "queryForByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalByte queryForByte(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalByte",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalByte if no record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForByte()"
              ]
            },
            {
              "name": "queryForShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalShort queryForShort(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalShort",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a short value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalShort if no record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForShort()"
              ]
            },
            {
              "name": "queryForInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalInt queryForInt(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalInt",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for an integer value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalInt if no record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForInt()"
              ]
            },
            {
              "name": "queryForLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalLong queryForLong(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalLong",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a long value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalLong if no record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForLong()"
              ]
            },
            {
              "name": "queryForFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalFloat queryForFloat(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalFloat",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a float value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalFloat if no record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForFloat()"
              ]
            },
            {
              "name": "queryForDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalDouble queryForDouble(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "OptionalDouble",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a double value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalDouble if no record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForDouble()"
              ]
            },
            {
              "name": "queryForString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<String> queryForString(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "Nullable<String>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a String value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForString()"
              ]
            },
            {
              "name": "queryForDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "Nullable<java.sql.Date>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Date value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForDate()"
              ]
            },
            {
              "name": "queryForTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "Nullable<java.sql.Time>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Time value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForTime()"
              ]
            },
            {
              "name": "queryForTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "Nullable<java.sql.Timestamp>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Timestamp value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForTimestamp()"
              ]
            },
            {
              "name": "queryForBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<byte[]> queryForBytes(final String singleSelectPropName, final ID id) throws SQLException",
              "return_type": "Nullable<byte[]>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte array value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForBytes()"
              ]
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single value of the specified type from a property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForSingleResult(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single non-null value of the specified type from a property of the entity.",
              "contract": [
                "Returns an empty Optional if no record is found or if the value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForSingleNonNull(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the custom mapper to transform the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single non-null value using a custom row mapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForSingleNonNull(Class)"
              ]
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique single result of the specified type.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForUniqueResult(\"email\", userId, String.class); // Throws DuplicatedResultException if multiple records found } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForUniqueResult(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique non-null result of the specified type.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found.",
                "Returns empty Optional if no record found or value is {@code null} .",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Optional<String> email = userDao.queryForUniqueNonNull(\"email\", userId, String.class); email.ifPresent(e -> sendEmail(e)); // Throws DuplicatedResultException if multiple records found } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the custom mapper to transform the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique non-null result using a custom row mapper.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found."
              ],
              "examples": [],
              "see_also": [
                "Filters",
                "AbstractQuery#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> get(final ID id) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID.",
              "contract": [
                "Returns an Optional containing the entity if found, otherwise empty."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> get(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, excluding properties of joining entities. All properties will be selected if null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties populated.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "T gett(final ID id) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); if (user != null) { System.out.println(\"Found user: \" + user.getName()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "T gett(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, excluding properties of joining entities. All properties will be selected if null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.",
                "This is useful for performance optimization when you only need specific fields.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Only load id, name, and email fields User user = userDao.gett(userId, Arrays.asList(\"id\", \"name\", \"email\")); if (user != null) { System.out.println(\"User name: \" + user.getName()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<T> batchGet(final Collection<? extends ID> ids) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs using the default batch size.",
              "contract": [
                "The returned list may be smaller than the input ID collection if some entities are not found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<T> batchGet(final Collection<? extends ID> ids, final int batchSize) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, excluding properties of joining entities. All properties will be selected if null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with only selected properties populated.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final int batchSize) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, excluding properties of joining entities. All properties will be selected if null",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with only selected properties populated and custom batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean exists(final ID id) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to check for existence",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID exists in the database.",
              "contract": [
                "Checks if an entity with the specified ID exists in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(userId)) { System.out.println(\"User exists\"); } else { System.out.println(\"User not found\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#exists()"
              ]
            },
            {
              "name": "notExists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default boolean notExists(final ID id) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to check for non-existence",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID does not exist in the database.",
              "contract": [
                "Checks if an entity with the specified ID does not exist in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(userId)) { // Create new user } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#notExists()"
              ]
            },
            {
              "name": "count",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta int count(final Collection<? extends ID> ids) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Counts how many of the specified IDs exist in the database.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int update(final T entityToUpdate) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "the entity with updated values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates an existing entity in the database.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "the entity containing the values to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the property names to update. If {@code null} or empty, all properties will be updated",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates only specified properties of an existing entity.",
              "contract": [
                "This is useful when you want to update only certain fields."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int update(final String propName, final Object propValue, final ID id) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates a single property of an entity identified by ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int update(final Map<String, Object> updateProps, final ID id) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates multiple properties of an entity identified by ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int batchUpdate(final Collection<? extends T> entities) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch update of multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch update of multiple entities with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the property names to update for all entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch update of multiple entities updating only specified properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the property names to update for all entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch update of multiple entities updating only specified properties with custom batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default T upsert(final T entity) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.",
              "contract": [
                "Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.",
                "If an entity with the same ID exists, it will be updated; otherwise, a new entity will be inserted.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User(); user.setId(userId); user.setName(\"John Doe\"); user.setEmail(\"john@example.com\"); User savedUser = userDao.upsert(user); // Insert if new, update if exists } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T upsert(final T entity, final Condition cond) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to check if the entity exists",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs an upsert operation: inserts the entity if it doesn't exist based on the specified condition, otherwise updates the existing entity.",
              "contract": [
                "Performs an upsert operation: inserts the entity if it doesn't exist based on the specified condition, otherwise updates the existing entity."
              ],
              "examples": [],
              "see_also": [
                "Filters"
              ]
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<T> batchUpsert(final Collection<? extends T> entities) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch upsert of multiple entities using the default batch size.",
              "contract": [
                "Each entity will be inserted if new or updated if it already exists based on ID fields."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch upsert of multiple entities with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch upsert based on specified unique properties for matching.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch upsert based on specified unique properties with custom batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "refresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default boolean refresh(final T entity) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to refresh (must have ID populated)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes an entity by reloading all its properties from the database.",
              "contract": [
                "This is useful when you want to ensure an entity has the latest values from the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); if (userDao.refresh(user)) { System.out.println(\"User refreshed with latest data\"); } else { System.out.println(\"User no longer exists in database\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "refresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default boolean refresh(final T entity, final Collection<String> propNamesToRefresh) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to refresh (must have ID populated)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToRefresh",
                  "type": "Collection<String>",
                  "javadoc": "the properties to refresh from the database",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes specific properties of an entity from the database.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int batchRefresh(final Collection<? extends T> entities) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes multiple entities from the database using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int batchRefresh(final Collection<? extends T> entities, final int batchSize) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes multiple entities from the database with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToRefresh",
                  "type": "Collection<String>",
                  "javadoc": "the properties to refresh from the database",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes specific properties of multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh, final int batchSize) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToRefresh",
                  "type": "Collection<String>",
                  "javadoc": "the properties to refresh from the database",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes specific properties of multiple entities with a custom batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int delete(final T entity) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to delete (must have ID populated)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes an entity from the database.",
              "contract": [
                "The entity must have its ID field(s) populated.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); int deletedRows = userDao.delete(user); if (deletedRows > 0) { System.out.println(\"User deleted successfully\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int deleteById(final ID id) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes an entity by its ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code int deletedRows = userDao.deleteById(userId); if (deletedRows == 0) { System.out.println(\"User not found\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int batchDelete(final Collection<? extends T> entities) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch delete of multiple entities using the default batch size.",
              "contract": [
                "Each entity must have its ID field(s) populated."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int batchDelete(final Collection<? extends T> entities, final int batchSize) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch delete of multiple entities with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int batchDeleteByIds(final Collection<? extends ID> ids) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes multiple entities by their IDs using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes multiple entities by their IDs with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.CrudDaoL",
          "name": "CrudDaoL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A specialized CrudDao interface that uses {@code Long} as the ID type.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "CrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "queryForBoolean",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalBoolean queryForBoolean(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalBoolean",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a boolean value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalBoolean if no record is found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean(\"isActive\", 123L); if (isActive.isPresent() && isActive.getAsBoolean()) { System.out.println(\"User is active\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForChar",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalChar queryForChar(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalChar",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a char value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalChar if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForByte",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalByte queryForByte(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalByte",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalByte if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForShort",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalShort queryForShort(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalShort",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a short value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalShort if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForInt",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalInt queryForInt(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalInt",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for an integer value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalInt if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForLong",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalLong queryForLong(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalLong",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a long value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalLong if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForFloat",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalFloat queryForFloat(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalFloat",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a float value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalFloat if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDouble",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default OptionalDouble queryForDouble(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "OptionalDouble",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a double value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalDouble if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForString",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Nullable<String> queryForString(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "Nullable<String>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a String value from a single property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "Nullable<java.sql.Date>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Date value from a single property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTime",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "Nullable<java.sql.Time>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Time value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTimestamp",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "Nullable<java.sql.Timestamp>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Timestamp value from a single property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBytes",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Nullable<byte[]> queryForBytes(final String singleSelectPropName, final long id) throws SQLException",
              "return_type": "Nullable<byte[]>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte array value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single value of the specified type from a property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single non-null value of the specified type from a property of the entity.",
              "contract": [
                "Returns an empty Optional if no record is found or if the value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the custom mapper to transform the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single non-null value using a custom row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique single result of the specified type.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForUniqueResult(\"email\", 123L, String.class); // Throws DuplicatedResultException if multiple records found } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique non-null result of the specified type.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found.",
                "Returns empty Optional if no record found or value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the custom mapper to transform the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique non-null result using a custom row mapper.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> get(final long id) throws SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID.",
              "contract": [
                "Returns an Optional containing the entity if found, otherwise empty."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> get(final long id, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, excluding properties of joining entities. All properties will be selected if null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties populated.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default T gett(final long id) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L); if (user != null) { System.out.println(\"Found user: \" + user.getName()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default T gett(final long id, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, excluding properties of joining entities. All properties will be selected if null",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with only selected properties populated, returning {@code null} if not found.",
                "This is useful for performance optimization when you only need specific fields.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Only load id, name, email fields User user = userDao.gett(123L, Arrays.asList(\"id\", \"name\", \"email\")); if (user != null) { System.out.println(\"User name: \" + user.getName()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default boolean exists(final long id) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID to check for existence",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID exists in the database.",
              "contract": [
                "Checks if an entity with the specified ID exists in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(123L)) { System.out.println(\"User exists\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "notExists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default boolean notExists(final long id) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID to check for non-existence",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID does not exist in the database.",
              "contract": [
                "Checks if an entity with the specified ID does not exist in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(123L)) { // Create new user with this ID } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int update(final String propName, final Object propValue, final long id) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates a single property of an entity identified by ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int update(final Map<String, Object> updateProps, final long id) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates multiple properties of an entity identified by ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int deleteById(final long id) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes an entity by its ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code int deletedRows = userDao.deleteById(123L); if (deletedRows == 0) { System.out.println(\"User not found\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.CrudJoinEntityHelper",
          "name": "CrudJoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Interface for CRUD operations with automatic join entity loading support.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "CrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and loads the specified type of join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and optionally loads all join entities.",
              "contract": [
                "When includeAllJoinEntities is {@code true} , all fields annotated with @JoinedBy will be loaded."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties and loads the specified join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties and loads multiple types of join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and loads the specified type of join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID and loads the specified type of join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId, Order.class); if (user != null) { // Process user with orders loaded user.getOrders().forEach(order -> processOrder(order)); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId, true); if (user != null) { // All @JoinedBy fields are populated performCompleteUserAnalysis(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties and loads the specified join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with only selected properties and loads the specified join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with specific fields and orders User user = userDao.gett(userId, Arrays.asList(\"id\", \"name\", \"email\"), Order.class); if (user != null) { displayUserWithOrders(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties and loads multiple types of join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with only selected properties and loads multiple types of join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with selected properties and multiple relations User user = userDao.gett(userId, Arrays.asList(\"id\", \"name\", \"status\"), Arrays.asList(Order.class, UserProfile.class)); if (user != null) { processUserWithOrdersAndProfile(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with only selected properties and optionally loads all join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with only selected properties and optionally loads all join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with minimal fields and all relations User user = userDao.gett(userId, Arrays.asList(\"id\", \"name\", \"email\"), true); // Load all @JoinedBy fields if (user != null) { performFullUserAnalysis(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs and loads the specified type of join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of join entities to load for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with selected properties and loads the specified join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with selected properties and loads multiple types of join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with selected properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of join entities to load for each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with selected properties and loads the specified join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load for each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with selected properties and loads multiple types of join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final int batchSize) throws DuplicatedResultException, SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from each entity, excluding join entity properties. If {@code null} , all properties of the entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input {@code ids}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves multiple entities by their IDs with selected properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.CrudJoinEntityHelperL",
          "name": "CrudJoinEntityHelperL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A specialized interface for CRUD operations with join entity support that uses {@code Long} as the ID type.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "CrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and loads the specified join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with selected properties and loads the specified join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with selected properties and loads multiple join entity types.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with selected properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and loads the specified join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID and loads the specified join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L, Order.class); if (user != null) { System.out.println(\"User: \" + user.getName()); System.out.println(\"Orders: \" + user.getOrders().size()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID and optionally loads all join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L, true); if (user != null) { // All @JoinedBy annotated fields are loaded processUserWithAllRelations(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with selected properties and loads the specified join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with selected properties and loads the specified join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with minimal fields plus orders User user = userDao.gett(123L, Arrays.asList(\"id\", \"name\"), Order.class); if (user != null) { displayUserSummary(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with selected properties and loads multiple join entity types, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with selected properties and loads multiple join entity types, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with orders and addresses User user = userDao.gett(123L, {@code null}, Arrays.asList(Order.class, Address.class)); if (user != null) { processUserWithRelations(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default T gett(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with selected properties and optionally loads all join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with selected properties and optionally loads all join entities, returning {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with essential fields and all relations User user = userDao.gett(123L, Arrays.asList(\"id\", \"name\", \"status\"), true); if (user != null) { performCompleteUserAnalysis(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.Dao",
          "name": "Dao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "The {@code Dao} interface provides a comprehensive data access abstraction layer for database operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "Dao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "dataSource",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@NonDBOperation javax.sql.DataSource dataSource()",
              "return_type": "javax.sql.DataSource",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Retrieves the underlying data source used by this DAO for database connections.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "sqlMapper",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@NonDBOperation SQLMapper sqlMapper()",
              "return_type": "SQLMapper",
              "type_params": [],
              "params": [],
              "throws": [],
              "javadoc_summary": "Retrieves the {@code SQLMapper} instance configured for this DAO.",
              "contract": [
                "If no SQLMapper is configured, an empty SQLMapper instance will be returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "targetEntityClass",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal Class<T> targetEntityClass()",
              "return_type": "Class<T>",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the class object representing the entity type managed by this DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "targetTableName",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal String targetTableName()",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the name of the database table associated with the entity type.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "executor",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal Executor executor()",
              "return_type": "Executor",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the executor used for asynchronous operations.",
              "contract": [
                "This executor is used when async methods are called without specifying a custom executor."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncExecutor",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal AsyncExecutor asyncExecutor()",
              "return_type": "AsyncExecutor",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the async executor wrapper that provides enhanced async operation support.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a PreparedQuery for the specified SQL query string.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query, final boolean generateKeys) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to return generated keys, {@code false} otherwise",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a PreparedQuery with the option to generate keys for INSERT statements.",
              "contract": [
                "When generateKeys is {@code true} , auto-generated keys can be retrieved after execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query, final int[] returnColumnIndexes) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "array of column indexes to return as generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a PreparedQuery that will return specific columns as generated keys.",
              "contract": [
                "This is useful when you need to retrieve specific auto-generated column values."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQuery(final String query, final String[] returnColumnNames) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "array of column names to return as generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a PreparedQuery that will return specific named columns as generated keys.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQuery(final String sql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "function to create the PreparedStatement with custom options",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a PreparedQuery using a custom statement creator function.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQuery(final Condition cond) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a SELECT query based on the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Filters"
              ]
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQuery(final Collection<String> selectPropNames, final Condition cond) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names to select, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a SELECT query for specific columns based on the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQueryForLargeResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQueryForLargeResult(final String query) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a PreparedQuery optimized for queries that return large result sets.",
              "contract": [],
              "examples": [],
              "see_also": [
                "JdbcUtil#prepareNamedQueryForLargeResult(DataSource, String)"
              ]
            },
            {
              "name": "prepareQueryForLargeResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQueryForLargeResult(final Condition cond) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a SELECT query optimized for large result sets based on the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": [
                "JdbcUtil#prepareNamedQueryForLargeResult(DataSource, String)"
              ]
            },
            {
              "name": "prepareQueryForLargeResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default PreparedQuery prepareQueryForLargeResult(final Collection<String> selectPropNames, final Condition cond) throws SQLException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names to select, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a SELECT query for specific columns optimized for large result sets.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the named SQL query string with :paramName placeholders",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery for the specified named SQL query string.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final boolean generateKeys) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the named SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to return generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery with the option to generate keys for INSERT statements.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final int[] returnColumnIndexes) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the named SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "array of column indexes to return",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery that will return specific columns as generated keys.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final String[] returnColumnNames) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the named SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "array of column names to return",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery that will return specific named columns as generated keys.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final String namedQuery, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the named SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "function to create the PreparedStatement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery using a custom statement creator function.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedSql) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed named query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery from a pre-parsed SQL object.",
              "contract": [
                "This is more efficient when reusing the same query multiple times."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedSql, final boolean generateKeys) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed named query",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to return generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery from a pre-parsed SQL object with key generation option.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final int[] returnColumnIndexes) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed named query",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "array of column indexes to return",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery from a pre-parsed SQL with specific return columns by index.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final String[] returnColumnNames) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed named query",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "array of column names to return",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery from a pre-parsed SQL with specific return columns by name.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final ParsedSql namedSql, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed named query",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "function to create the PreparedStatement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery from a pre-parsed SQL with custom statement creation.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final Condition cond) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a named SELECT query based on the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQuery(final Collection<String> selectPropNames, final Condition cond) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names to select, or {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a named SELECT query for specific columns based on the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQueryForLargeResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final String namedQuery) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the named SQL query string",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery optimized for large result sets.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQueryForLargeResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final ParsedSql namedSql) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedSql",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed named query",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a NamedQuery from pre-parsed SQL optimized for large result sets.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQueryForLargeResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final Condition cond) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a named SELECT query optimized for large result sets based on condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQueryForLargeResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default NamedQuery prepareNamedQueryForLargeResult(final Collection<String> selectPropNames, final Condition cond) throws SQLException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names to select, or {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for the WHERE clause",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a named SELECT query for specific columns optimized for large result sets.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareCallableQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default CallableQuery prepareCallableQuery(final String query) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the stored procedure call string",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a CallableQuery for executing stored procedures or functions.",
              "contract": [
                "The query should use the JDBC escape syntax: {call procedure_name(?, ?)} <p> <b> Usage Examples: </b> </p> <pre> {@code CallableQuery query = dao.prepareCallableQuery(\"{call get_user_count(?)}\"); query.registerOutParameter(1, Types.INTEGER); query.execute(); int count = query.getInt(1); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareCallableQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default CallableQuery prepareCallableQuery(final String sql, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws SQLException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "sql",
                  "type": "String",
                  "javadoc": "the stored procedure call string",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, CallableStatement, SQLException>",
                  "javadoc": "function to create the CallableStatement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Creates a CallableQuery using a custom statement creator.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void save(final T entityToSave) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to insert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Saves (inserts) the specified entity to the database.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void save(final T entityToSave, final Collection<String> propNamesToSave) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Saves (inserts) the specified entity with only the specified properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void save(final String namedInsertSql, final T entityToSave) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named INSERT SQL statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity providing the parameter values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Saves (inserts) the entity using a custom named INSERT SQL statement.",
              "contract": [
                "The SQL should use named parameters that match the entity properties."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void batchSave(final Collection<? extends T> entitiesToSave) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves (inserts) multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "#batchSave(Collection, int)"
              ]
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves (inserts) multiple entities with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves entities with only the specified properties using default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves entities with only the specified properties and custom batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named INSERT SQL statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities providing parameter values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves entities using a custom named INSERT SQL with default batch size.",
              "contract": [
                "The SQL should use named parameters matching entity properties."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named INSERT SQL statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities providing parameter values",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves entities using a custom named INSERT SQL with specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "boolean exists(final Condition cond) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to check",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if at least one record exists that matches the specified condition.",
              "contract": [
                "Checks if at least one record exists that matches the specified condition.",
                "More efficient than counting when you only need to know if records exist.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code boolean hasActiveUsers = dao.exists(Filters.eq(\"status\", \"ACTIVE\")); if (hasActiveUsers) { // Process active users } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "Filters"
              ]
            },
            {
              "name": "notExists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default boolean notExists(final Condition cond) throws SQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to check",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if no records exist that match the specified condition.",
              "contract": [
                "Checks if no records exist that match the specified condition.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (dao.notExists(Filters.eq(\"email\", email))) { // Email is available, proceed with registration } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "count",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int count(final Condition cond) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition for counting",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Counts the number of records that match the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Optional<T> findFirst(final Condition cond) throws SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first record that matches the specified condition.",
              "contract": [
                "Returns an Optional containing the entity if found, empty otherwise."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findFirst(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds the first record matching the condition and maps it using the provided mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findFirst(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the bi-function to map the result row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds the first record matching the condition and maps it using a bi-function mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Optional<T> findFirst(final Collection<String> selectPropNames, final Condition cond) throws SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first record with only specified properties matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds the first record with specified properties and maps the result.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the bi-function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds the first record with specified properties using a bi-function mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Optional<T> findOnlyOne(final Condition cond) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record matching the condition, throwing exception if multiple found.",
              "contract": [
                "Finds exactly one record matching the condition, throwing exception if multiple found.",
                "Use this when you expect exactly zero or one result.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Optional<User> user = dao.findOnlyOne(Filters.eq(\"email\", \"john@example.com\")); // Throws DuplicatedResultException if multiple users have this email } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds exactly one record and maps it, throwing exception if multiple found.",
              "contract": [
                "Finds exactly one record and maps it, throwing exception if multiple found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the bi-function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds exactly one record using a bi-function mapper, throwing if multiple found.",
              "contract": [
                "Finds exactly one record using a bi-function mapper, throwing if multiple found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Condition cond) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record with specified properties, throwing if multiple found.",
              "contract": [
                "Finds exactly one record with specified properties, throwing if multiple found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds exactly one record with specified properties and maps it.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, SQLException, IllegalArgumentException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the bi-function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.IllegalArgumentException",
                  "condition": "if rowMapper returns null"
                }
              ],
              "javadoc_summary": "Finds exactly one record with specified properties using a bi-function mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalBoolean queryForBoolean(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalBoolean",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a boolean value from a single column.",
              "contract": [
                "Returns an OptionalBoolean containing the value if found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = dao.queryForBoolean(\"is_active\", Filters.eq(\"id\", 123)); if (isActive.orElse(false)) { // User is active } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForChar",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalChar queryForChar(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalChar",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a char value from a single column.",
              "contract": [
                "Returns an OptionalChar containing the value if found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalChar grade = dao.queryForChar(\"grade\", Filters.eq(\"student_id\", 123)); if (grade.isPresent()) { System.out.println(\"Grade: \" + grade.getAsChar()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalByte queryForByte(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalByte",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte value from a single column.",
              "contract": [
                "Returns an OptionalByte containing the value if found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalShort queryForShort(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalShort",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a short value from a single column.",
              "contract": [
                "Returns an OptionalShort containing the value if found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalInt queryForInt(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalInt",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for an integer value from a single column.",
              "contract": [
                "Returns an OptionalInt containing the value if found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalLong queryForLong(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalLong",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a long value from a single column.",
              "contract": [
                "Returns an OptionalLong containing the value if found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalFloat queryForFloat(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalFloat",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a float value from a single column.",
              "contract": [
                "Returns an OptionalFloat containing the value if found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "OptionalDouble queryForDouble(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "OptionalDouble",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a double value from a single column.",
              "contract": [
                "Returns an OptionalDouble containing the value if found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<String> queryForString(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "Nullable<String>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a String value from a single column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "Nullable<java.sql.Date>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Date value from a single column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "Nullable<java.sql.Time>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Time value from a single column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "Nullable<java.sql.Timestamp>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Timestamp value from a single column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Nullable<byte[]> queryForBytes(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "Nullable<byte[]>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte array from a single column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single value of the specified type from a column.",
              "contract": [],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleResult(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single non-null value of the specified type.",
              "contract": [
                "Returns an Optional, empty if no value found or if the value is {@code null} ."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleNonNull(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single value using a custom row mapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleNonNull(Type)"
              ]
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one row matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique single value, throwing if multiple rows found.",
              "contract": [
                "Queries for a unique single value, throwing if multiple rows found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> uniqueEmail = dao.queryForUniqueResult( \"email\", Filters.eq(\"username\", \"john_doe\"), String.class ); // Throws DuplicatedResultException if multiple users have this username } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueResult(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one row matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique non-null single value, throwing if multiple rows found.",
              "contract": [
                "Queries for a unique non-null single value, throwing if multiple rows found."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the function to map the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one row matches"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique value using a custom row mapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueNonNull(Type)"
              ]
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Dataset query(final Condition cond) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the results as a Dataset.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "Dataset query(final Collection<String> selectPropNames, final Condition cond) throws SQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query for specific columns and returns results as a Dataset.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> R query(final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "function to process the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and processes results with a custom result extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "function to process the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query for specific columns with a custom result extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> R query(final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "bi-function to process the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query with a bi-function result extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws SQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "bi-function to process the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query for specific columns with a bi-function result extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "List<T> list(final Condition cond) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of all entities matching the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of results mapped by the provided row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of results mapped by a bi-function row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list of results mapped by the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "bi-predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list using bi-function filter and mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "List<T> list(final Collection<String> selectPropNames, final Condition cond) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of entities with only the specified properties populated.",
              "contract": [
                "More efficient than loading full entities when only specific fields are needed."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of selected properties mapped by the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of selected properties mapped by a bi-function mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list of selected properties mapped by the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "<R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "bi-predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list with bi-function filter and mapper for selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default <R> List<R> list(final String singleSelectPropName, final Condition cond) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of values from a single property/column.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map the property value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of single property values mapped by the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws SQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter values",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map filtered values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list of single property values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation Stream<T> stream(final Condition cond)",
              "return_type": "Stream<T>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream of entities matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": [
                "Filters"
              ]
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream with custom row mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream with bi-function row mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a filtered lazy Stream with row mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "bi-predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a filtered lazy Stream with bi-function filter and mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation Stream<T> stream(final Collection<String> selectPropNames, final Condition cond)",
              "return_type": "Stream<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream of entities with selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream of selected properties with row mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream with bi-function mapping for selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a filtered lazy Stream of selected properties with mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@LazyEvaluation <R> Stream<R> stream(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "bi-predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "bi-function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a filtered lazy Stream with maximum flexibility.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@LazyEvaluation default <R> Stream<R> stream(final String singleSelectPropName, final Condition cond)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream of values from a single property.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@LazyEvaluation default <R> Stream<R> stream(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map property values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a lazy Stream of single property values with custom mapping.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@LazyEvaluation default <R> Stream<R> stream(final String singleSelectPropName, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter values",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "function to map filtered values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a filtered lazy Stream of single property values.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "paginate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @LazyEvaluation Stream<Dataset> paginate(final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, Dataset> paramSetter)",
              "return_type": "Stream<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition with required orderBy clause",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of records per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super PreparedQuery, Dataset>",
                  "javadoc": "function to set parameters for next page based on previous results",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a paginated Stream of query results as Dataset pages.",
              "contract": [
                "The condition must include orderBy for consistent pagination.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Stream<Dataset> pages = dao.paginate( Filters.criteria().where(Filters.gt(\"id\", 0)).orderBy(\"id\"), 100, (query, lastPageResult) -> { if (lastPageResult != {@code null} && lastPageResult.size() > 0) { long lastId = lastPageResult.getLong(lastPageResult.size() - 1, \"id\"); query.setLong(1, lastId); } } ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "paginate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @LazyEvaluation <R> Stream<R> paginate(final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.ResultExtractor<? extends R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition with required orderBy clause",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of records per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super PreparedQuery, R>",
                  "javadoc": "function to set parameters for next page",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "function to process each page's ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a paginated Stream with custom result extraction.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "paginate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @LazyEvaluation <R> Stream<R> paginate(final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.BiResultExtractor<? extends R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition with required orderBy clause",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of records per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super PreparedQuery, R>",
                  "javadoc": "function to set parameters for next page",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "bi-function to process each page",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a paginated Stream with bi-function result extraction.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "paginate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @LazyEvaluation Stream<Dataset> paginate(final Collection<String> selectPropNames, final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, Dataset> paramSetter)",
              "return_type": "Stream<Dataset>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition with required orderBy clause",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of records per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super PreparedQuery, Dataset>",
                  "javadoc": "function to set parameters for next page",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a paginated Stream with selected properties as Dataset pages.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "paginate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @LazyEvaluation <R> Stream<R> paginate(final Collection<String> selectPropNames, final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.ResultExtractor<? extends R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition with required orderBy clause",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of records per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super PreparedQuery, R>",
                  "javadoc": "function to set parameters for next page",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "function to process each page",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a paginated Stream of selected properties with custom extraction.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "paginate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @LazyEvaluation <R> Stream<R> paginate(final Collection<String> selectPropNames, final Condition cond, final int pageSize, final Jdbc.BiParametersSetter<? super PreparedQuery, R> paramSetter, final Jdbc.BiResultExtractor<? extends R> resultExtractor)",
              "return_type": "Stream<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition with required orderBy clause",
                  "nullability": "unspecified"
                },
                {
                  "name": "pageSize",
                  "type": "int",
                  "javadoc": "the number of records per page",
                  "nullability": "unspecified"
                },
                {
                  "name": "paramSetter",
                  "type": "Jdbc.BiParametersSetter<? super PreparedQuery, R>",
                  "javadoc": "function to set parameters for next page",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "bi-function to process each page",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Returns a paginated Stream with bi-function extraction for selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Condition cond, final Jdbc.RowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "consumer to process each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over query results, applying the row consumer to each row.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "bi-consumer to process each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over results with a bi-consumer receiving ResultSet and column labels.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "consumer for filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over filtered results, processing only rows that pass the filter.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "bi-predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "bi-consumer for filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over filtered results with bi-function filter and consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "consumer to process each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over selected properties, applying the consumer to each row.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "bi-consumer to process each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over selected properties with a bi-consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "consumer for filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over filtered results of selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, {@code null} for all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "bi-predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "bi-consumer for filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over filtered results with maximum flexibility.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "foreach",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void foreach(final Collection<String> selectPropNames, final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "consumer that receives reusable row array",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over results using a disposable object array consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "foreach",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void foreach(final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the search condition",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "consumer that receives reusable row array",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates over all results using a disposable object array consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int update(final String propName, final Object propValue, final Condition cond) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates a single property for all records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int update(final Map<String, Object> updateProps, final Condition cond) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "map of property names to new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates multiple properties for all records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int update(final T entity, final Condition cond) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing update values",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates records matching the condition with all non-null properties from the entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing update values",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the property names to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates records with only the specified properties from the entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "property names that uniquely identify the record",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs an upsert operation - inserts if not exists, updates if exists.",
              "contract": [
                "Performs an upsert operation - inserts if not exists, updates if exists.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User(\"john@example.com\", \"John Doe\"); User saved = dao.upsert(user, Arrays.asList(\"email\")); // Inserts if email doesn't exist, updates if it does } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default T upsert(final T entity, final Condition cond) throws SQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "condition to check for existence",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs an upsert operation based on a custom condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int delete(final Condition cond) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records for deletion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all records matching the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @NonDBOperation default <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super TD, ? extends R, SQLException> sqlAction)",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Function<? super TD, ? extends R, SQLException>",
                  "javadoc": "function that performs database operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Executes an asynchronous database operation using the default executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncCall",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default <R> ContinuableFuture<R> asyncCall(final Throwables.Function<? super TD, ? extends R, SQLException> sqlAction, final Executor executor)",
              "return_type": "ContinuableFuture<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Function<? super TD, ? extends R, SQLException>",
                  "javadoc": "function that performs database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to run the operation",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Executes an asynchronous database operation using the specified executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @NonDBOperation default ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super TD, SQLException> sqlAction)",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Consumer<? super TD, SQLException>",
                  "javadoc": "consumer that performs database operations",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Executes an asynchronous database operation without return value using default executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "asyncRun",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation default ContinuableFuture<Void> asyncRun(final Throwables.Consumer<? super TD, SQLException> sqlAction, final Executor executor)",
              "return_type": "ContinuableFuture<Void>",
              "type_params": [],
              "params": [
                {
                  "name": "sqlAction",
                  "type": "Throwables.Consumer<? super TD, SQLException>",
                  "javadoc": "consumer that performs database operations",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to run the operation",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Executes an asynchronous database operation without return value using specified executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.JoinEntityHelper",
          "name": "JoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Interface for handling join entities in database operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "Dao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "targetDaoInterface",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal Class<TD> targetDaoInterface()",
              "return_type": "Class<TD>",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only - not intended for public use",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the class type of the target DAO interface.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "targetEntityClass",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal Class<T> targetEntityClass()",
              "return_type": "Class<T>",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only - not intended for public use",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the class type of the target entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "targetTableName",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal String targetTableName()",
              "return_type": "String",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only - not intended for public use",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the name of the target table.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "executor",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Internal Executor executor()",
              "return_type": "Executor",
              "type_params": [],
              "params": [],
              "throws": [],
              "deprecated": {
                "is_deprecated": true,
                "message": "Internal use only - not intended for public use",
                "for_removal": false
              },
              "javadoc_summary": "Retrieves the executor for executing tasks in parallel.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> findFirst(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first entity that matches the specified condition and loads the specified join entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> findFirst(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first entity that matches the specified condition and loads multiple types of join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> findFirst(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first entity that matches the specified condition, optionally loading all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified condition"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the only entity that matches the specified condition and loads the specified join entity.",
              "contract": [
                "Throws an exception if more than one entity matches the condition."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified condition"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the only entity that matches the specified condition and loads multiple types of join entities.",
              "contract": [
                "Throws an exception if more than one entity matches the condition."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws DuplicatedResultException, SQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified condition"
                },
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the only entity that matches the specified condition, optionally loading all join entities.",
              "contract": [
                "Throws an exception if more than one entity matches the condition."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> list(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves a list of entities that match the specified condition and loads the specified join entity for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> list(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves a list of entities that match the specified condition and loads multiple types of join entities for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default List<T> list(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws SQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves a list of entities that match the specified condition, optionally loading all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Stream<T> stream(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond)",
              "return_type": "Stream<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Streams entities that match the specified condition and loads the specified join entity for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Stream<T> stream(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond)",
              "return_type": "Stream<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Streams entities that match the specified condition and loads multiple types of join entities for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "stream",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default Stream<T> stream(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond)",
              "return_type": "Stream<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [],
              "javadoc_summary": "Streams entities that match the specified condition, optionally loading all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final T entity, final Class<?> joinEntityClass) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a single entity.",
              "contract": [
                "If multiple properties in the entity are of the specified type, all will be loaded."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a single entity with specific property selection.",
              "contract": [
                "If multiple properties in the entity are of the specified type, all will be loaded."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a collection of entities.",
              "contract": [
                "If multiple properties in the entities are of the specified type, all will be loaded."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a collection of entities with specific property selection.",
              "contract": [
                "If multiple properties in the entities are of the specified type, all will be loaded."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final T entity, final String joinEntityPropName) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a single entity by property name.",
              "contract": [
                "The property name must correspond to a field annotated with {@code @JoinedBy} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void loadJoinEntities(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities. Must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. This parameter is useful for performance optimization when only specific fields are needed",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a single entity by property name with specific property selection.",
              "contract": [
                "The property name must correspond to a field annotated with {@code @JoinedBy} .",
                "This is an abstract method that must be implemented by concrete DAO classes.",
                "</p> <p> The implementation should handle both collection-type properties (List, Set, etc.) and single-entity properties."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a collection of entities by property name.",
              "contract": [
                "The property name must correspond to a field annotated with {@code @JoinedBy} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities. Can be empty but not {@code null} . If empty, this method returns immediately",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. Specifying only needed properties can significantly improve query performance and reduce memory usage",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a collection of entities by property name with specific property selection.",
              "contract": [
                "The property name must correspond to a field annotated with {@code @JoinedBy} .",
                "This is an abstract method that must be implemented by concrete DAO classes."
              ],
              "performance": "</p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, this method executes O(1) queries instead of O(N) </li> <li> Large collections may be automatically batched to prevent excessive memory usage </li> <li> Selecting fewer properties via {@code selectPropNames} can significantly improve performance </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = userDao.list(Filters.between(\"createdDate\", startDate, endDate)); // Load only essential fields from addresses userDao.loadJoinEntities(users, \"addresses\", Arrays.asList(\"city\", \"country\")); // Load all fields from orders for multiple users userDao.loadJoinEntities(users, \"orders\", null); } </pre>",
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a single entity by property names.",
              "contract": [
                "Each property name must correspond to a field annotated with {@code @JoinedBy} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a single entity with optional parallel execution.",
              "contract": [
                "When parallel execution is enabled, join entities are loaded concurrently for better performance."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a single entity using a custom executor for parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a collection of entities by property names.",
              "contract": [
                "Each property name must correspond to a field annotated with {@code @JoinedBy} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a collection of entities with optional parallel execution.",
              "contract": [
                "When parallel execution is enabled, different join entity types are loaded concurrently."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a collection of entities using a custom executor for parallel execution.",
              "contract": [
                "This method provides fine-grained control over the threading behavior when loading multiple join entity types."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default void loadAllJoinEntities(final T entity) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load all join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadAllJoinEntities(final T entity, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity with optional parallel execution.",
              "contract": [
                "When parallel execution is enabled, all join entities are loaded concurrently for better performance."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadAllJoinEntities(final T entity, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity using a custom executor for parallel execution.",
              "contract": [
                "This method provides fine-grained control over the threading behavior when loading all join entities."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default void loadAllJoinEntities(final Collection<T> entities) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load all join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a collection of entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a collection of entities with optional parallel execution.",
              "contract": [
                "When parallel execution is enabled, different join entity types are loaded concurrently."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadAllJoinEntities(final Collection<T> entities, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a collection of entities using a custom executor for parallel execution.",
              "contract": [
                "This method provides fine-grained control over the threading behavior when loading all join entities."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a single entity only if they are currently {@code null} .",
              "contract": [
                "Loads join entities of the specified type for a single entity only if they are currently {@code null} .",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load orders only if not already loaded userDao.loadJoinEntitiesIfNull(user, Order.class); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a single entity only if they are currently {@code null} , with specific property selection.",
              "contract": [
                "Loads join entities of the specified type for a single entity only if they are currently {@code null} , with specific property selection.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load addresses with specific fields only if not already loaded userDao.loadJoinEntitiesIfNull(user, Address.class, Arrays.asList(\"street\", \"city\")); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a collection of entities only if they are currently {@code null} .",
              "contract": [
                "Loads join entities of the specified type for a collection of entities only if they are currently {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified type for a collection of entities only if they are currently {@code null} , with specific property selection.",
              "contract": [
                "Loads join entities of the specified type for a collection of entities only if they are currently {@code null} , with specific property selection."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a single entity by property name only if the property is currently {@code null} .",
              "contract": [
                "Loads join entities for a single entity by property name only if the property is currently {@code null} .",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load orders only if not already loaded userDao.loadJoinEntitiesIfNull(user, \"orders\"); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a single entity by property name only if the property is currently {@code null} , with specific property selection.",
              "contract": [
                "Loads join entities for a single entity by property name only if the property is currently {@code null} , with specific property selection.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Load addresses with specific fields only if not already loaded userDao.loadJoinEntitiesIfNull(user, \"addresses\", Arrays.asList(\"city\", \"country\")); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a collection of entities by property name only if the property is currently {@code null} .",
              "contract": [
                "Loads join entities for a collection of entities by property name only if the property is currently {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a collection of entities by property name only if the property is currently {@code null} , with specific property selection.",
              "contract": [
                "Loads join entities for a collection of entities by property name only if the property is currently {@code null} , with specific property selection."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a single entity by property names only if they are currently {@code null} .",
              "contract": [
                "Loads multiple join entities for a single entity by property names only if they are currently {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a single entity only if they are currently {@code null} , with optional parallel execution.",
              "contract": [
                "Loads multiple join entities for a single entity only if they are currently {@code null} , with optional parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution.",
              "contract": [
                "Loads multiple join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a collection of entities by property names only if they are currently {@code null} .",
              "contract": [
                "Loads multiple join entities for a collection of entities by property names only if they are currently {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution.",
              "contract": [
                "Loads multiple join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution.",
              "contract": [
                "Loads multiple join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default void loadJoinEntitiesIfNull(final T entity) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity only if they are currently {@code null} .",
              "contract": [
                "Loads all join entities for a single entity only if they are currently {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntitiesIfNull(final T entity, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity only if they are currently {@code null} , with optional parallel execution.",
              "contract": [
                "Loads all join entities for a single entity only if they are currently {@code null} , with optional parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntitiesIfNull(final T entity, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution.",
              "contract": [
                "Loads all join entities for a single entity only if they are currently {@code null} , using a custom executor for parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default void loadJoinEntitiesIfNull(final Collection<T> entities) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a collection of entities only if they are currently {@code null} .",
              "contract": [
                "Loads all join entities for a collection of entities only if they are currently {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final boolean inParallel) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be loaded in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution.",
              "contract": [
                "Loads all join entities for a collection of entities only if they are currently {@code null} , with optional parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta default void loadJoinEntitiesIfNull(final Collection<T> entities, final Executor executor) throws SQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to load join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel loading",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution.",
              "contract": [
                "Loads all join entities for a collection of entities only if they are currently {@code null} , using a custom executor for parallel execution."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities of the specified type for a single entity.",
              "contract": [
                "This operation is performed within a transaction if multiple join properties exist for the specified type."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities of the specified type for a collection of entities.",
              "contract": [
                "This operation is performed within a transaction if multiple join properties exist for the specified type."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int deleteJoinEntities(final T entity, final String joinEntityPropName) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete join entities. Must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes join entities for a single entity by property name.",
              "contract": [
                "The property name must correspond to a field annotated with {@code @JoinedBy} .",
                "This is an abstract method that must be implemented by concrete DAO classes."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete join entities. Can be empty but not {@code null} . If empty, this method returns 0 immediately",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes join entities for a collection of entities by property name.",
              "contract": [
                "The property name must correspond to a field annotated with {@code @JoinedBy} .",
                "This is an abstract method that must be implemented by concrete DAO classes."
              ],
              "performance": "</p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, executes O(1) or O(N/batch_size) DELETE statements instead of O(N) </li> <li> Much more efficient than deleting join entities one parent at a time </li> <li> The actual number of deleted records may be less than or greater than the number of parent entities </li> </ul> <p> Important notes: </p> <ul> <li> This operation does NOT modify the in-memory join properties of the entities </li> <li> All deletions are permanent unless executed within a transaction </li> <li> For transactional deletion of multiple properties, use {@link #deleteJoinEntities(Collection, Collection)} </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = userDao.list(Filters.in(\"id\", userIdsToClean)); // Delete all reviews for these users int deletedCount = userDao.deleteJoinEntities(users, \"reviews\"); System.out.println(\"Deleted \" + deletedCount + \" reviews for \" + users.size() + \" users\"); } </pre>",
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes multiple join entities for a single entity by property names.",
              "contract": [
                "This operation is performed within a transaction when multiple properties are specified."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be deleted in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes multiple join entities for a single entity with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel deletion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes multiple join entities for a single entity using a custom executor for parallel execution.",
              "contract": [
                "Note: This operation cannot be completed within a single transaction when executed in multiple threads."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes multiple join entities for a collection of entities by property names.",
              "contract": [
                "This operation is performed within a transaction when multiple properties are specified."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be deleted in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes multiple join entities for a collection of entities with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel deletion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes multiple join entities for a collection of entities using a custom executor for parallel execution.",
              "contract": [
                "Note: This operation cannot be completed within a single transaction when executed in multiple threads."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default int deleteAllJoinEntities(final T entity) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete all join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities for a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be deleted in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for a single entity with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteAllJoinEntities(final T entity, final Executor executor) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity for which to delete all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel deletion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for a single entity using a custom executor for parallel execution.",
              "contract": [
                "Note: This operation cannot be completed within a single transaction when executed in multiple threads."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") default int deleteAllJoinEntities(final Collection<T> entities) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete all join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities for a collection of entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , join entities will be deleted in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for a collection of entities with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Beta default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws SQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities for which to delete all join entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the executor to use for parallel deletion",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for a collection of entities using a custom executor for parallel execution.",
              "contract": [
                "Note: This operation cannot be completed within a single transaction when executed in multiple threads."
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.NoUpdateCrudDao",
          "name": "NoUpdateCrudDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A CRUD Data Access Object interface that disables update and delete operations while allowing read and insert operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "NoUpdateCrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entityToUpdate) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "the entity with updated values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "the entity containing the values to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the property names to update. If {@code null} or empty, all properties will be updated",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default int update(final String propName, final Object propValue, final ID id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final Map<String, Object> updateProps, final ID id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the property names to update for all entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the property names to update for all entities",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to upsert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upserts are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to check if the entity exists",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upserts are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upserts are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upserts are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upserts are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upserts are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upserts are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int delete(final T entity) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to delete (must have ID populated)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as deletes are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteById(final ID id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as deletes are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDelete(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as deletes are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDelete(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as deletes are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as deletes are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of IDs to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of IDs to process in each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as deletes are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.NoUpdateCrudDaoL",
          "name": "NoUpdateCrudDaoL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A CRUD Data Access Object interface for entities with {@code Long} type primary keys that disables update and delete operations while allowing read and insert operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "NoUpdateCrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final String propName, final Object propValue, final long id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final Map<String, Object> updateProps, final long id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as updates are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteById(final long id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as deletes are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.NoUpdateDao",
          "name": "NoUpdateDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "This interface extends the base Dao interface but disables update and delete operations while allowing read and insert operations to ensure data integrity in scenarios where modifications to existing records should be prevented.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "NoUpdateDao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query) throws SQLException, UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string to prepare (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a SQL query for execution.",
              "contract": [
                "<p> The query string should be a valid SQL SELECT or INSERT statement."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final boolean generateKeys) throws SQLException, UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string to prepare (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to enable retrieval of auto-generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a SQL query with support for auto-generated keys retrieval.",
              "contract": [
                "<p> When {@code generateKeys} is {@code true} , the prepared statement will be configured to return auto-generated keys which can be retrieved after executing an INSERT.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Row generated = dao.prepareQuery(\"INSERT INTO users (name, email) VALUES (?, ?)\", true) .setString(1, \"John Doe\") .setString(2, \"john@example.com\") .insert() .orElse(null); if (generated != null) { long generatedId = generated.getLong(1); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final int[] returnColumnIndexes) throws SQLException, UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string to prepare (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "an array of column indexes indicating the columns that should be returned from the inserted row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a SQL query with specific column indexes for auto-generated key retrieval.",
              "contract": [
                "This method allows precise control over which auto-generated columns should be returned after an INSERT operation by specifying their column indexes.",
                "This is useful when your table has multiple auto-generated columns and you only need specific ones.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Retrieve only the first and third auto-generated columns Row generated = dao.prepareQuery(\"INSERT INTO orders (customer_id, total) VALUES (?, ?)\", new int[] {1, 3}) .setLong(1, customerId) .setBigDecimal(2, orderTotal) .insert() .orElse(null); if (generated != null) { long firstColumn = generated.getLong(1); BigDecimal thirdColumn = generated.getBigDecimal(2); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final String[] returnColumnNames) throws SQLException, UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string to prepare (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "an array of column names indicating the columns that should be returned from the inserted row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a SQL query with specific column names for auto-generated key retrieval.",
              "contract": [
                "This method provides the most readable way to specify which auto-generated columns should be returned after an INSERT operation by using column names instead of indexes.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Row generated = dao.prepareQuery(\"INSERT INTO users (name, email) VALUES (?, ?)\", new String[] {\"id\", \"created_timestamp\"}) .setString(1, \"Jane Doe\") .setString(2, \"jane@example.com\") .insert() .orElse(null); if (generated != null) { long id = generated.getLong(\"id\"); Timestamp created = generated.getTimestamp(\"created_timestamp\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "custom statement creator function",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as custom statement creation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a named parameter SQL query for execution.",
              "contract": [
                "<p> Named parameters can appear multiple times in the query and will all be set to the same value when the parameter is bound."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final boolean generateKeys) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to enable retrieval of auto-generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a named parameter SQL query with support for auto-generated keys retrieval.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final int[] returnColumnIndexes) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "an array of column indexes for generated key retrieval",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a named parameter SQL query with specific column indexes for auto-generated key retrieval.",
              "contract": [
                "This method combines named parameters with precise control over which auto-generated columns should be returned by their index positions."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final String[] returnColumnNames) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters (must be SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "an array of column names for generated key retrieval",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a named parameter SQL query with specific column names for auto-generated key retrieval.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "custom statement creator function",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as custom statement creation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed SQL query object (must represent SELECT or INSERT)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a named query using a pre-parsed SQL object.",
              "contract": [
                "This method is useful when you have already parsed a named query and want to avoid the overhead of parsing it again."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final boolean generateKeys) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed SQL query object (must represent SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to enable retrieval of auto-generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a parsed named query with support for auto-generated keys retrieval.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final int[] returnColumnIndexes) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed SQL query object (must represent SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "an array of column indexes for generated key retrieval",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a parsed named query with specific column indexes for auto-generated key retrieval.",
              "contract": [
                "This method combines pre-parsed SQL efficiency with precise control over which auto-generated columns should be returned."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final String[] returnColumnNames) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed SQL query object (must represent SELECT or INSERT)",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "an array of column names for generated key retrieval",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the query is not a SELECT or INSERT statement"
                }
              ],
              "javadoc_summary": "Prepares a parsed named query with specific column names for auto-generated key retrieval.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final Throwables.BiFunction<Connection, String, PreparedStatement, SQLException> stmtCreator) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed SQL query object",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, PreparedStatement, SQLException>",
                  "javadoc": "custom statement creator function",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as custom statement creation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareCallableQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default CallableQuery prepareCallableQuery(final String query) throws UnsupportedOperationException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the stored procedure call string",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as callable query operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareCallableQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default CallableQuery prepareCallableQuery(final String query, final Throwables.BiFunction<Connection, String, CallableStatement, SQLException> stmtCreator) throws UnsupportedOperationException",
              "return_type": "CallableQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the stored procedure call string",
                  "nullability": "unspecified"
                },
                {
                  "name": "stmtCreator",
                  "type": "Throwables.BiFunction<Connection, String, CallableStatement, SQLException>",
                  "javadoc": "custom statement creator function",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as callable query operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default int update(final String propName, final Object propValue, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the name of the property to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to identify records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final Map<String, Object> updateProps, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to identify records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entity, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing values to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to identify records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing values to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "collection of property names to update from the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to identify records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to be upserted",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the list of property names to determine uniqueness",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to be upserted",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to check if the record exists",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int delete(final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to identify records to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as delete operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.ReadOnlyCrudDao",
          "name": "ReadOnlyCrudDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A completely read-only CRUD Data Access Object interface that prevents all data modification operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "ReadOnlyCrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default ID insert(final T entityToInsert) throws UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default ID insert(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity whose properties will be bound to the named parameters (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities whose properties will be bound to the named parameters (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities whose properties will be bound to the named parameters (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.ReadOnlyCrudDaoL",
          "name": "ReadOnlyCrudDaoL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only CRUD (Create, Read, Update, Delete) Data Access Object interface specifically designed for entities with {@code Long} type primary keys.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "ReadOnlyCrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.ReadOnlyCrudJoinEntityHelper",
          "name": "ReadOnlyCrudJoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only interface for handling join entity operations with CRUD DAOs.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "CrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.ReadOnlyCrudJoinEntityHelperL",
          "name": "ReadOnlyCrudJoinEntityHelperL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only interface for handling join entity operations with CRUD DAOs that use {@code Long} type primary keys.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "CrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.ReadOnlyDao",
          "name": "ReadOnlyDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A strictly read-only Data Access Object interface that only allows SELECT queries.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "ReadOnlyDao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@NonDBOperation @Override default PreparedQuery prepareQuery(final String query) throws SQLException, UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string to prepare (must be a SELECT statement)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT statement"
                }
              ],
              "javadoc_summary": "Prepares a SQL query for execution.",
              "contract": [
                "<p> The query string must be a valid SQL SELECT statement."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final boolean generateKeys) throws UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to retrieve auto-generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final int[] returnColumnIndexes) throws UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "an array of column indexes for returned keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default PreparedQuery prepareQuery(final String query, final String[] returnColumnNames) throws UnsupportedOperationException",
              "return_type": "PreparedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "query",
                  "type": "String",
                  "javadoc": "the SQL query string",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "an array of column names for returned keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters (must be a SELECT statement)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the specified query is not a SELECT statement"
                }
              ],
              "javadoc_summary": "Prepares a named parameter SQL query for execution.",
              "contract": [
                "<p> Named parameters can appear multiple times in the query and will all be set to the same value when the parameter is bound."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final boolean generateKeys) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to retrieve auto-generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final int[] returnColumnIndexes) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "an array of column indexes for returned keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final String namedQuery, final String[] returnColumnNames) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "String",
                  "javadoc": "the SQL query string with named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "an array of column names for returned keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery) throws SQLException, UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the pre-parsed SQL query object (must represent a SELECT statement)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.sql.SQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the query is not a SELECT statement"
                }
              ],
              "javadoc_summary": "Prepares a named query using a pre-parsed SQL object.",
              "contract": [
                "This method is useful when you have already parsed a named query and want to avoid the overhead of parsing it again."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final boolean generateKeys) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the parsed SQL query with named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "generateKeys",
                  "type": "boolean",
                  "javadoc": "{@code true} to retrieve auto-generated keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final int[] returnColumnIndexes) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the parsed SQL query with named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnIndexes",
                  "type": "int[]",
                  "javadoc": "an array of column indexes for returned keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "prepareNamedQuery",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default NamedQuery prepareNamedQuery(final ParsedSql namedQuery, final String[] returnColumnNames) throws UnsupportedOperationException",
              "return_type": "NamedQuery",
              "type_params": [],
              "params": [
                {
                  "name": "namedQuery",
                  "type": "ParsedSql",
                  "javadoc": "the parsed SQL query with named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "returnColumnNames",
                  "type": "String[]",
                  "javadoc": "an array of column names for returned keys",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as key generation operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void save(final T entityToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void save(final T entityToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "collection of property names to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void save(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "collection of entities to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "collection of property names to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "collection of property names to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "collection of entities to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.ReadOnlyJoinEntityHelper",
          "name": "ReadOnlyJoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only interface for handling join entity operations in a Data Access Object (DAO) pattern.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "Dao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entity to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entity to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final String joinEntityPropName) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entity to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entity to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names of join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names of join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names of join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names of join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names of join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names of join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final T entity) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all join entities should be deleted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final T entity, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all join entities should be deleted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only mode.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedCrudDao",
          "name": "UncheckedCrudDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "The UncheckedCrudDao interface provides comprehensive CRUD (Create, Read, Update, Delete) operations with unchecked exceptions.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedCrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "generateId",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @NonDBOperation @Override default ID generateId() throws UncheckedSQLException, UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                },
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "if the operation is not supported (default behavior)"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is deprecated as ID generation should typically be handled by the database",
                "for_removal": false
              },
              "javadoc_summary": "Generates a new ID for entity insertion.",
              "contract": [
                "<p> This method should be overridden by implementations that support ID generation."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override ID insert(final T entityToInsert) throws UncheckedSQLException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (must not be null)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs or the entity is null"
                }
              ],
              "javadoc_summary": "Inserts the specified entity into the database and returns the generated ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws UncheckedSQLException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (must not be null)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement. If {@code null} or empty, all properties will be inserted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Inserts the specified entity with only the specified properties.",
              "contract": [
                "This is useful when you want to insert an entity with only certain fields populated."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override ID insert(final String namedInsertSql, final T entityToInsert) throws UncheckedSQLException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity whose properties will be bound to the named parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Inserts an entity using a custom named SQL insert statement.",
              "contract": [
                "The SQL should use named parameters that match the entity's property names."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<ID> batchInsert(final Collection<? extends T> entities) throws UncheckedSQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert of multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert of multiple entities with a specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws UncheckedSQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert with only specified properties for all entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws UncheckedSQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to insert",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the property names to include in the INSERT statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert with only specified properties and custom batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws UncheckedSQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities whose properties will be bound to the named parameters",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert using a custom named SQL statement with default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @Override List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named parameter SQL insert statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities whose properties will be bound to the named parameters",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the number of entities to process in each batch. The operation will split large collections into chunks of this size for optimal performance.",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs batch insert using a custom named SQL statement with specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalBoolean queryForBoolean(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalBoolean",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalBoolean} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean(\"isActive\", userId); if (isActive.isPresent() && isActive.getAsBoolean()) { // User is active } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForBoolean()"
              ]
            },
            {
              "name": "queryForChar",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalChar queryForChar(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalChar",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalChar} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalChar grade = userDao.queryForChar(\"grade\", studentId); if (grade.isPresent()) { System.out.println(\"Student grade: \" + grade.getAsChar()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForChar()"
              ]
            },
            {
              "name": "queryForByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalByte queryForByte(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalByte",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalByte} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalByte level = userDao.queryForByte(\"accessLevel\", userId); if (level.isPresent() && level.getAsByte() > 5) { // User has admin access } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForByte()"
              ]
            },
            {
              "name": "queryForShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalShort queryForShort(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalShort",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalShort} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalShort age = userDao.queryForShort(\"age\", userId); if (age.isPresent()) { System.out.println(\"User age: \" + age.getAsShort()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForShort()"
              ]
            },
            {
              "name": "queryForInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalInt queryForInt(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalInt",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalInt} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalInt loginCount = userDao.queryForInt(\"loginCount\", userId); if (loginCount.isPresent() && loginCount.getAsInt() > 100) { // Frequent user } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForInt()"
              ]
            },
            {
              "name": "queryForLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalLong queryForLong(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalLong",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalLong} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalLong totalBytes = userDao.queryForLong(\"storageUsed\", userId); if (totalBytes.isPresent()) { System.out.println(\"Storage used: \" + totalBytes.getAsLong() + \" bytes\"); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForLong()"
              ]
            },
            {
              "name": "queryForFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalFloat queryForFloat(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalFloat",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalFloat} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalFloat rating = userDao.queryForFloat(\"averageRating\", productId); if (rating.isPresent() && rating.getAsFloat() >= 4.5f) { // Highly rated product } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForFloat()"
              ]
            },
            {
              "name": "queryForDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalDouble queryForDouble(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "OptionalDouble",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalDouble} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalDouble balance = userDao.queryForDouble(\"accountBalance\", accountId); if (balance.isPresent()) { processPayment(balance.getAsDouble()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForDouble()"
              ]
            },
            {
              "name": "queryForString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<String> queryForString(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "Nullable<String>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<String>} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForString(\"email\", userId); if (email.isPresent()) { sendNotification(email.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForString()"
              ]
            },
            {
              "name": "queryForDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Date>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<java.sql.Date>} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<java.sql.Date> birthDate = userDao.queryForDate(\"birthDate\", userId); if (birthDate.isPresent()) { calculateAge(birthDate.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForDate()"
              ]
            },
            {
              "name": "queryForTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Time>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<java.sql.Time>} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<java.sql.Time> startTime = userDao.queryForTime(\"workStartTime\", employeeId); if (startTime.isPresent()) { scheduleShift(startTime.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForTime()"
              ]
            },
            {
              "name": "queryForTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Timestamp>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<java.sql.Timestamp>} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<java.sql.Timestamp> lastLogin = userDao.queryForTimestamp(\"lastLoginTime\", userId); if (lastLogin.isPresent()) { updateActivity(lastLogin.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForTimestamp()"
              ]
            },
            {
              "name": "queryForBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<byte[]> queryForBytes(final String singleSelectPropName, final ID id) throws UncheckedSQLException",
              "return_type": "Nullable<byte[]>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<byte[]>} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<byte[]> avatar = userDao.queryForBytes(\"profileImage\", userId); if (avatar.isPresent()) { displayImage(avatar.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForBytes()"
              ]
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws UncheckedSQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueClass",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<V>} describing the value of a single property for the entity with the specified ID, converted to the specified target type.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<BigDecimal> price = userDao.queryForSingleResult(\"price\", productId, BigDecimal.class); if (price.isPresent()) { applyDiscount(price.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleResult(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueClass",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the non-null value of a single property for the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleNonNull(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the function to map the result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the non-null value mapped by the row mapper for the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleNonNull(Class)"
              ]
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueClass",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable} describing the value of a single property for the entity with the specified ID.",
              "contract": [
                "Throws {@code DuplicatedResultException} if more than one record is found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Assuming email should be unique per user Nullable<String> email = userDao.queryForUniqueResult(\"email\", userId, String.class); } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueResult(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Class<? extends V> targetValueClass) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueClass",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the unique non-null value of a single property for the entity with the specified ID.",
              "contract": [
                "Throws {@code DuplicatedResultException} if more than one record is found."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final ID id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the function to map the result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the unique non-null value mapped by the row mapper for the entity with the specified ID.",
              "contract": [
                "Throws {@code DuplicatedResultException} if more than one record is found."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> get(final ID id) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> get(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, or {@code null} to select all",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID, selecting only the specified properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override T gett(final ID id) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID.",
              "contract": [
                "Returns the entity directly or {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); if (user != null) { processUser(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override T gett(final ID id, final Collection<String> selectPropNames) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, or {@code null} to select all",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID, selecting only the specified properties.",
              "contract": [
                "Returns the entity directly or {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId, Arrays.asList(\"id\", \"email\", \"status\")); if (user != {@code null} && \"ACTIVE\".equals(user.getStatus())) { sendEmail(user.getEmail()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<T> batchGet(final Collection<? extends ID> ids) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Gets multiple entities by their IDs in batch using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<T> batchGet(final Collection<? extends ID> ids, final int batchSize) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Gets multiple entities by their IDs in batch using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, or {@code null} to select all",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Gets multiple entities by their IDs with only the specified properties selected.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final int batchSize) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Gets multiple entities by their IDs with only the specified properties selected, using the specified batch size for efficient querying.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override boolean exists(final ID id) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to check",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID exists in the database.",
              "contract": [
                "Checks if an entity with the specified ID exists in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(userId)) { // User exists, proceed with update userDao.update(\"lastAccess\", new Date(), userId); } else { // User doesn't exist, create new userDao.insert(new User(userId)); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#exists()"
              ]
            },
            {
              "name": "notExists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default boolean notExists(final ID id) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID to check",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID does not exist in the database.",
              "contract": [
                "Checks if an entity with the specified ID does not exist in the database.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(userId)) { // User doesn't exist, safe to create userDao.insert(new User(userId)); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#notExists()"
              ]
            },
            {
              "name": "count",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @Override int count(final Collection<? extends ID> ids) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs to count",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Counts the number of entities with the specified IDs.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code List<Long> requestedIds = Arrays.asList(1L, 2L, 3L, 4L, 5L); int existingCount = userDao.count(requestedIds); if (existingCount < requestedIds.size()) { // Some users don't exist } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int update(final T entityToUpdate) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "the entity containing the values to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates the specified entity in the database.",
              "contract": [
                "The entity must have its ID set."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "the entity containing the values to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the properties to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates only the specified properties of the entity in the database.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int update(final String propName, final Object propValue, final ID id) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates a single property value for the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int update(final Map<String, Object> updateProps, final ID id) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates multiple properties for the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int batchUpdate(final Collection<? extends T> entities) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch updates multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch updates multiple entities using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the properties to update for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch updates only the specified properties of multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the properties to update for each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch updates only the specified properties of multiple entities using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T upsert(final T entity) throws UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.",
              "contract": [
                "Performs an upsert operation: inserts the entity if it doesn't exist based on ID fields, otherwise updates the existing entity.",
                "The entity must have ID field(s) defined."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify the record",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Performs an upsert operation: inserts the entity if it doesn't exist based on the specified unique properties, otherwise updates the existing entity.",
              "contract": [
                "Performs an upsert operation: inserts the entity if it doesn't exist based on the specified unique properties, otherwise updates the existing entity.",
                "If no record matches the unique properties, inserts the entity."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T upsert(final T entity, final Condition cond) throws UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to insert or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to check for existing record",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes an upsert operation based on the specified condition.",
              "contract": [
                "If no record matches the condition, inserts the entity."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<T> batchUpsert(final Collection<? extends T> entities) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch upserts multiple entities using the default batch size.",
              "contract": [
                "Entities are inserted if they don't exist (based on ID), otherwise updated."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch upserts multiple entities using the specified batch size.",
              "contract": [
                "Entities are inserted if they don't exist (based on ID), otherwise updated."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify each record",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch upserts multiple entities based on the specified unique properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to upsert",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the property names that uniquely identify each record",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch upserts multiple entities based on the specified unique properties using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "refresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default boolean refresh(final T entity) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to refresh (must have ID set)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes the specified entity by reloading all its properties from the database.",
              "contract": [
                "The entity must have its ID set.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = new User(); user.setId(123L); boolean found = userDao.refresh(user); if (found) { // User now contains all current values from database System.out.println(\"User email: \" + user.getEmail()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "refresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @SuppressWarnings(\"deprecation\") default boolean refresh(final T entity, final Collection<String> propNamesToRefresh) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to refresh (must have ID set)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToRefresh",
                  "type": "Collection<String>",
                  "javadoc": "the properties to refresh from the database",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Refreshes only the specified properties of the entity from the database.",
              "contract": [
                "The entity must have its ID set."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int batchRefresh(final Collection<? extends T> entities) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch refreshes multiple entities from the database using the default batch size.",
              "contract": [
                "Each entity must have its ID set."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int batchRefresh(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch refreshes multiple entities from the database using the specified batch size.",
              "contract": [
                "Each entity must have its ID set."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToRefresh",
                  "type": "Collection<String>",
                  "javadoc": "the properties to refresh for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch refreshes only the specified properties of multiple entities using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchRefresh",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @SuppressWarnings(\"deprecation\") default int batchRefresh(final Collection<? extends T> entities, final Collection<String> propNamesToRefresh, final int batchSize) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to refresh",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToRefresh",
                  "type": "Collection<String>",
                  "javadoc": "the properties to refresh for each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch refreshes only the specified properties of multiple entities using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int delete(final T entity) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to delete (must have ID set)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes the specified entity from the database.",
              "contract": [
                "The entity must have its ID set.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(userId); int deletedRows = userDao.delete(user); if (deletedRows > 0) { System.out.println(\"User deleted successfully\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int deleteById(final ID id) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the ID of the entity to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes the entity with the specified ID from the database.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code int deletedRows = userDao.deleteById(userId); if (deletedRows == 0) { System.out.println(\"User not found\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int batchDelete(final Collection<? extends T> entities) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch deletes multiple entities from the database using the default batch size.",
              "contract": [
                "Each entity must have its ID set."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int batchDelete(final Collection<? extends T> entities, final int batchSize) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch deletes multiple entities from the database using the specified batch size.",
              "contract": [
                "Each entity must have its ID set."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int batchDeleteByIds(final Collection<? extends ID> ids) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch deletes entities by their IDs using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch deletes entities by their IDs using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedCrudDaoL",
          "name": "UncheckedCrudDaoL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A specialized CrudDao interface that uses {@code Long} as the ID type with unchecked exception handling.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedCrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "queryForBoolean",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalBoolean queryForBoolean(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalBoolean",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a boolean value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalBoolean if no record is found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean(\"isActive\", 123L); if (isActive.isPresent() && isActive.getAsBoolean()) { System.out.println(\"User is active\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForChar",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalChar queryForChar(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalChar",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a char value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalChar if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForByte",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalByte queryForByte(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalByte",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalByte if no record is found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalByte level = userDao.queryForByte(\"level\", 123L); if (level.isPresent() && level.getAsByte() >= 5) { // User has sufficient level } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForShort",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalShort queryForShort(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalShort",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a short value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalShort if no record is found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalShort year = userDao.queryForShort(\"birthYear\", 123L); if (year.isPresent()) { int age = currentYear - year.getAsShort(); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForInt",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalInt queryForInt(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalInt",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for an integer value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalInt if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForLong",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalLong queryForLong(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalLong",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a long value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalLong if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForFloat",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalFloat queryForFloat(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalFloat",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a float value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalFloat if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDouble",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default OptionalDouble queryForDouble(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "OptionalDouble",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a double value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns an empty OptionalDouble if no record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForString",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Nullable<String> queryForString(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "Nullable<String>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a String value from a single property of the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForString(\"email\", 123L); if (email.isPresent()) { sendNotification(email.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForDate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Date>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Date value from a single property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTime",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Time>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Time value from a single property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForTimestamp",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Timestamp>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a Timestamp value from a single property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBytes",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Nullable<byte[]> queryForBytes(final String singleSelectPropName, final long id) throws UncheckedSQLException",
              "return_type": "Nullable<byte[]>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a byte array value from a single property of the entity with the specified ID.",
              "contract": [
                "Returns a Nullable containing the value, which can be {@code null} if the database value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws UncheckedSQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single value of the specified type from a property of the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single non-null value of the specified type from a property of the entity.",
              "contract": [
                "Returns an empty Optional if no record is found or if the value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the custom mapper to transform the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a single non-null value using a custom row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique single result of the specified type.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the value type to convert to",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique non-null result of the specified type.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found.",
                "Returns empty Optional if no record found or value is {@code null} ."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final long id, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the primitive long ID of the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the custom mapper to transform the result",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Queries for a unique non-null result using a custom row mapper.",
              "contract": [
                "Throws DuplicatedResultException if more than one record is found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> get(final long id) throws UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> get(final long id, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, or {@code null} to select all",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID, selecting only the specified properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T gett(final long id) throws UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID, returning it directly or {@code null} if not found.",
              "contract": [
                "Retrieves the entity with the specified ID, returning it directly or {@code null} if not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = userDao.gett(123L); if (user != null) { processUser(user); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T gett(final long id, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select, or {@code null} to select all",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves the entity with the specified ID and selected properties, returning it directly or {@code null} if not found.",
              "contract": [
                "Retrieves the entity with the specified ID and selected properties, returning it directly or {@code null} if not found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "exists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default boolean exists(final long id) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID exists.",
              "contract": [
                "Checks if an entity with the specified ID exists.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.exists(123L)) { // User exists } else { // Create new user } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "notExists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default boolean notExists(final long id) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if an entity with the specified ID does not exist.",
              "contract": [
                "Checks if an entity with the specified ID does not exist.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code if (userDao.notExists(123L)) { // Safe to create new user with this ID } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int update(final String propName, final Object propValue, final long id) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates a single property value for the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int update(final Map<String, Object> updateProps, final long id) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates multiple properties for the entity with the specified ID.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int deleteById(final long id) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes the entity with the specified ID.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code int deleted = userDao.deleteById(123L); if (deleted > 0) { System.out.println(\"User deleted successfully\"); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedCrudJoinEntityHelper",
          "name": "UncheckedCrudJoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "The UncheckedCrudJoinEntityHelper interface combines CRUD operations with join entity management capabilities, providing a comprehensive solution for handling entities with relationships.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedCrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default Optional<T> get(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID and loads the specified join entity class.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with their orders loaded Optional<User> user = userDao.get(userId, Order.class); if (user.isPresent()) { List<Order> orders = user.get().getOrders(); // Orders are already loaded } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default Optional<T> get(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID with selected properties and loads the specified join entity class.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default Optional<T> get(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID with selected properties and loads multiple join entity classes.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default Optional<T> get(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID with selected properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default T gett(final ID id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID and loads the specified join entity class, returning the entity directly.",
              "contract": [
                "This is a beta API that returns {@code null} if the entity is not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with orders, returns {@code null} if not found User user = userDao.gett(userId, Order.class); if (user != null) { // Process user with loaded orders } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default T gett(final ID id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID and optionally loads all join entities, returning the entity directly.",
              "contract": [
                "This is a beta API that returns {@code null} if the entity is not found.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with all relationships User user = userDao.gett(userId, true); if (user != null) { // All relationships are loaded } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default T gett(final ID id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID with selected properties and loads the specified join entity class.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default T gett(final ID id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID with selected properties and loads multiple join entity classes.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default T gett(final ID id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "the entity ID",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Retrieves an entity by ID with selected properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities by IDs and loads the specified join entity class for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities by IDs and optionally loads all join entities for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities with selected properties and loads the specified join entity class.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities with selected properties and loads multiple join entity classes.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities with selected properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load for each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch for processing",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities with selected properties using a specific batch size and loads the specified join entity class.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final int batchSize) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch for processing",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities with selected properties using a specific batch size and loads multiple join entity classes.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchGet",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> batchGet(final Collection<? extends ID> ids, final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final int batchSize) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "the collection of entity IDs",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entities, excluding join entity properties. If {@code null} , all properties of the main entities are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch for processing",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if the size of result is bigger than the size of input IDs"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch gets entities with selected properties using a specific batch size and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedCrudJoinEntityHelperL",
          "name": "UncheckedCrudJoinEntityHelperL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A specialized interface for CRUD operations with join entity support, specifically designed for entities with {@link Long} type primary keys.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedCrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default Optional<T> get(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and loads the specified join entity class.",
              "contract": [
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Fetch a user and load their orders Optional<User> userWithOrders = userDao.get(123L, Order.class); if (userWithOrders.isPresent()) { User user = userWithOrders.get(); List<Order> orders = user.getOrders(); // Orders are already loaded } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default Optional<T> get(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with the option to load all associated join entities.",
              "contract": [
                "<p> When {@code includeAllJoinEntities} is {@code true} , all mapped relationships will be loaded.",
                "This is useful when you need the complete object graph but should be used carefully to avoid performance issues with large datasets."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "The properties (columns) to select from the main entity. If {@code null} , all properties are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "The class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with specific properties and loads the specified join entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "The properties (columns) to select from the main entity. If {@code null} , all properties are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "Collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with specific properties and loads multiple join entity types.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "get",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default Optional<T> get(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "The properties (columns) to select from the main entity. If {@code null} , all properties are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with specific properties and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default T gett(final long id, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "The class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID and loads the specified join entity class, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID and loads the specified join entity class, returning {@code null} if not found.",
                "It returns {@code null} if the entity is not found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get a user with orders loaded User user = userDao.gett(123L, Order.class); if (user != null) { List<Order> orders = user.getOrders(); // Orders are already loaded } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default T gett(final long id, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "If {@code true} , loads all mapped join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with the option to load all join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with the option to load all join entities, returning {@code null} if not found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get a complete user object graph User fullUser = userDao.gett(123L, true); if (fullUser != null) { // All relationships are loaded } // Get just the user without relationships User userOnly = userDao.gett(123L, false); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default T gett(final long id, final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "The class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with specific properties and loads the specified join entity, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with specific properties and loads the specified join entity, returning {@code null} if not found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get essential user data with orders User user = userDao.gett(123L, Arrays.asList(\"id\", \"name\", \"email\"), Order.class); if (user != null) { // Process user with orders } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default T gett(final long id, final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "Collection of join entity classes to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with specific properties and loads multiple join entity types, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with specific properties and loads multiple join entity types, returning {@code null} if not found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get user with specific fields and multiple relationships User user = userDao.gett(123L, Arrays.asList(\"id\", \"name\", \"email\", \"createdDate\"), Arrays.asList(Order.class, Address.class, Preference.class)); if (user != null) { // User has limited fields but all specified relationships are loaded List<Order> orders = user.getOrders(); List<Address> addresses = user.getAddresses(); } } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "gett",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Beta default T gett(final long id, final Collection<String> selectPropNames, final boolean includeAllJoinEntities) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "The primary key value of the entity to retrieve",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "If {@code true} , loads all mapped join entities",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found by the specified {@code id}"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "If any SQL error occurs during the operation"
                }
              ],
              "javadoc_summary": "Retrieves an entity by its ID with specific properties and optionally loads all join entities, returning {@code null} if not found.",
              "contract": [
                "Retrieves an entity by its ID with specific properties and optionally loads all join entities, returning {@code null} if not found.",
                "</p> <p> <b> Usage Examples: </b> </p> <pre> {@code // Get minimal user data but with all relationships User user = userDao.gett(123L, Arrays.asList(\"id\", \"name\"), // Only these fields true); // But load all join entities if (user != null) { // Process user with all relationships } // Get complete user data without any relationships User userOnly = userDao.gett(123L, {@code null}, // All fields false); // No join entities } </pre>"
              ],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedDao",
          "name": "UncheckedDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Interface for an unchecked Data Access Object (DAO) that extends the base DAO interface.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedDao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void save(final T entityToSave) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Saves the specified entity to the database.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void save(final T entityToSave, final Collection<String> propNamesToSave) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the properties to save, or {@code null} to save all properties",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Saves the specified entity with only the specified properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void save(final String namedInsertSql, final T entityToSave) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Saves the entity using a named insert SQL statement.",
              "contract": [
                "The SQL statement should contain named parameters that will be populated from the entity properties."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void batchSave(final Collection<? extends T> entitiesToSave) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves the specified entities to the database using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "CrudDao#batchInsert(Collection)"
              ]
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves the specified entities to the database using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "CrudDao#batchInsert(Collection)"
              ]
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the properties to save for each entity",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves the specified entities with only the specified properties using the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "CrudDao#batchInsert(Collection)"
              ]
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the properties to save for each entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves the specified entities with only the specified properties using the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "CrudDao#batchInsert(Collection)"
              ]
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to save",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves entities using a named insert SQL statement with the default batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "CrudDao#batchInsert(Collection)"
              ]
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Beta @Override void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL statement",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the collection of entities to save",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the size of each batch",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Batch saves entities using a named insert SQL statement with the specified batch size.",
              "contract": [],
              "examples": [],
              "see_also": [
                "CrudDao#batchInsert(Collection)"
              ]
            },
            {
              "name": "exists",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override boolean exists(final Condition cond) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if any records exist that match the specified condition.",
              "contract": [
                "Checks if any records exist that match the specified condition."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#exists()"
              ]
            },
            {
              "name": "notExists",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default boolean notExists(final Condition cond) throws UncheckedSQLException",
              "return_type": "boolean",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Checks if no records exist that match the specified condition.",
              "contract": [
                "Checks if no records exist that match the specified condition."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#notExists()"
              ]
            },
            {
              "name": "count",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int count(final Condition cond) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Counts the number of records that match the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Optional<T> findFirst(final Condition cond) throws UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds and returns the first record that matches the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findFirst(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result set row to the desired type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first record matching the condition and maps it using the provided row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findFirst(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map the result set row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first record matching the condition and maps it using the provided bi-row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Optional<T> findFirst(final Collection<String> selectPropNames, final Condition cond) throws UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first record matching the condition, selecting only the specified properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first record matching the condition with selected properties and maps it using the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findFirst(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map the result set row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first record matching the condition with selected properties and maps it using the bi-row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Optional<T> findOnlyOne(final Condition cond) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record matching the condition.",
              "contract": [
                "Throws an exception if multiple records are found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record matching the condition and maps it using the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findOnlyOne(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map the result set row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record matching the condition and maps it using the bi-row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Condition cond) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record matching the condition, selecting only the specified properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record with selected properties and maps it using the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> Optional<R> findOnlyOne(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map the result set row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one record with selected properties and maps it using the bi-row mapper.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "queryForBoolean",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalBoolean queryForBoolean(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalBoolean",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalBoolean} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalBoolean} describing the value in the first row/column if it exists.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code OptionalBoolean isActive = userDao.queryForBoolean(\"isActive\", Filters.eq(\"id\", 1)); if (isActive.isPresent() && isActive.getAsBoolean()) { // User is active } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForBoolean()"
              ]
            },
            {
              "name": "queryForChar",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalChar queryForChar(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalChar",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalChar} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalChar} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForChar()"
              ]
            },
            {
              "name": "queryForByte",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalByte queryForByte(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalByte",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalByte} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalByte} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForByte()"
              ]
            },
            {
              "name": "queryForShort",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalShort queryForShort(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalShort",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalShort} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalShort} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForShort()"
              ]
            },
            {
              "name": "queryForInt",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalInt queryForInt(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalInt",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalInt} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalInt} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForInt()"
              ]
            },
            {
              "name": "queryForLong",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalLong queryForLong(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalLong",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalLong} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalLong} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForLong()"
              ]
            },
            {
              "name": "queryForFloat",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalFloat queryForFloat(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalFloat",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalFloat} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalFloat} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForFloat()"
              ]
            },
            {
              "name": "queryForDouble",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override OptionalDouble queryForDouble(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "OptionalDouble",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code OptionalDouble} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code OptionalDouble} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForDouble()"
              ]
            },
            {
              "name": "queryForString",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<String> queryForString(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "Nullable<String>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<String>} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns a {@code Nullable<String>} describing the value in the first row/column if it exists.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code Nullable<String> email = userDao.queryForString(\"email\", Filters.eq(\"username\", \"john_doe\")); if (email.isPresent()) { sendEmail(email.get()); } } </pre>"
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForString()"
              ]
            },
            {
              "name": "queryForDate",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<java.sql.Date> queryForDate(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Date>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<java.sql.Date>} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns a {@code Nullable<java.sql.Date>} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForDate()"
              ]
            },
            {
              "name": "queryForTime",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<java.sql.Time> queryForTime(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Time>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<java.sql.Time>} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns a {@code Nullable<java.sql.Time>} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForTime()"
              ]
            },
            {
              "name": "queryForTimestamp",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<java.sql.Timestamp> queryForTimestamp(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "Nullable<java.sql.Timestamp>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<java.sql.Timestamp>} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns a {@code Nullable<java.sql.Timestamp>} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForTimestamp()"
              ]
            },
            {
              "name": "queryForBytes",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Nullable<byte[]> queryForBytes(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "Nullable<byte[]>",
              "type_params": [],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<byte[]>} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns a {@code Nullable<byte[]>} describing the value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForBytes()"
              ]
            },
            {
              "name": "queryForSingleResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Nullable<V> queryForSingleResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws UncheckedSQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable<V>} describing the value in the first row/column if it exists, converted to the specified target type.",
              "contract": [
                "Returns a {@code Nullable<V>} describing the value in the first row/column if it exists, converted to the specified target type."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleResult(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the non-null value in the first row/column if it exists.",
              "contract": [
                "Returns an {@code Optional} describing the non-null value in the first row/column if it exists."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleNonNull(Class)"
              ]
            },
            {
              "name": "queryForSingleNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForSingleNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the function to map the result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the non-null value mapped by the row mapper.",
              "contract": [],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForSingleNonNull(Class)"
              ]
            },
            {
              "name": "queryForUniqueResult",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Nullable<V> queryForUniqueResult(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Nullable<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a {@code Nullable} describing the value in the first row/column if it exists.",
              "contract": [
                "Returns a {@code Nullable} describing the value in the first row/column if it exists.",
                "Throws {@code DuplicatedResultException} if more than one record is found."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueResult(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Class<? extends V> targetValueType) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "targetValueType",
                  "type": "Class<? extends V>",
                  "javadoc": "the class of the target value type",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the unique non-null value in the first row/column.",
              "contract": [
                "Throws {@code DuplicatedResultException} if more than one record is found."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "queryForUniqueNonNull",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <V> Optional<V> queryForUniqueNonNull(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends V> rowMapper) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<V>",
              "type_params": [
                {
                  "name": "V",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends V>",
                  "javadoc": "the function to map the result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns an {@code Optional} describing the unique non-null value mapped by the row mapper.",
              "contract": [
                "Throws {@code DuplicatedResultException} if more than one record is found."
              ],
              "examples": [],
              "see_also": [
                "AbstractQuery#queryForUniqueNonNull(Class)"
              ]
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Dataset query(final Condition cond) throws UncheckedSQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and returns the results as a Dataset containing all matching records.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override Dataset query(final Collection<String> selectPropNames, final Condition cond) throws UncheckedSQLException",
              "return_type": "Dataset",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query selecting only specified properties and returns the results as a Dataset.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> R query(final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "the function to extract results from the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and processes the result set using the provided result extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.ResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.ResultExtractor<? extends R>",
                  "javadoc": "the function to extract results from the ResultSet",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query with selected properties and processes the result set using the result extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> R query(final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "the function to extract results with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query and processes the result set using the bi-result extractor which receives column labels.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "query",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> R query(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiResultExtractor<? extends R> resultExtractor) throws UncheckedSQLException",
              "return_type": "R",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "resultExtractor",
                  "type": "Jdbc.BiResultExtractor<? extends R>",
                  "javadoc": "the function to extract results with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes a query with selected properties and processes using the bi-result extractor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override List<T> list(final Condition cond) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of all entities matching the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map each result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of results mapped by the provided row mapper for records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map each result set row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of results mapped by the bi-row mapper for records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the predicate to filter rows before mapping",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map filtered result set rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list of results mapped by the row mapper for records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the bi-predicate to filter rows with column labels",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map filtered rows with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list using bi-row filter and bi-row mapper for records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override List<T> list(final Collection<String> selectPropNames, final Condition cond) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of entities with only selected properties for records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map each result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of mapped results with selected properties for records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map each row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of mapped results using bi-row mapper with selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the predicate to filter rows before mapping",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered and mapped list with selected properties for records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override <R> List<R> list(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the bi-predicate to filter rows with column labels",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.BiRowMapper<? extends R>",
                  "javadoc": "the function to map filtered rows with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered and mapped list using bi-filters and bi-mappers with selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <R> List<R> list(final String singleSelectPropName, final Condition cond) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of values for a single property from records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map the single column value",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a list of mapped values for a single property from records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default <R> List<R> list(final String singleSelectPropName, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowMapper<? extends R> rowMapper) throws UncheckedSQLException",
              "return_type": "List<R>",
              "type_params": [
                {
                  "name": "R",
                  "bounds": [
                    "java.lang.Object"
                  ]
                }
              ],
              "params": [
                {
                  "name": "singleSelectPropName",
                  "type": "String",
                  "javadoc": "the single property name to select",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the predicate to filter rows before mapping",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowMapper",
                  "type": "Jdbc.RowMapper<? extends R>",
                  "javadoc": "the function to map filtered values",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Returns a filtered list of mapped values for a single property from records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Condition cond, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to process each result set row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through all records matching the condition and processes each row with the row consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the bi-consumer to process each row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through records using a bi-row consumer that receives column labels.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to process filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through filtered records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the bi-predicate to filter rows with column labels",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the bi-consumer to process filtered rows with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through filtered records using bi-row filter and bi-row consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to process each row",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through records with selected properties matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the bi-consumer to process each row with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through records with selected properties using a bi-row consumer.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.RowFilter rowFilter, final Jdbc.RowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.RowFilter",
                  "javadoc": "the predicate to filter rows",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.RowConsumer",
                  "javadoc": "the consumer to process filtered rows",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through filtered records with selected properties.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "forEach",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void forEach(final Collection<String> selectPropNames, final Condition cond, final Jdbc.BiRowFilter rowFilter, final Jdbc.BiRowConsumer rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected, or {@code null} to select all",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowFilter",
                  "type": "Jdbc.BiRowFilter",
                  "javadoc": "the bi-predicate to filter rows with column labels",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Jdbc.BiRowConsumer",
                  "javadoc": "the bi-consumer to process filtered rows with column labels",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Iterates through filtered records with selected properties using bi-row filter and consumer.",
              "contract": [
                "<p> <b> Usage Examples: </b> </p> <pre> {@code userDao.forEach( Arrays.asList(\"id\", \"email\", \"preferences\"), Filters.eq(\"active\", true), (rs, cols) -> shouldReceiveNotification(rs.getString(\"preferences\")), (rs, cols) -> queueNotification(rs.getLong(\"id\"), rs.getString(\"email\")) ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "foreach",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void foreach(final Collection<String> selectPropNames, final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "the consumer that receives row data as DisposableObjArray",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Processes each record with selected properties using a consumer that receives DisposableObjArray.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "foreach",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void foreach(final Condition cond, final Consumer<DisposableObjArray> rowConsumer) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                },
                {
                  "name": "rowConsumer",
                  "type": "Consumer<DisposableObjArray>",
                  "javadoc": "the consumer that receives row data as DisposableObjArray",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Processes each record matching the condition using a consumer that receives DisposableObjArray.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int update(final String propName, final Object propValue, final Condition cond) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value for the property",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates a single property value for all records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int update(final Map<String, Object> updateProps, final Condition cond) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "a map of property names to their new values",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates multiple properties for all records matching the condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int update(final T entity, final Condition cond) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing values to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates all records matching the condition with values from the specified entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing values to update",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the properties to update from the entity",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records to update",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Updates records matching the condition with specified properties from the entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to add or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the list of property names that uniquely identify the record",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes an upsert operation: inserts the entity if no record matches the unique properties, otherwise updates the existing record.",
              "contract": [
                "Executes an upsert operation: inserts the entity if no record matches the unique properties, otherwise updates the existing record."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default T upsert(final T entity, final Condition cond) throws UncheckedSQLException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to add or update",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to verify if the record exists",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Executes an upsert operation: inserts the entity if no record matches the condition, otherwise updates the existing record.",
              "contract": [
                "Executes an upsert operation: inserts the entity if no record matches the condition, otherwise updates the existing record."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int delete(final Condition cond) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all records that match the specified condition.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedJoinEntityHelper",
          "name": "UncheckedJoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "The UncheckedJoinEntityHelper interface provides advanced functionality for handling entity relationships and join operations in DAOs with unchecked exceptions.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedDao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> findFirst(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first entity matching the condition and loads the specified join entity class.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> findFirst(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first entity matching the condition and loads multiple join entity classes.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findFirst",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> findFirst(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds the first entity matching the condition and optionally loads all join entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found for the specified condition"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one entity matching the condition and loads the specified join entity class.",
              "contract": [
                "Throws an exception if multiple entities are found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found for the specified condition"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one entity matching the condition and loads multiple join entity classes.",
              "contract": [
                "Throws an exception if multiple entities are found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "findOnlyOne",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default Optional<T> findOnlyOne(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws DuplicatedResultException, UncheckedSQLException",
              "return_type": "Optional<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.DuplicatedResultException",
                  "condition": "if more than one record is found for the specified condition"
                },
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Finds exactly one entity matching the condition and optionally loads all join entities.",
              "contract": [
                "Throws an exception if multiple entities are found."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> list(final Collection<String> selectPropNames, final Class<?> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all entities matching the condition and loads the specified join entity class for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> list(final Collection<String> selectPropNames, final Collection<Class<?>> joinEntitiesToLoad, final Condition cond) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntitiesToLoad",
                  "type": "Collection<Class<?>>",
                  "javadoc": "the collection of join entity classes to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all entities matching the condition and loads multiple join entity classes for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "list",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default List<T> list(final Collection<String> selectPropNames, final boolean includeAllJoinEntities, final Condition cond) throws UncheckedSQLException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to select from the main entity, excluding join entity properties. If {@code null} , all properties of the main entity are selected",
                  "nullability": "unspecified"
                },
                {
                  "name": "includeAllJoinEntities",
                  "type": "boolean",
                  "javadoc": "if {@code true} , all join entities will be loaded; if {@code false} , no join entities are loaded",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Lists all entities matching the condition and optionally loads all join entities for each.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntities(final T entity, final Class<?> joinEntityClass) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class for a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadJoinEntities(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class with selected properties for a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class for multiple entities in batch.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class with selected properties for multiple entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntities(final T entity, final String joinEntityPropName) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property name of a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void loadJoinEntities(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load join entities for. Must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. This parameter is useful for performance optimization when only specific fields are needed",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs (wraps {@link java.sql.SQLException} )"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property name with selected properties for a single entity.",
              "contract": [
                "</p> <p> The implementation should handle both collection-type properties (List, Set, etc.) and single-entity properties."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property name for multiple entities in batch.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override void loadJoinEntities(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load join entities for. Can be empty but not {@code null} . If empty, this method returns immediately",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected. Specifying only needed properties can significantly improve query performance and reduce memory usage",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs (wraps {@link java.sql.SQLException} )"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property name with selected properties for multiple entities.",
              "contract": [],
              "performance": "</p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, this method executes O(1) queries instead of O(N) </li> <li> Large collections may be automatically batched to prevent excessive memory usage </li> <li> Selecting fewer properties via {@code selectPropNames} can significantly improve performance </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = userDao.batchGet(userIds); // Load address property with selected fields for all users userDao.loadJoinEntities( users, \"addresses\", Arrays.asList(\"street\", \"city\", \"country\", \"isPrimary\") ); // Use in stream operations without try-catch users.stream() .peek(u -> userDao.loadJoinEntities(u, \"orders\", null)) .filter(u -> u.getOrders().size() > 5) .collect(Collectors.toList()); } </pre>",
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for multiple property names of a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for multiple property names of a single entity, optionally in parallel.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default void loadJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for multiple property names using a custom executor for parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for multiple property names for multiple entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for multiple property names for multiple entities, optionally in parallel.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default void loadJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for multiple property names for multiple entities using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadAllJoinEntities(final T entity) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load all join entities for",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities defined in the entity class for a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadAllJoinEntities(final T entity, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity, optionally in parallel.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadAllJoinEntities(final T entity, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for a single entity using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadAllJoinEntities(final Collection<T> entities) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load all join entities for",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for multiple entities in batch.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for multiple entities, optionally in parallel.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadAllJoinEntities(final Collection<T> entities, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities for multiple entities using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class only if they are currently {@code null} .",
              "contract": [
                "Loads join entities of the specified class only if they are currently {@code null} .",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getCachedUser(); // Only load orders if not already loaded userDao.loadJoinEntitiesIfNull(user, Order.class); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadJoinEntitiesIfNull(final T entity, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class with selected properties only if they are currently {@code null} .",
              "contract": [
                "Loads join entities of the specified class with selected properties only if they are currently {@code null} .",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getPartiallyLoadedUser(); // Load profile with specific fields if not already loaded userDao.loadJoinEntitiesIfNull( user, UserProfile.class, Arrays.asList(\"bio\", \"avatarUrl\", \"preferences\") ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class for multiple entities only where they are {@code null} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Class<?> joinEntityClass, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities of the specified class with selected properties for multiple entities only where they are {@code null} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property only if it is currently {@code null} .",
              "contract": [
                "Loads join entities for a specific property only if it is currently {@code null} .",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getUser(); // Only load profile if user.getProfile() is null userDao.loadJoinEntitiesIfNull(user, \"profile\"); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final T entity, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property with selected fields only if the property is {@code null} .",
              "contract": [
                "Loads join entities for a specific property with selected fields only if the property is {@code null} .",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getUser(); // Load addresses with specific fields if not already loaded userDao.loadJoinEntitiesIfNull( user, \"addresses\", Arrays.asList(\"street\", \"city\", \"postalCode\") ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property for multiple entities only where the property is {@code null} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final String joinEntityPropName, final Collection<String> selectPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "selectPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the properties (columns) to be selected from the join entities. If {@code null} , all properties of the join entities are selected",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads join entities for a specific property with selected fields for multiple entities only where {@code null} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join properties only if they are {@code null} for a single entity.",
              "contract": [
                "Loads multiple join properties only if they are {@code null} for a single entity.",
                "<p> <b> Usage Examples: </b> </p> <pre> {@code User user = getPartialUser(); // Load multiple properties if not already loaded userDao.loadJoinEntitiesIfNull( user, Arrays.asList(\"orders\", \"profile\", \"preferences\") ); } </pre>"
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join properties only if they are {@code null} , optionally in parallel.",
              "contract": [
                "Loads multiple join properties only if they are {@code null} , optionally in parallel."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default void loadJoinEntitiesIfNull(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join properties only if they are {@code null} using a custom executor.",
              "contract": [
                "Loads multiple join properties only if they are {@code null} using a custom executor."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join properties for multiple entities only where they are {@code null} .",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join properties for multiple entities only where {@code null} , optionally in parallel.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to load",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads multiple join properties for multiple entities only where {@code null} using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadJoinEntitiesIfNull(final T entity) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load all join entities for",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities only if they are {@code null} for a single entity.",
              "contract": [
                "Loads all join entities only if they are {@code null} for a single entity."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntitiesIfNull(final T entity, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities only if they are {@code null} , optionally in parallel.",
              "contract": [
                "Loads all join entities only if they are {@code null} , optionally in parallel."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntitiesIfNull(final T entity, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to conditionally load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities only if they are {@code null} using a custom executor.",
              "contract": [
                "Loads all join entities only if they are {@code null} using a custom executor."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default void loadJoinEntitiesIfNull(final Collection<T> entities) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load all join entities for",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities only if they are {@code null} for multiple entities.",
              "contract": [
                "Loads all join entities only if they are {@code null} for multiple entities."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are loaded in parallel; if {@code false} , loaded sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities only if they are {@code null} for multiple entities, optionally in parallel.",
              "contract": [
                "Loads all join entities only if they are {@code null} for multiple entities, optionally in parallel."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "loadJoinEntitiesIfNull",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Beta @Override default void loadJoinEntitiesIfNull(final Collection<T> entities, final Executor executor) throws UncheckedSQLException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities to conditionally load all join entities for",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Loads all join entities only if they are {@code null} for multiple entities using a custom executor.",
              "contract": [
                "Loads all join entities only if they are {@code null} for multiple entities using a custom executor."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities of the specified class related to the given entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities of the specified class for multiple entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int deleteJoinEntities(final T entity, final String joinEntityPropName) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted. Must not be {@code null}",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs (wraps {@link java.sql.SQLException} )"
                }
              ],
              "javadoc_summary": "Deletes join entities for a specific property name of a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "public"
              ],
              "signature": "@Override int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted. Can be empty but not {@code null} . If empty, this method returns 0 immediately",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name of the join entities to delete. Must be a valid property name that exists in the entity class and is annotated with {@code @JoinedBy}",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs (wraps {@link java.sql.SQLException} )"
                }
              ],
              "javadoc_summary": "Deletes join entities for a specific property name for multiple entities.",
              "contract": [],
              "performance": "</p> <p> Performance characteristics: </p> <ul> <li> For N parent entities, executes O(1) or O(N/batch_size) DELETE statements instead of O(N) </li> <li> Much more efficient than deleting join entities one parent at a time </li> <li> The actual number of deleted records may be less than or greater than the number of parent entities </li> </ul> <p> Important notes: </p> <ul> <li> This operation does NOT modify the in-memory join properties of the entities </li> <li> All deletions are permanent unless executed within a transaction </li> <li> For transactional deletion of multiple properties, use {@link #deleteJoinEntities(Collection, Collection)} </li> </ul> <p> <b> Usage Examples: </b> </p> <pre> {@code List<User> users = getDeactivatedUsers(); // Delete all payment methods for these users int totalDeleted = userDao.deleteJoinEntities(users, \"paymentMethods\"); // Use in stream context int deletedOrders = userDao.list(Filters.eq(\"status\", \"INACTIVE\")) .stream() .collect(Collectors.collectingAndThen( Collectors.toList(), list -> userDao.deleteJoinEntities(list, \"orders\") )); } </pre>",
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes join entities for multiple property names of a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when it's executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes join entities for multiple property names of a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes join entities for multiple property names of a single entity in parallel (deprecated).",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes join entities for multiple property names for multiple entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes join entities for multiple property names for multiple entities in parallel (deprecated).",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the property names of the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when it's executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes join entities for multiple property names for multiple entities using a custom executor (deprecated).",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default int deleteAllJoinEntities(final T entity) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all join entities should be deleted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities for a single entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for a single entity, optionally in parallel (deprecated).",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteAllJoinEntities(final T entity, final Executor executor) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when it's executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for a single entity using a custom executor (deprecated).",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@SuppressWarnings(\"deprecation\") @Override default int deleteAllJoinEntities(final Collection<T> entities) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all join entities should be deleted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "javadoc_summary": "Deletes all join entities for multiple entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "if {@code true} , entities are deleted in parallel; if {@code false} , deleted sequentially",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction if {@code inParallel} is {@code true}",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for multiple entities, optionally in parallel (deprecated).",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Beta @Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws UncheckedSQLException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "com.landawn.abacus.exception.UncheckedSQLException",
                  "condition": "if a database access error occurs"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation may not complete in a single transaction when it's executed in multiple threads",
                "for_removal": false
              },
              "javadoc_summary": "Deletes all join entities for multiple entities using a custom executor (deprecated).",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedNoUpdateCrudDao",
          "name": "UncheckedNoUpdateCrudDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A specialized CRUD DAO interface that disables update operations while allowing read, insert, and delete operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedNoUpdateCrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entityToUpdate) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "The entity to update (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entityToUpdate, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entityToUpdate",
                  "type": "T",
                  "javadoc": "The entity containing updated values (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "Collection of property names to update (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default int update(final String propName, final Object propValue, final ID id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "The name of the property to update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "The new value for the property (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "The ID of the entity to update (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final Map<String, Object> updateProps, final ID id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "Map of property names to their new values (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "The ID of the entity to update (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to update (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The batch size for the operation (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "Properties to update in each entity (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [
                "Consider using a different DAO type if update operations are required for your use case."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpdate",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchUpdate(final Collection<? extends T> entities, final Collection<String> propNamesToUpdate, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "Properties to update in each entity (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The batch size for the operation (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [
                "This DAO type ensures that once data is inserted, it cannot be modified, only deleted if necessary."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "The entity to insert or update (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [
                "If a record already exists, it must be deleted first before inserting a new version."
              ],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "The entity to insert or update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "Property names used to check for existing records (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "The entity to insert or update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "Condition to check for existing records (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to upsert (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as batch upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to upsert (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The batch size for the operation (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as batch upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to upsert (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "Property names for conflict detection (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as batch upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchUpsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default List<T> batchUpsert(final Collection<? extends T> entities, final List<String> uniquePropNamesForQuery, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<T>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to upsert (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "Property names for conflict detection (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The batch size for the operation (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown as batch upsert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int delete(final T entity) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "The entity to delete (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown to maintain API consistency"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@link #deleteById(Object)} or other delete methods instead",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteById(final ID id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "ID",
                  "javadoc": "The ID of the entity to delete (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown to maintain API consistency"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use other delete methods that are not deprecated",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDelete(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to delete (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown to maintain API consistency"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@link #batchDeleteByIds(Collection)} or condition-based delete methods",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDelete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDelete(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "Collection of entities to delete (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The batch size for the operation (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown to maintain API consistency"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use {@link #batchDeleteByIds(Collection, int)} or condition-based delete methods",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "Collection of IDs to delete (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown to maintain API consistency"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use condition-based delete methods instead",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchDeleteByIds",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int batchDeleteByIds(final Collection<? extends ID> ids, final int batchSize) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "ids",
                  "type": "Collection<? extends ID>",
                  "javadoc": "Collection of IDs to delete (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "The batch size for the operation (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "Always thrown to maintain API consistency"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "Use condition-based delete methods instead",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedNoUpdateCrudDaoL",
          "name": "UncheckedNoUpdateCrudDaoL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A no-update CRUD DAO interface that uses {@code Long} as the ID type with unchecked exception handling.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedNoUpdateCrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final String propName, final Object propValue, final long id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final Map<String, Object> updateProps, final long id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "the properties to update (operation will fail)",
                  "nullability": "unspecified"
                },
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteById",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteById(final long id) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "id",
                  "type": "long",
                  "javadoc": "the entity ID as primitive long (operation will fail)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as delete operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported and will always throw an exception",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedNoUpdateDao",
          "name": "UncheckedNoUpdateDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "Interface for an unchecked Data Access Object (DAO) that disables update and delete operations while allowing read and insert operations.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedNoUpdateDao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Override @Deprecated default int update(final String propName, final Object propValue, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "propName",
                  "type": "String",
                  "javadoc": "the property name to update (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propValue",
                  "type": "Object",
                  "javadoc": "the new value (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final Map<String, Object> updateProps, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "updateProps",
                  "type": "Map<String, Object>",
                  "javadoc": "the properties to update (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entity, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing values to update (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "update",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int update(final T entity, final Collection<String> propNamesToUpdate, final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity containing values to update (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToUpdate",
                  "type": "Collection<String>",
                  "javadoc": "the properties to update (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final List<String> uniquePropNamesForQuery) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to upsert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "uniquePropNamesForQuery",
                  "type": "List<String>",
                  "javadoc": "the unique properties for query (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "upsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default T upsert(final T entity, final Condition cond) throws UnsupportedOperationException",
              "return_type": "T",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity to upsert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to verify existence (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as update operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "delete",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int delete(final Condition cond) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "cond",
                  "type": "Condition",
                  "javadoc": "the condition to match records to delete (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as delete operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in no-update DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in no-update DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudDao",
          "name": "UncheckedReadOnlyCrudDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only CRUD DAO interface that provides only query operations without any insert, update, or delete capabilities.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedReadOnlyCrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default ID insert(final T entityToInsert) throws UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default ID insert(final T entityToInsert, final Collection<String> propNamesToInsert) throws UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "entityToInsert",
                  "type": "T",
                  "javadoc": "the entity to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the properties to insert (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "insert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default ID insert(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException",
              "return_type": "ID",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in a read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to insert (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the batch size (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the properties to insert (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final Collection<? extends T> entities, final Collection<String> propNamesToInsert, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToInsert",
                  "type": "Collection<String>",
                  "javadoc": "the properties to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the batch size (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to insert (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchInsert",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default List<ID> batchInsert(final String namedInsertSql, final Collection<? extends T> entities, final int batchSize) throws UnsupportedOperationException",
              "return_type": "List<ID>",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entities",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to insert (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the batch size (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as insert operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudDaoL",
          "name": "UncheckedReadOnlyCrudDaoL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only CRUD DAO interface that uses {@code Long} as the ID type with unchecked exception handling.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedReadOnlyCrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudJoinEntityHelper",
          "name": "UncheckedReadOnlyCrudJoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A specialized interface that combines read-only operations with join entity support for CRUD DAOs with unchecked exceptions.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "ID",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedCrudDao<T, ID, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedReadOnlyCrudJoinEntityHelperL",
          "name": "UncheckedReadOnlyCrudJoinEntityHelperL",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only CRUD DAO interface with join entity helper capabilities that uses primitive {@code long} for ID operations and throws unchecked exceptions.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedCrudDaoL<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedReadOnlyDao",
          "name": "UncheckedReadOnlyDao",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only DAO interface that provides only query operations without any write capabilities.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedReadOnlyDao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void save(final T entityToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void save(final T entityToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the properties to save (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "save",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void save(final String namedInsertSql, final T entityToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entityToSave",
                  "type": "T",
                  "javadoc": "the entity to save (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to save (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to save (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the batch size (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to save (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the properties to save (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final Collection<? extends T> entitiesToSave, final Collection<String> propNamesToSave, final int batchSize) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to save (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "propNamesToSave",
                  "type": "Collection<String>",
                  "javadoc": "the properties to save (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the batch size (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to save (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "batchSave",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default void batchSave(final String namedInsertSql, final Collection<? extends T> entitiesToSave, final int batchSize) throws UnsupportedOperationException",
              "return_type": "void",
              "type_params": [],
              "params": [
                {
                  "name": "namedInsertSql",
                  "type": "String",
                  "javadoc": "the named insert SQL (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "entitiesToSave",
                  "type": "Collection<? extends T>",
                  "javadoc": "the entities to save (ignored)",
                  "nullability": "unspecified"
                },
                {
                  "name": "batchSize",
                  "type": "int",
                  "javadoc": "the batch size (ignored)",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as save operations are not supported"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only DAO",
                "for_removal": false
              },
              "javadoc_summary": "This operation is not supported in read-only DAO.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        },
        {
          "fqn": "com.landawn.abacus.jdbc.dao.UncheckedReadOnlyJoinEntityHelper",
          "name": "UncheckedReadOnlyJoinEntityHelper",
          "kind": "interface",
          "modifiers": [
            "public"
          ],
          "javadoc_summary": "A read-only interface for managing join entity relationships in database operations without checked exceptions.",
          "thread_safety": "unspecified",
          "nullability": "unspecified",
          "type_params": [
            {
              "name": "T",
              "bounds": [
                "java.lang.Object"
              ]
            },
            {
              "name": "SB",
              "bounds": [
                "SQLBuilder"
              ]
            },
            {
              "name": "TD",
              "bounds": [
                "UncheckedDao<T, SB, TD>"
              ]
            }
          ],
          "constructors": [],
          "methods": [
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Class<?> joinEntityClass) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete join entities of a specific class related to the given entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Class<?> joinEntityClass) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityClass",
                  "type": "Class<?>",
                  "javadoc": "the class of the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete join entities of a specific class related to the given collection of entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final String joinEntityPropName) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name identifying the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete join entities identified by property name related to the given entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final String joinEntityPropName) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropName",
                  "type": "String",
                  "javadoc": "the property name identifying the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete join entities identified by property name related to the given collection of entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names identifying the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete multiple types of join entities identified by property names related to the given entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names identifying the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "whether to execute the deletions in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete multiple types of join entities with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final T entity, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names identifying the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete multiple types of join entities using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names identifying the join entities to delete",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete multiple types of join entities for a collection of entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names identifying the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "whether to execute the deletions in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete multiple types of join entities for a collection of entities with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteJoinEntities(final Collection<T> entities, final Collection<String> joinEntityPropNames, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "joinEntityPropNames",
                  "type": "Collection<String>",
                  "javadoc": "the collection of property names identifying the join entities to delete",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete multiple types of join entities for a collection of entities using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final T entity) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all related join entities should be deleted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete all join entities related to the given entity.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final T entity, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "whether to execute the deletions in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete all join entities related to the given entity with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final T entity, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entity",
                  "type": "T",
                  "javadoc": "the entity whose all related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete all join entities related to the given entity using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all related join entities should be deleted",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete all join entities related to the given collection of entities.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final boolean inParallel) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "inParallel",
                  "type": "boolean",
                  "javadoc": "whether to execute the deletions in parallel",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete all join entities related to the given collection of entities with optional parallel execution.",
              "contract": [],
              "examples": [],
              "see_also": []
            },
            {
              "name": "deleteAllJoinEntities",
              "kind": "instance",
              "modifiers": [
                "default",
                "public"
              ],
              "signature": "@Deprecated @Override default int deleteAllJoinEntities(final Collection<T> entities, final Executor executor) throws UnsupportedOperationException",
              "return_type": "int",
              "type_params": [],
              "params": [
                {
                  "name": "entities",
                  "type": "Collection<T>",
                  "javadoc": "the collection of entities whose all related join entities should be deleted",
                  "nullability": "unspecified"
                },
                {
                  "name": "executor",
                  "type": "Executor",
                  "javadoc": "the {@code Executor} to use for parallel execution",
                  "nullability": "unspecified"
                }
              ],
              "throws": [
                {
                  "type": "java.lang.UnsupportedOperationException",
                  "condition": "always thrown as this is a read-only interface"
                }
              ],
              "deprecated": {
                "is_deprecated": true,
                "message": "This operation is not supported in read-only mode",
                "for_removal": false
              },
              "javadoc_summary": "Attempts to delete all join entities related to the given collection of entities using a custom executor.",
              "contract": [],
              "examples": [],
              "see_also": []
            }
          ],
          "fields": []
        }
      ]
    }
  ]
}
